<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>面试算法题 汇总</title>
    <link href="/p/f5cc/"/>
    <url>/p/f5cc/</url>
    
    <content type="html"><![CDATA[<p>面试算法题 汇总</p><span id="more"></span><h2 id="链表与树"><a class="markdownIt-Anchor" href="#链表与树"></a> 链表与树</h2><h3 id="25-k-个一组翻转链表"><a class="markdownIt-Anchor" href="#25-k-个一组翻转链表"></a> <a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a></h3><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 翻转一个子链表，并且返回新的头与尾</span><br>    <span class="hljs-function">pair&lt;ListNode *, ListNode *&gt; <span class="hljs-title">reverse</span><span class="hljs-params">(ListNode *head, ListNode *tail)</span> </span>&#123;<br>        ListNode *prev = tail-&gt;next;<br>        ListNode *p = head;<br>        <span class="hljs-keyword">while</span> (prev != tail) &#123;<br>            ListNode *nex = p-&gt;next;<br>            p-&gt;next = prev;<br>            prev = p;<br>            p = nex;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;tail, head&#125;;<br>    &#125;<br><br>    <span class="hljs-function">ListNode *<span class="hljs-title">reverseKGroup</span><span class="hljs-params">(ListNode *head, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        ListNode *hair = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        hair-&gt;next = head;<br>        ListNode *pre = hair;<br><br>        <span class="hljs-keyword">while</span> (head) &#123;<br>            ListNode *tail = pre;<br>            <span class="hljs-comment">// 查看剩余部分长度是否大于等于 k</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>                tail = tail-&gt;next;<br>                <span class="hljs-keyword">if</span> (!tail) &#123;<br>                    <span class="hljs-keyword">return</span> hair-&gt;next;<br>                &#125;<br>            &#125;<br>            ListNode *nex = tail-&gt;next;<br>            pair&lt;ListNode *, ListNode *&gt; result = <span class="hljs-built_in">reverse</span>(head, tail);<br>            head = result.first;<br>            tail = result.second;<br>            <span class="hljs-comment">// 把子链表重新接回原链表</span><br>            pre-&gt;next = head;<br>            tail-&gt;next = nex;<br>            pre = tail;<br>            head = tail-&gt;next;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> hair-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="113-路径总和-ii"><a class="markdownIt-Anchor" href="#113-路径总和-ii"></a> <a href="https://leetcode-cn.com/problems/path-sum-ii/">113. 路径总和 II</a></h3><p>DFS。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ret;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> targetSum)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        path.<span class="hljs-built_in">emplace_back</span>(root-&gt;val);<br>        targetSum -= root-&gt;val;<br>        <span class="hljs-keyword">if</span> (root-&gt;left == <span class="hljs-literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="hljs-literal">nullptr</span> &amp;&amp; targetSum == <span class="hljs-number">0</span>) &#123;<br>            ret.<span class="hljs-built_in">emplace_back</span>(path);<br>        &#125;<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left, targetSum);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right, targetSum);<br>        path.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">pathSum</span>(TreeNode* root, <span class="hljs-type">int</span> targetSum) &#123;<br>        <span class="hljs-built_in">dfs</span>(root, targetSum);<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="92-反转链表-ii"><a class="markdownIt-Anchor" href="#92-反转链表-ii"></a> <a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">92. 反转链表 II</a></h3><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">reverseBetween</span><span class="hljs-params">(ListNode *head, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        ListNode *hair = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        hair-&gt;next = head;<br><br>        ListNode *pre = hair;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; left - <span class="hljs-number">1</span>; i++) &#123;<br>            pre = pre-&gt;next;<br>        &#125;<br><br>        <span class="hljs-comment">// 第 2 步：从 pre 再走 right - left + 1 步，来到 right 节点</span><br>        ListNode *leftNode=pre-&gt;next,*rightNode = pre;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; right - left + <span class="hljs-number">1</span>; i++) &#123;<br>            rightNode = rightNode-&gt;next;<br>        &#125;<br><br>        ListNode *curr = rightNode-&gt;next;<br><br>        pre-&gt;next = <span class="hljs-literal">nullptr</span>;<br>        rightNode-&gt;next = <span class="hljs-literal">nullptr</span>;<br><br>        <span class="hljs-built_in">reverse</span>(leftNode);<br><br>        pre-&gt;next = rightNode;<br>        leftNode-&gt;next = curr;<br>        <span class="hljs-keyword">return</span> hair-&gt;next;<br>    &#125;<br><br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverse</span><span class="hljs-params">(ListNode *head)</span></span>&#123;<br>        ListNode *pre=<span class="hljs-literal">NULL</span>,*p=head,*next;<br>        <span class="hljs-keyword">while</span>(p)&#123;<br>            next=p-&gt;next;<br>            p-&gt;next=pre;<br>            pre=p;<br>            p=next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="剑指-offer-ii-046-二叉树的右侧视图"><a class="markdownIt-Anchor" href="#剑指-offer-ii-046-二叉树的右侧视图"></a> <a href="https://leetcode-cn.com/problems/WNC0Lk/">剑指 Offer II 046. 二叉树的右侧视图</a></h3><p>右视图需要的是每一行最右侧的元素，而如果用DFS来遍历，并且后访问右节点，永远是该行最右侧的节点最后被访问。</p><p>所以我们可以直接用数组保存每行最后访问到的节点</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightSideView</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-built_in">preOrder</span>(root, <span class="hljs-number">0</span>, ans);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(TreeNode *root, <span class="hljs-type">int</span> depth, vector&lt;<span class="hljs-type">int</span>&gt; &amp;ans)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (depth == ans.<span class="hljs-built_in">size</span>())<br>            ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>        ans[depth] = root-&gt;val;<br>        depth++;<br>        <span class="hljs-built_in">preOrder</span>(root-&gt;left, depth, ans);<br>        <span class="hljs-built_in">preOrder</span>(root-&gt;right, depth, ans);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="98-验证二叉搜索树"><a class="markdownIt-Anchor" href="#98-验证二叉搜索树"></a> <a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h3><p>根据二叉搜索树性质，我们知道中序遍历二叉搜索树时，一定会得到升序序列。</p><p>这里我们维护一个pre变量，来将遍历到的元素与上一个元素比较，判断是否为升序</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> pre = LONG_LONG_MIN;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">inOrder</span>(root);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">bool</span> left = <span class="hljs-built_in">inOrder</span>(root-&gt;left);<br>        <span class="hljs-keyword">if</span> (root-&gt;val &lt;= pre)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        pre = root-&gt;val;<br>        <span class="hljs-type">bool</span> right = <span class="hljs-built_in">inOrder</span>(root-&gt;right);<br>        <span class="hljs-keyword">return</span> left &amp;&amp; right;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="剑指-offer-52-两个链表的第一个公共节点"><a class="markdownIt-Anchor" href="#剑指-offer-52-两个链表的第一个公共节点"></a> <a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">剑指 Offer 52. 两个链表的第一个公共节点</a></h3><p>本题运用双指针。</p><blockquote><p>怎么让两个速度相同，跑道不同的人相遇？</p><p>答案是交换他们的跑道</p></blockquote><p>我们让两个指针分别从两条链表的头开始向后走，当其中一个链表走到尾端（即指向为空）时，让其从另一个链表头开始再走一遍，直到俩链表相遇或是都为空。</p><p>假设A链表长为A，B链表长为B，公共区域长为C。</p><p>从A出发的指针pA走完时，长度为A+C，相对的，pB走完时长度为B+C。</p><p>这时交换他们的跑道，pA走A+C+B，pB走B+C+A，因他们速度相同，要么在交点相遇，要么都走到空节点，此时返回他们指向的节点即可。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>        ListNode *aPtr = headA, *bPtr = headB;<br>        <span class="hljs-keyword">while</span> (aPtr &amp;&amp; bPtr) &#123;<br>            <span class="hljs-comment">//如果相同，则找到第一个公共节点</span><br>            <span class="hljs-keyword">if</span> (aPtr == bPtr)<br>                <span class="hljs-keyword">return</span> aPtr;<br>            aPtr = aPtr-&gt;next;<br>            bPtr = bPtr-&gt;next;<br>            <span class="hljs-comment">//如果都为空，说明无公共节点</span><br>            <span class="hljs-keyword">if</span> (!aPtr &amp;&amp; !bPtr)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>            <span class="hljs-comment">//两个指针走到尽头时，分别切换到另一个链表上</span><br>            <span class="hljs-keyword">if</span> (!aPtr)<br>                aPtr = headB;<br>            <span class="hljs-keyword">if</span> (!bPtr)<br>                bPtr = headA;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="145-二叉树的后序遍历"><a class="markdownIt-Anchor" href="#145-二叉树的后序遍历"></a> <a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a></h3><p>递归较简单，这里我们用迭代。顺带复习一下DFS。</p><p>使用栈储存节点，map或者set储存已访问的节点。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    stack&lt;TreeNode *&gt; stack;<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>    map&lt;TreeNode *, <span class="hljs-type">bool</span>&gt; isVisited;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root)<br>            <span class="hljs-keyword">return</span> ans;<br>        stack.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!stack.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-comment">//标记访问到的节点</span><br>            isVisited[stack.<span class="hljs-built_in">top</span>()] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">//非空且未访问过，入栈</span><br>            <span class="hljs-keyword">if</span> (stack.<span class="hljs-built_in">top</span>()-&gt;left &amp;&amp; !isVisited.<span class="hljs-built_in">count</span>(stack.<span class="hljs-built_in">top</span>()-&gt;left)) &#123;<br>                stack.<span class="hljs-built_in">push</span>(stack.<span class="hljs-built_in">top</span>()-&gt;left);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">//同上</span><br>            <span class="hljs-keyword">if</span> (stack.<span class="hljs-built_in">top</span>()-&gt;right &amp;&amp; !isVisited.<span class="hljs-built_in">count</span>(stack.<span class="hljs-built_in">top</span>()-&gt;right)) &#123;<br>                stack.<span class="hljs-built_in">push</span>(stack.<span class="hljs-built_in">top</span>()-&gt;right);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">//因为是后序，最后输出值并出栈</span><br>            ans.<span class="hljs-built_in">push_back</span>(stack.<span class="hljs-built_in">top</span>()-&gt;val);<br>            stack.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="102-二叉树的层序遍历"><a class="markdownIt-Anchor" href="#102-二叉树的层序遍历"></a> <a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h3><p>层序遍历我们一般使用队列，从左向右遍历时，将下一层的节点加入队列。</p><p>此题需要我们进行分层，我们便在while语句中进一步用for来细化各层，将开启每一层时队列的大小当作循环条件。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    queue&lt;TreeNode *&gt; queue;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode *root) &#123;<br>        <span class="hljs-keyword">if</span> (!root)<br>            <span class="hljs-keyword">return</span> ans;<br>        queue.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!queue.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-comment">//保存该层的大小</span><br>            <span class="hljs-type">int</span> levelSize = queue.<span class="hljs-built_in">size</span>();<br>            ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; levelSize; ++i) &#123;<br>                TreeNode *node = queue.<span class="hljs-built_in">front</span>();<br>                ans.<span class="hljs-built_in">back</span>().<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>                <span class="hljs-keyword">if</span> (node-&gt;left)<br>                    queue.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span> (node-&gt;right)<br>                    queue.<span class="hljs-built_in">push</span>(node-&gt;right);<br>                queue.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="23-合并k个升序链表"><a class="markdownIt-Anchor" href="#23-合并k个升序链表"></a> <a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">23. 合并K个升序链表</a></h3><p>先看如何合并两个链表</p><ul><li>可以使用额外头节点 head，方便操作。返回结果时返回 <code>head-&gt;next</code>。</li><li>使用指针记录新链表遍历到的末尾位置，比较好结果后直接插入尾部。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ListNode *<span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode *aHead, ListNode *bHead)</span> </span>&#123;                      <br>    <span class="hljs-keyword">if</span> (!aHead || !bHead)                                                        <br>        <span class="hljs-keyword">return</span> aHead ? aHead : bHead;                                            <br>    ListNode *aPtr = aHead, *bPtr = bHead, *head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>), *tail = head;<br>    <span class="hljs-keyword">while</span> (aPtr &amp;&amp; bPtr) &#123;                                                       <br>        <span class="hljs-keyword">if</span> (aPtr-&gt;val &lt; bPtr-&gt;val) &#123;                                             <br>            tail-&gt;next = aPtr;                                                   <br>            aPtr = aPtr-&gt;next;                                                   <br>        &#125; <span class="hljs-keyword">else</span> &#123;                                                                 <br>            tail-&gt;next = bPtr;                                                   <br>            bPtr = bPtr-&gt;next;                                                   <br>        &#125;                                                                        <br>        tail = tail-&gt;next;                                                       <br>    &#125;                                                                            <br>    tail-&gt;next = (aPtr ? aPtr : bPtr);                                           <br>    <span class="hljs-keyword">return</span> head-&gt;next;                                                           <br>&#125;                                                                                <br></code></pre></td></tr></table></figure><p>对于 K 个链表，我们有两种方案：</p><p>1、顺序遍历</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode *a, ListNode *b)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> ((!a) || (!b)) <span class="hljs-keyword">return</span> a ? a : b;<br>        ListNode head, *tail = &amp;head, *aPtr = a, *bPtr = b;<br>        <span class="hljs-keyword">while</span> (aPtr &amp;&amp; bPtr) &#123;<br>            <span class="hljs-keyword">if</span> (aPtr-&gt;val &lt; bPtr-&gt;val) &#123;<br>                tail-&gt;next = aPtr; aPtr = aPtr-&gt;next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                tail-&gt;next = bPtr; bPtr = bPtr-&gt;next;<br>            &#125;<br>            tail = tail-&gt;next;<br>        &#125;<br>        tail-&gt;next = (aPtr ? aPtr : bPtr);<br>        <span class="hljs-keyword">return</span> head.next;<br>    &#125;<br><br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeKLists</span><span class="hljs-params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;<br>        ListNode *ans = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; lists.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            ans = <span class="hljs-built_in">mergeTwoLists</span>(ans, lists[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>2、分治</p><p>参考归并的思想，将 K 个链表先分，再治。</p><p>每一次合并返回合并好的链表。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">mergeKLists</span><span class="hljs-params">(vector&lt;ListNode *&gt; &amp;lists)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">merge</span>(lists, <span class="hljs-number">0</span>, lists.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function">ListNode *<span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode *aHead, ListNode *bHead)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!aHead || !bHead)<br>            <span class="hljs-keyword">return</span> aHead ? aHead : bHead;<br>        ListNode *aPtr = aHead, *bPtr = bHead, *head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>), *tail = head;<br>        <span class="hljs-keyword">while</span> (aPtr &amp;&amp; bPtr) &#123;<br>            <span class="hljs-keyword">if</span> (aPtr-&gt;val &lt; bPtr-&gt;val) &#123;<br>                tail-&gt;next = aPtr;<br>                aPtr = aPtr-&gt;next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                tail-&gt;next = bPtr;<br>                bPtr = bPtr-&gt;next;<br>            &#125;<br>            tail = tail-&gt;next;<br>        &#125;<br>        tail-&gt;next = (aPtr ? aPtr : bPtr);<br>        <span class="hljs-keyword">return</span> head-&gt;next;<br>    &#125;<br><br>    <span class="hljs-function">ListNode *<span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;ListNode *&gt; &amp;lists, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-comment">//分到单个链表时，返回该链表</span><br>        <span class="hljs-keyword">if</span> (l == r)<br>            <span class="hljs-keyword">return</span> lists[l];<br>        <span class="hljs-comment">//边界判断</span><br>        <span class="hljs-keyword">if</span> (l &gt; r)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">//返回合并好的链表</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">mergeTwoLists</span>(<span class="hljs-built_in">merge</span>(lists, l, mid), <span class="hljs-built_in">merge</span>(lists, mid + <span class="hljs-number">1</span>, r));<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="143-重排链表"><a class="markdownIt-Anchor" href="#143-重排链表"></a> <a href="https://leetcode-cn.com/problems/reorder-list/">143. 重排链表</a></h3><p>寻找链表中点 + 链表逆序 + 合并链表</p><p>注意到目标链表即为将原链表的左半端和反转后的右半端合并后的结果。</p><p>这样我们的任务即可划分为三步：</p><ol><li>找到原链表的中点。我们可以使用快慢指针来找到链表的中间节点。</li><li>将原链表的右半端反转。我们可以使用迭代法实现链表的反转。</li><li>将原链表的两端合并。因为两链表长度相差不超过 11，因此直接合并即可。</li></ol><p><strong>注意</strong></p><p>这里的合并并非有序合并，直接一步一步合并即可。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reorderList</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        ListNode *aTail = <span class="hljs-built_in">findMid</span>(head), *bHead = aTail-&gt;next;<br>        <span class="hljs-comment">//拆分链表</span><br>        aTail-&gt;next = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-comment">//反转 b 链表</span><br>        bHead = <span class="hljs-built_in">reverseList</span>(bHead);<br>        <span class="hljs-comment">//合并</span><br>        head = <span class="hljs-built_in">mergeTwoList</span>(head, bHead);<br>    &#125;<br><br>    <span class="hljs-function">ListNode *<span class="hljs-title">findMid</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        ListNode *fast = head, *slow = head;<br>        <span class="hljs-comment">//快慢指针，fast 走两步，slow 走一步</span><br>        <span class="hljs-keyword">while</span> (fast-&gt;next) &#123;<br>            fast = fast-&gt;next-&gt;next;<br>            <span class="hljs-comment">//如果 fast 为空，提前退出，避免在条件中对 fast 进行冗余判断出错</span><br>            <span class="hljs-keyword">if</span> (!fast)<br>                <span class="hljs-keyword">break</span>;<br>            slow = slow-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br><br>    <span class="hljs-function">ListNode *<span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!head)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        ListNode *pre = <span class="hljs-literal">NULL</span>, *p = head, *next = head-&gt;next;<br>        <span class="hljs-comment">//三指针遍历反转</span><br>        <span class="hljs-keyword">while</span> (p) &#123;<br>            next = p-&gt;next;<br>            p-&gt;next = pre;<br>            pre = p;<br>            p = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br><br>    <span class="hljs-function">ListNode *<span class="hljs-title">mergeTwoList</span><span class="hljs-params">(ListNode *aHead, ListNode *bHead)</span> </span>&#123;<br>        ListNode *head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>), *tail = head;<br>        ListNode *aPtr = aHead, *bPtr = bHead;<br>        <span class="hljs-keyword">while</span> (aPtr &amp;&amp; bPtr) &#123;<br>            <span class="hljs-comment">//合并 a 的一个元素</span><br>            tail-&gt;next = aPtr;<br>            aPtr = aPtr-&gt;next;<br>            tail = tail-&gt;next;<br>            <span class="hljs-comment">//合并 b 的一个元素</span><br>            tail-&gt;next = bPtr;<br>            bPtr = bPtr-&gt;next;<br>            tail = tail-&gt;next;<br>        &#125;<br>        tail-&gt;next = aPtr ? aPtr : bPtr;<br>        <span class="hljs-keyword">return</span> head-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="82-删除排序链表中的重复元素-ii"><a class="markdownIt-Anchor" href="#82-删除排序链表中的重复元素-ii"></a> <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/">82. 删除排序链表中的重复元素 II</a></h3><p>直接遍历。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!head) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <br>        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>, head);<br><br>        ListNode* cur = dummy;<br>        <span class="hljs-keyword">while</span> (cur-&gt;next &amp;&amp; cur-&gt;next-&gt;next) &#123;<br>            <span class="hljs-keyword">if</span> (cur-&gt;next-&gt;val == cur-&gt;next-&gt;next-&gt;val) &#123;<br>                <span class="hljs-type">int</span> x = cur-&gt;next-&gt;val;<br>                <span class="hljs-keyword">while</span> (cur-&gt;next &amp;&amp; cur-&gt;next-&gt;val == x) &#123;<br>                    cur-&gt;next = cur-&gt;next-&gt;next;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                cur = cur-&gt;next;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="剑指-offer-54-二叉搜索树的第k大节点"><a class="markdownIt-Anchor" href="#剑指-offer-54-二叉搜索树的第k大节点"></a> <a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">剑指 Offer 54. 二叉搜索树的第k大节点</a></h3><p>中序便利的逆序。</p><p>直接计数。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> ans, kNum;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kthLargest</span><span class="hljs-params">(TreeNode *root, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        kNum = k;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>        kNum--;<br>        <span class="hljs-keyword">if</span> (kNum == <span class="hljs-number">0</span>) &#123;<br>            ans = root-&gt;val;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="105-从前序与中序遍历序列构造二叉树"><a class="markdownIt-Anchor" href="#105-从前序与中序遍历序列构造二叉树"></a> <a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h3><p>前序得到根节点，到中序中分化左右子树。</p><p>在左右子树上继续递归。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; index;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">myBuildTree</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, <span class="hljs-type">int</span> preorder_left, <span class="hljs-type">int</span> preorder_right, <span class="hljs-type">int</span> inorder_left, <span class="hljs-type">int</span> inorder_right)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (preorder_left &gt; preorder_right) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 前序遍历中的第一个节点就是根节点</span><br>        <span class="hljs-type">int</span> preorder_root = preorder_left;<br>        <span class="hljs-comment">// 在中序遍历中定位根节点</span><br>        <span class="hljs-type">int</span> inorder_root = index[preorder[preorder_root]];<br>        <br>        <span class="hljs-comment">// 先把根节点建立出来</span><br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(preorder[preorder_root]);<br>        <span class="hljs-comment">// 得到左子树中的节点数目</span><br>        <span class="hljs-type">int</span> size_left_subtree = inorder_root - inorder_left;<br>        <span class="hljs-comment">// 递归地构造左子树，并连接到根节点</span><br>        <span class="hljs-comment">// 先序遍历中「从 左边界+1 开始的 size_left_subtree」个元素就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素</span><br>        root-&gt;left = <span class="hljs-built_in">myBuildTree</span>(preorder, inorder, preorder_left + <span class="hljs-number">1</span>, preorder_left + size_left_subtree, inorder_left, inorder_root - <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 递归地构造右子树，并连接到根节点</span><br>        <span class="hljs-comment">// 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素</span><br>        root-&gt;right = <span class="hljs-built_in">myBuildTree</span>(preorder, inorder, preorder_left + size_left_subtree + <span class="hljs-number">1</span>, preorder_right, inorder_root + <span class="hljs-number">1</span>, inorder_right);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = preorder.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 构造哈希映射，帮助我们快速定位根节点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            index[inorder[i]] = i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">myBuildTree</span>(preorder, inorder, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="数据结构"><a class="markdownIt-Anchor" href="#数据结构"></a> 数据结构</h2><h3 id="381-o1-时间插入-删除和获取随机元素-允许重复"><a class="markdownIt-Anchor" href="#381-o1-时间插入-删除和获取随机元素-允许重复"></a> <a href="https://leetcode-cn.com/problems/insert-delete-getrandom-o1-duplicates-allowed/">381. O(1) 时间插入、删除和获取随机元素 - 允许重复</a></h3><p>哈希表，额外维护数值在列表中<strong>每一次</strong>出现的下标集合。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RandomizedCollection</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    unordered_map&lt;<span class="hljs-type">int</span>, unordered_set&lt;<span class="hljs-type">int</span>&gt;&gt; idx;<br>    vector&lt;<span class="hljs-type">int</span>&gt; nums;<br><br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-built_in">RandomizedCollection</span>() &#123;<br><br>    &#125;<br>    <br>    <span class="hljs-comment">/** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>        nums.<span class="hljs-built_in">push_back</span>(val);<br>        idx[val].<span class="hljs-built_in">insert</span>(nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> idx[val].<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Removes a value from the collection. Returns true if the collection contained the specified element. */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (idx.<span class="hljs-built_in">find</span>(val) == idx.<span class="hljs-built_in">end</span>()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> i = *(idx[val].<span class="hljs-built_in">begin</span>());<br>        nums[i] = nums.<span class="hljs-built_in">back</span>();<br>        idx[val].<span class="hljs-built_in">erase</span>(i);<br>        idx[nums[i]].<span class="hljs-built_in">erase</span>(nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (i &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) &#123;<br>            idx[nums[i]].<span class="hljs-built_in">insert</span>(i);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (idx[val].<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) &#123;<br>            idx.<span class="hljs-built_in">erase</span>(val);<br>        &#125;<br>        nums.<span class="hljs-built_in">pop_back</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Get a random element from the collection. */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getRandom</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> nums[<span class="hljs-built_in">rand</span>() % nums.<span class="hljs-built_in">size</span>()];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="432-全-o1-的数据结构"><a class="markdownIt-Anchor" href="#432-全-o1-的数据结构"></a> <a href="https://leetcode-cn.com/problems/all-oone-data-structure/">432. 全 O(1) 的数据结构</a></h3><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AllOne</span> &#123;<br>    list&lt;pair&lt;unordered_set&lt;string&gt;, <span class="hljs-type">int</span>&gt;&gt; lst;<br>    unordered_map&lt;string, list&lt;pair&lt;unordered_set&lt;string&gt;, <span class="hljs-type">int</span>&gt;&gt;::iterator&gt; nodes;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">AllOne</span>() &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inc</span><span class="hljs-params">(string key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nodes.<span class="hljs-built_in">count</span>(key)) &#123;<br>            <span class="hljs-keyword">auto</span> cur = nodes[key], nxt = <span class="hljs-built_in">next</span>(cur);<br>            <span class="hljs-keyword">if</span> (nxt == lst.<span class="hljs-built_in">end</span>() || nxt-&gt;second &gt; cur-&gt;second + <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-function">unordered_set&lt;string&gt; <span class="hljs-title">s</span><span class="hljs-params">(&#123;key&#125;)</span></span>;<br>                nodes[key] = lst.<span class="hljs-built_in">emplace</span>(nxt, s, cur-&gt;second + <span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                nxt-&gt;first.<span class="hljs-built_in">emplace</span>(key);<br>                nodes[key] = nxt;<br>            &#125;<br>            cur-&gt;first.<span class="hljs-built_in">erase</span>(key);<br>            <span class="hljs-keyword">if</span> (cur-&gt;first.<span class="hljs-built_in">empty</span>()) &#123;<br>                lst.<span class="hljs-built_in">erase</span>(cur);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// key 不在链表中</span><br>            <span class="hljs-keyword">if</span> (lst.<span class="hljs-built_in">empty</span>() || lst.<span class="hljs-built_in">begin</span>()-&gt;second &gt; <span class="hljs-number">1</span>) &#123;<br>                unordered_set&lt;string&gt; <span class="hljs-built_in">s</span>(&#123;key&#125;);<br>                lst.<span class="hljs-built_in">emplace_front</span>(s, <span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                lst.<span class="hljs-built_in">begin</span>()-&gt;first.<span class="hljs-built_in">emplace</span>(key);<br>            &#125;<br>            nodes[key] = lst.<span class="hljs-built_in">begin</span>();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dec</span><span class="hljs-params">(string key)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> cur = nodes[key];<br>        <span class="hljs-keyword">if</span> (cur-&gt;second == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// key 仅出现一次，将其移出 nodes</span><br>            nodes.<span class="hljs-built_in">erase</span>(key);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">auto</span> pre = <span class="hljs-built_in">prev</span>(cur);<br>            <span class="hljs-keyword">if</span> (cur == lst.<span class="hljs-built_in">begin</span>() || pre-&gt;second &lt; cur-&gt;second - <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-function">unordered_set&lt;string&gt; <span class="hljs-title">s</span><span class="hljs-params">(&#123;key&#125;)</span></span>;<br>                nodes[key] = lst.<span class="hljs-built_in">emplace</span>(cur, s, cur-&gt;second - <span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                pre-&gt;first.<span class="hljs-built_in">emplace</span>(key);<br>                nodes[key] = pre;<br>            &#125;<br>        &#125;<br>        cur-&gt;first.<span class="hljs-built_in">erase</span>(key);<br>        <span class="hljs-keyword">if</span> (cur-&gt;first.<span class="hljs-built_in">empty</span>()) &#123;<br>            lst.<span class="hljs-built_in">erase</span>(cur);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function">string <span class="hljs-title">getMaxKey</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> lst.<span class="hljs-built_in">empty</span>() ? <span class="hljs-string">&quot;&quot;</span> : *lst.<span class="hljs-built_in">rbegin</span>()-&gt;first.<span class="hljs-built_in">begin</span>();<br>    &#125;<br><br>    <span class="hljs-function">string <span class="hljs-title">getMinKey</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> lst.<span class="hljs-built_in">empty</span>() ? <span class="hljs-string">&quot;&quot;</span> : *lst.<span class="hljs-built_in">begin</span>()-&gt;first.<span class="hljs-built_in">begin</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="146-lru-缓存"><a class="markdownIt-Anchor" href="#146-lru-缓存"></a> <a href="https://leetcode-cn.com/problems/lru-cache/">146. LRU 缓存</a></h3><p>LRU是最近最少使用算法，即扔掉最长时间未被使用的元素。我们不仅需要使用map存储键值对，还需要维护一个可更新使用频次的数据结构。</p><p>在这里我们使用双向链表，在每次更新某元素频次时，将其移动到链表头位置，所以链表的尾端就是最长时间未被使用的元素。</p><p>moveToHead直接实现较为复杂，所以我们可以将它拆分成removeNode和addToHead两部分，且两部分都可复用。</p><p>因为我们同时维护两个数据结构，所以不在removeTail中直接释放掉元素，需要拿到它的返回值以同步更新map。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>        <span class="hljs-type">int</span> key, value;<br>        Node *prev;<br>        Node *next;<br><br>        <span class="hljs-built_in">Node</span>() : <span class="hljs-built_in">key</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">value</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">prev</span>(<span class="hljs-literal">NULL</span>), <span class="hljs-built_in">next</span>(<span class="hljs-literal">NULL</span>) &#123;&#125;<br><br>        <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value) : <span class="hljs-built_in">key</span>(key), <span class="hljs-built_in">value</span>(value), <span class="hljs-built_in">prev</span>(<span class="hljs-literal">NULL</span>), <span class="hljs-built_in">next</span>(<span class="hljs-literal">NULL</span>) &#123;&#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">typedef</span> Node *PtrToNode;<br>    map&lt;<span class="hljs-type">int</span>, PtrToNode&gt; map;<br>    PtrToNode head, tail;<br>    <span class="hljs-type">int</span> size, cap;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LRUCache</span>(<span class="hljs-type">int</span> capacity) &#123;<br>        head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br>        tail = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br>        head-&gt;next = tail;<br>        tail-&gt;prev = head;<br>        size = <span class="hljs-number">0</span>;<br>        cap = capacity;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!map.<span class="hljs-built_in">count</span>(key)) &#123;<br>            <span class="hljs-comment">//key不存在</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-comment">//如果key存在</span><br>        PtrToNode p = map[key];<br>        <span class="hljs-built_in">moveToHead</span>(p);<br>        <span class="hljs-keyword">return</span> p-&gt;value;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!map.<span class="hljs-built_in">count</span>(key)) &#123;<br>            <span class="hljs-comment">//key不存在，向map和链表中添加元素</span><br>            PtrToNode node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(key, value);<br>            map[key] = node;<br>            <span class="hljs-built_in">addToHead</span>(node);<br>            size++;<br>            <span class="hljs-keyword">if</span> (size &gt; cap) &#123;<br>                <span class="hljs-comment">//超过容量删除缓存</span><br>                PtrToNode removed = <span class="hljs-built_in">removeTail</span>();<br>                map.<span class="hljs-built_in">erase</span>(removed-&gt;key);<br>                <span class="hljs-keyword">delete</span> removed;<br>                size--;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//key存在,覆盖value</span><br>            PtrToNode node = map[key];<br>            node-&gt;value = value;<br>            <span class="hljs-built_in">moveToHead</span>(node);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeNode</span><span class="hljs-params">(PtrToNode node)</span> </span>&#123;<br>        node-&gt;prev-&gt;next = node-&gt;next;<br>        node-&gt;next-&gt;prev = node-&gt;prev;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addToHead</span><span class="hljs-params">(PtrToNode node)</span> </span>&#123;<br>        head-&gt;next-&gt;prev = node;<br>        node-&gt;next = head-&gt;next;<br>        head-&gt;next = node;<br>        node-&gt;prev = head;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">moveToHead</span><span class="hljs-params">(PtrToNode node)</span> </span>&#123;<br>        <span class="hljs-built_in">removeNode</span>(node);<br>        <span class="hljs-built_in">addToHead</span>(node);<br>    &#125;<br><br>    <span class="hljs-function">PtrToNode <span class="hljs-title">removeTail</span><span class="hljs-params">()</span> </span>&#123;<br>        PtrToNode removed = tail-&gt;prev;<br>        <span class="hljs-built_in">removeNode</span>(tail-&gt;prev);<br>        <span class="hljs-keyword">return</span> removed;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your LRUCache object will be instantiated and called as such:</span><br><span class="hljs-comment"> * LRUCache* obj = new LRUCache(capacity);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;get(key);</span><br><span class="hljs-comment"> * obj-&gt;put(key,value);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h3 id="构造有序链表"><a class="markdownIt-Anchor" href="#构造有序链表"></a> 构造有序链表</h3><p>顺序查找和删除即可。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span> &#123;<br>        <span class="hljs-type">int</span> val;<br>        ListNode *next;<br><br>        <span class="hljs-built_in">ListNode</span>(<span class="hljs-type">int</span> x) &#123;<br>            val = x;<br>            next = <span class="hljs-literal">NULL</span>;<br>        &#125;;<br>    &#125;;<br><br>    ListNode *head;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">creatList</span><span class="hljs-params">()</span> </span>&#123;<br>        head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>        ListNode *p = head;<br>        <span class="hljs-comment">//p最后停在链表满足条件的最后一个节点，但是没有访问到该节点</span><br>        <span class="hljs-keyword">while</span> (p-&gt;next &amp;&amp; p-&gt;next-&gt;val &lt; num) &#123;<br>            p = p-&gt;next;<br>        &#125;<br>        ListNode *node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(num);<br>        node-&gt;next = p-&gt;next;<br>        p-&gt;next = node;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>        ListNode *p = head-&gt;next, *pre = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">while</span> (p &amp;&amp; p-&gt;val &lt;= num) &#123;<br>            <span class="hljs-keyword">if</span> (p-&gt;val == num) &#123;<br>                <span class="hljs-comment">//移除该节点，但是pre不动</span><br>                pre-&gt;next = p-&gt;next;<br>                p = p-&gt;next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//正常遍历</span><br>                pre = p;<br>                p = p-&gt;next;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printList</span><span class="hljs-params">()</span> </span>&#123;<br>        ListNode *p = head-&gt;next;<br>        <span class="hljs-keyword">while</span> (p) &#123;<br>            cout &lt;&lt; p-&gt;val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>            p = p-&gt;next;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="字符串"><a class="markdownIt-Anchor" href="#字符串"></a> 字符串</h2><h3 id="面试题-0106-字符串压缩"><a class="markdownIt-Anchor" href="#面试题-0106-字符串压缩"></a> <a href="https://leetcode-cn.com/problems/compress-string-lcci/">面试题 01.06. 字符串压缩</a></h3><p>快慢双指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">compressString</span><span class="hljs-params">(string S)</span> </span>&#123;<br>        <span class="hljs-type">int</span> slow = <span class="hljs-number">0</span>, fast = <span class="hljs-number">0</span>;<br>        string res;<br>        <span class="hljs-keyword">while</span> (slow &lt; S.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">while</span> (fast &lt; S.<span class="hljs-built_in">size</span>() &amp;&amp; S[slow] == S[fast])<br>                fast++;<br>            res += S[slow];<br>            res += <span class="hljs-built_in">to_string</span>(fast - slow);<br>            slow = fast;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res.<span class="hljs-built_in">length</span>() &lt; S.<span class="hljs-built_in">size</span>() ? res : S;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="76-最小覆盖子串"><a class="markdownIt-Anchor" href="#76-最小覆盖子串"></a> <a href="https://leetcode-cn.com/problems/minimum-window-substring/">76. 最小覆盖子串</a></h3><p>滑动窗口。</p><p>第一次遍历时，将无关字符标记。</p><p>通过维护 needCount 来快速判断当前窗口中是否有足够的字符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">minWindow</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">size</span>() &lt; t.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span> &amp;&amp; t.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> s[<span class="hljs-number">0</span>] == t[<span class="hljs-number">0</span>] ? s : <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        <span class="hljs-comment">//哈希表统计字符</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">need</span><span class="hljs-params">(<span class="hljs-number">128</span>)</span></span>;<br>        <span class="hljs-comment">//needCount统计所需字符数量</span><br>        <span class="hljs-type">int</span> needCount = t.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">//统计需要的字符</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c: t) &#123;<br>            need[c]++;<br>        &#125;<br>        <span class="hljs-comment">//不需要的全部变为INT_MIN</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; need.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (need[i] == <span class="hljs-number">0</span>)<br>                need[i] = INT_MIN;<br>        &#125;<br>        <span class="hljs-comment">//窗口右边界</span><br>        <span class="hljs-type">int</span> right = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//目标字符串最小长度</span><br>        <span class="hljs-type">int</span> len = INT_MAX;<br>        <span class="hljs-comment">//目标字符串出发点</span><br>        <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> left = <span class="hljs-number">0</span>; left &lt; s.<span class="hljs-built_in">size</span>(); left++) &#123;<br>            <span class="hljs-comment">//所需字符数量不够时，从窗口一直向右移</span><br>            <span class="hljs-keyword">while</span> (right &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; needCount &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">//对于无关字符直接不去管</span><br>                <span class="hljs-keyword">if</span> (need[s[right]] != INT_MIN) &#123;<br>                    <span class="hljs-comment">//对于缺的字符，needcount需要减</span><br>                    <span class="hljs-keyword">if</span> (need[s[right]] &gt; <span class="hljs-number">0</span>) &#123;<br>                        needCount--;<br>                    &#125;<br>                    <span class="hljs-comment">//对于不缺的但是是目标字符仍需要减1</span><br>                    need[s[right]]--;<br>                &#125;<br>                right++;<br>            &#125;<br>            <span class="hljs-comment">//更新目标起点和长度</span><br>            <span class="hljs-keyword">if</span> (needCount == <span class="hljs-number">0</span> &amp;&amp; right - left &lt; len) &#123;<br>                len = right - left;<br>                start = left;<br>            &#125;<br>            <span class="hljs-comment">//窗口左侧右移1位</span><br>            <span class="hljs-keyword">if</span> (need[s[left]] != INT_MIN) &#123;<span class="hljs-comment">//排除无关字符</span><br>                <span class="hljs-keyword">if</span> (need[s[left]] == <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//等于0表示右移后会缺少</span><br>                    needCount++;<br>                &#125;<br>                <span class="hljs-comment">//小于0的表示还多出来有富余，只需数量减少</span><br>                need[s[left]]++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> len &lt; INT_MAX ? s.<span class="hljs-built_in">substr</span>(start, len) : <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="8-字符串转换整数-atoi"><a class="markdownIt-Anchor" href="#8-字符串转换整数-atoi"></a> <a href="https://leetcode-cn.com/problems/string-to-integer-atoi/">8. 字符串转换整数 (atoi)</a></h3><p>状态机</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Automaton</span> &#123;<br>    string state = <span class="hljs-string">&quot;start&quot;</span>;<br>    unordered_map&lt;string, vector&lt;string&gt;&gt; table = &#123;<br>        &#123;<span class="hljs-string">&quot;start&quot;</span>, &#123;<span class="hljs-string">&quot;start&quot;</span>, <span class="hljs-string">&quot;signed&quot;</span>, <span class="hljs-string">&quot;in_number&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>&#125;&#125;,<br>        &#123;<span class="hljs-string">&quot;signed&quot;</span>, &#123;<span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;in_number&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>&#125;&#125;,<br>        &#123;<span class="hljs-string">&quot;in_number&quot;</span>, &#123;<span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;in_number&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>&#125;&#125;,<br>        &#123;<span class="hljs-string">&quot;end&quot;</span>, &#123;<span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>&#125;&#125;<br>    &#125;;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_col</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isspace</span>(c)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;+&#x27;</span> <span class="hljs-keyword">or</span> c == <span class="hljs-string">&#x27;-&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isdigit</span>(c)) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> sign = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> </span>&#123;<br>        state = table[state][<span class="hljs-built_in">get_col</span>(c)];<br>        <span class="hljs-keyword">if</span> (state == <span class="hljs-string">&quot;in_number&quot;</span>) &#123;<br>            ans = ans * <span class="hljs-number">10</span> + c - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            ans = sign == <span class="hljs-number">1</span> ? <span class="hljs-built_in">min</span>(ans, (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)INT_MAX) : <span class="hljs-built_in">min</span>(ans, -(<span class="hljs-type">long</span> <span class="hljs-type">long</span>)INT_MIN);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == <span class="hljs-string">&quot;signed&quot;</span>)<br>            sign = c == <span class="hljs-string">&#x27;+&#x27;</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">myAtoi</span><span class="hljs-params">(string str)</span> </span>&#123;<br>        Automaton automaton;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : str)<br>            automaton.<span class="hljs-built_in">get</span>(c);<br>        <span class="hljs-keyword">return</span> automaton.sign * automaton.ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="连续字符不区分大小写"><a class="markdownIt-Anchor" href="#连续字符不区分大小写"></a> 连续字符（不区分大小写）</h3><p>直接遍历。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">maxPower</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len = <span class="hljs-number">1</span>, cnt = <span class="hljs-number">1</span>, idx = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">length</span>(); ++i) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] == s[i - <span class="hljs-number">1</span>] || s[i] - <span class="hljs-number">32</span> == s[i - <span class="hljs-number">1</span>] || s[i] + <span class="hljs-number">32</span> == s[i - <span class="hljs-number">1</span>]) &#123;<br>                ++cnt;<br>                <span class="hljs-keyword">if</span> (cnt &gt; len) &#123;<br>                    len = cnt;<br>                    idx = i;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cnt = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">substr</span>(idx - len + <span class="hljs-number">1</span>, len);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="反转url"><a class="markdownIt-Anchor" href="#反转url"></a> 反转URL</h3><p>遍历，储存遇到的上一个标识点。</p><p>将上一个标识点与当前标识点中间区域反转。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">reverseURL</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        string ans = s;<br>        <span class="hljs-type">int</span> pre = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ans.<span class="hljs-built_in">length</span>(); ++i) &#123;<br>            <span class="hljs-keyword">if</span> (ans[i] == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>                <span class="hljs-built_in">reverse</span>(ans.<span class="hljs-built_in">begin</span>() + pre, ans.<span class="hljs-built_in">begin</span>() + i);<br>                pre = i + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//最后将顶级域名部分反转</span><br>        <span class="hljs-built_in">reverse</span>(ans.<span class="hljs-built_in">begin</span>() + pre, ans.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="557-反转字符串中的单词-iii"><a class="markdownIt-Anchor" href="#557-反转字符串中的单词-iii"></a> <a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/">557. 反转字符串中的单词 III</a></h3><p>直接遍历 + 双指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">reverseWords</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> length = s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> fast = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (fast &lt; length) &#123;<br>            <span class="hljs-type">int</span> slow = fast;<br>            <span class="hljs-keyword">while</span> (fast &lt; length &amp;&amp; s[fast] != <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                fast++;<br>            &#125;<br><br>            <span class="hljs-type">int</span> left = slow, right = fast - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>                <span class="hljs-built_in">swap</span>(s[left], s[right]);<br>                left++;<br>                right--;<br>            &#125;<br><span class="hljs-comment">//            reverse(s.begin() + slow, s.begin() + fast);</span><br>            <span class="hljs-keyword">while</span> (fast &lt; length &amp;&amp; s[fast] == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                fast++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="22-括号生成"><a class="markdownIt-Anchor" href="#22-括号生成"></a> <a href="https://leetcode-cn.com/problems/generate-parentheses/">22. 括号生成</a></h3><p>DFS + 回溯</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        vector&lt;string&gt; ans;<br>        string str;<br>        <span class="hljs-built_in">dfs</span>(ans, str, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, n);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;string&gt; &amp;ans, string &amp;cur, <span class="hljs-type">int</span> open, <span class="hljs-type">int</span> close, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">//达到深度，结束递归</span><br>        <span class="hljs-keyword">if</span> (cur.<span class="hljs-built_in">size</span>() == n * <span class="hljs-number">2</span>) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(cur);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//左括号数小于 n，可以添加左括号</span><br>        <span class="hljs-keyword">if</span> (open &lt; n) &#123;<br>            cur.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;(&#x27;</span>);<br>            <span class="hljs-built_in">dfs</span>(ans, cur, open + <span class="hljs-number">1</span>, close, n);<br>            <span class="hljs-comment">//回溯</span><br>            cur.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>        <span class="hljs-comment">//右括号数小于 n，可以添加右括号</span><br>        <span class="hljs-keyword">if</span> (close &lt; open) &#123;<br>            cur.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;)&#x27;</span>);<br>            <span class="hljs-built_in">dfs</span>(ans, cur, open, close + <span class="hljs-number">1</span>, n);<br>            cur.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="单调栈"><a class="markdownIt-Anchor" href="#单调栈"></a> 单调栈</h2><h3 id="42-接雨水"><a class="markdownIt-Anchor" href="#42-接雨水"></a> <a href="https://leetcode-cn.com/problems/trapping-rain-water/">42. 接雨水</a></h3><p>单调减栈</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;height)</span> </span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    stack&lt;<span class="hljs-type">int</span>&gt; stack;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; height.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-keyword">while</span> (!stack.<span class="hljs-built_in">empty</span>() &amp;&amp; height[stack.<span class="hljs-built_in">top</span>()] &lt; height[i]) &#123;<br>            <span class="hljs-type">int</span> cur = stack.<span class="hljs-built_in">top</span>();<br>            stack.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (stack.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">//计算水量</span><br>            <span class="hljs-type">int</span> l = stack.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-type">int</span> r = i;<br>            <span class="hljs-type">int</span> h = <span class="hljs-built_in">min</span>(height[r], height[l]) - height[cur];<br>            ans += (r - l - <span class="hljs-number">1</span>) * h;<br>        &#125;<br>        stack.<span class="hljs-built_in">push</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="84-柱状图中最大的矩形"><a class="markdownIt-Anchor" href="#84-柱状图中最大的矩形"></a> <a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">84. 柱状图中最大的矩形</a></h3><p>单调增栈。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;heights)</span> </span>&#123;<br>        heights.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);        <span class="hljs-comment">//插入空矩形，弹出栈中剩余矩形</span><br>        <span class="hljs-type">int</span> len = heights.<span class="hljs-built_in">size</span>(), area = <span class="hljs-number">0</span>, pre_index, height, width;<br>        stack&lt;<span class="hljs-type">int</span>&gt; indices;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-keyword">while</span> (!indices.<span class="hljs-built_in">empty</span>() &amp;&amp; heights[indices.<span class="hljs-built_in">top</span>()] &gt; heights[i]) &#123;    <span class="hljs-comment">//检查栈是否为空</span><br>                pre_index = indices.<span class="hljs-built_in">top</span>();        <span class="hljs-comment">//储存栈顶矩形的位置</span><br>                indices.<span class="hljs-built_in">pop</span>();<br>                height = heights[pre_index];    <span class="hljs-comment">//储存高度</span><br>                <span class="hljs-keyword">if</span> (indices.<span class="hljs-built_in">empty</span>()) &#123;            <span class="hljs-comment">//避免操作空栈</span><br>                    width = i;                    <span class="hljs-comment">//若弹出至栈为空，因栈的递增性，边界可向左延伸至0</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    width = i - indices.<span class="hljs-built_in">top</span>() - <span class="hljs-number">1</span>;        <span class="hljs-comment">//储存宽度</span><br>                &#125;<br>                area = area &gt; (width * height) ? area : (width * height);        <span class="hljs-comment">//更新结果</span><br>            &#125;<br>            indices.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> area;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="85-最大矩形"><a class="markdownIt-Anchor" href="#85-最大矩形"></a> <a href="https://leetcode-cn.com/problems/maximal-rectangle/">85. 最大矩形</a></h3><p>每层单调增栈。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maximalRectangle</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; &amp;matrix)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = matrix.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> n = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">heights</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>));<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-comment">//把每一层转化为柱状图的高度</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (matrix[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                    heights[i][j] = (i == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : heights[i - <span class="hljs-number">1</span>][j]) + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//保存答案</span><br>            ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">largestRectangleArea</span>(heights[i]));<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;heights)</span> </span>&#123;<br>        heights.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);        <span class="hljs-comment">//插入空矩形，弹出栈中剩余矩形</span><br>        <span class="hljs-type">int</span> len = heights.<span class="hljs-built_in">size</span>(), area = <span class="hljs-number">0</span>, pre_index, height, width;<br>        stack&lt;<span class="hljs-type">int</span>&gt; indices;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-keyword">while</span> (!indices.<span class="hljs-built_in">empty</span>() &amp;&amp; heights[indices.<span class="hljs-built_in">top</span>()] &gt; heights[i]) &#123;    <span class="hljs-comment">//检查栈是否为空</span><br>                pre_index = indices.<span class="hljs-built_in">top</span>();        <span class="hljs-comment">//储存栈顶矩形的位置</span><br>                indices.<span class="hljs-built_in">pop</span>();<br>                height = heights[pre_index];    <span class="hljs-comment">//储存高度</span><br>                <span class="hljs-keyword">if</span> (indices.<span class="hljs-built_in">empty</span>()) &#123;            <span class="hljs-comment">//避免操作空栈</span><br>                    width = i;                    <span class="hljs-comment">//若弹出至栈为空，因栈的递增性，边界可向左延伸至0</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    width = i - indices.<span class="hljs-built_in">top</span>() - <span class="hljs-number">1</span>;        <span class="hljs-comment">//储存宽度</span><br>                &#125;<br>                area = area &gt; (width * height) ? area : (width * height);        <span class="hljs-comment">//更新结果</span><br>            &#125;<br>            indices.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> area;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="找出第一个比它大的数"><a class="markdownIt-Anchor" href="#找出第一个比它大的数"></a> 找出第一个比它大的数</h3><p>单调减栈。</p><p>单调栈的核心在于，我们想要什么时候弹出元素。</p><p>本题中，我们希望当新元素比栈顶元素大时，弹出栈顶，保存信息。所以我们采用单调减的栈。</p><p>在本题中保存索引下标。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">firstLargeNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; nums)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(nums.size())</span></span>;<br>        stack&lt;<span class="hljs-type">int</span>&gt; stack;<br>        stack.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; nums[stack.<span class="hljs-built_in">top</span>()]) &#123;<br>                <span class="hljs-comment">//比栈顶大时，弹出并处理元素，直到恢复单调</span><br>                <span class="hljs-keyword">while</span> (!stack.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i] &gt; nums[stack.<span class="hljs-built_in">top</span>()]) &#123;<br>                    ans[stack.<span class="hljs-built_in">top</span>()] = nums[i];<br>                    stack.<span class="hljs-built_in">pop</span>();<br>                &#125;<br>                stack.<span class="hljs-built_in">push</span>(i);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                stack.<span class="hljs-built_in">push</span>(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//栈中还有剩余元素，说明这些元素右边没有比它大的元素，按顺序弹出处理就好</span><br>        <span class="hljs-keyword">while</span> (!stack.<span class="hljs-built_in">empty</span>()) &#123;<br>            ans[stack.<span class="hljs-built_in">top</span>()] = <span class="hljs-number">-1</span>;<br>            stack.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="402-移掉-k-位数字"><a class="markdownIt-Anchor" href="#402-移掉-k-位数字"></a> <a href="https://leetcode-cn.com/problems/remove-k-digits/">402. 移掉 K 位数字</a></h3><p>贪心 + 单调增栈。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">removeKdigits</span><span class="hljs-params">(string num, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">//使用 vector 模拟栈，避免倒转</span><br>        vector&lt;<span class="hljs-type">char</span>&gt; stack;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;digit: num) &#123;<br>            <span class="hljs-keyword">while</span> (stack.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span> &amp;&amp; stack.<span class="hljs-built_in">back</span>() &gt; digit &amp;&amp; k) &#123;<br>                stack.<span class="hljs-built_in">pop_back</span>();<br>                k -= <span class="hljs-number">1</span>;<br>            &#125;<br>            stack.<span class="hljs-built_in">push_back</span>(digit);<br>        &#125;<br><br>        <span class="hljs-comment">//移除的数字还不够 k 个时，继续移除</span><br>        <span class="hljs-keyword">for</span> (; k &gt; <span class="hljs-number">0</span>; --k) &#123;<br>            stack.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br><br>        string ans = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-comment">//先假设有前导零</span><br>        <span class="hljs-type">bool</span> isLeadingZero = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;digit: stack) &#123;<br>            <span class="hljs-comment">//标记前导零</span><br>            <span class="hljs-keyword">if</span> (isLeadingZero &amp;&amp; digit == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            isLeadingZero = <span class="hljs-literal">false</span>;<br>            ans += digit;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans == <span class="hljs-string">&quot;&quot;</span> ? <span class="hljs-string">&quot;0&quot;</span> : ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="dfs"><a class="markdownIt-Anchor" href="#dfs"></a> DFS</h2><h3 id="剑指-offer-38-字符串的排列"><a class="markdownIt-Anchor" href="#剑指-offer-38-字符串的排列"></a> <a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/">剑指 Offer 38. 字符串的排列</a></h3><p>这道题我们采用回溯，也叫深度优先搜索。</p><p>从第一位开始，首先与包括自己的后面所有字符交换，确定了第一位。</p><p>确定第一位之后，向更深一层搜索，即向第二位搜索。将其与包括自己的后面所有字符交换，确定第二位。</p><p>以此递归，直到所有位被确定。</p><p><strong>注意</strong></p><ul><li>交换时，可用 set 来保存每一层待交换的字符，遇到重复时可剪枝。跳过这个字符继续交换下一个字符。</li><li>在交换完毕并完成下一层的搜索后，需要恢复交换。以免影响相邻层或是下一次交换。</li></ul><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    vector&lt;string&gt; ans;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">permutation</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(s, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> depth)</span> </span>&#123;<br>        <span class="hljs-comment">//到达最后一层，直接返回</span><br>        <span class="hljs-keyword">if</span> (depth == s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(s);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//使用set去重</span><br>        set&lt;<span class="hljs-type">char</span>&gt; set;<br>        <span class="hljs-comment">//从x位开始，分别与后面交换</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = depth; i &lt; s.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-comment">//如果待交换的字符重复，剪枝</span><br>            <span class="hljs-keyword">if</span> (set.<span class="hljs-built_in">count</span>(s[i]) &gt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            set.<span class="hljs-built_in">insert</span>(s[i]);<br>            <span class="hljs-comment">//交换</span><br>            <span class="hljs-built_in">swap</span>(s[i], s[depth]);<br>            <span class="hljs-comment">//搜索下一层</span><br>            <span class="hljs-built_in">dfs</span>(s, depth + <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//恢复交换，避免对s的修改影响相邻层或是下一次交换</span><br>            <span class="hljs-built_in">swap</span>(s[i], s[depth]);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="200-岛屿数量"><a class="markdownIt-Anchor" href="#200-岛屿数量"></a> <a href="https://leetcode-cn.com/problems/number-of-islands/">200. 岛屿数量</a></h3><p>DFS。</p><p>先污染，后治理。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; &amp;grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; grid.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); j++) &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                    <span class="hljs-built_in">dfs</span>(grid, i, j);<br>                    ans++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; &amp;grid, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> </span>&#123;<br>        <span class="hljs-comment">//先污染，后治理</span><br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span> || i &gt;= grid.<span class="hljs-built_in">size</span>() || j &gt;= grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() || grid[i][j] == <span class="hljs-string">&#x27;0&#x27;</span>)<br>            <span class="hljs-keyword">return</span>;<br>        grid[i][j] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-built_in">dfs</span>(grid, i + <span class="hljs-number">1</span>, j);<br>        <span class="hljs-built_in">dfs</span>(grid, i, j + <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">dfs</span>(grid, i - <span class="hljs-number">1</span>, j);<br>        <span class="hljs-built_in">dfs</span>(grid, i, j - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划"></a> 动态规划</h2><h3 id="72-编辑距离"><a class="markdownIt-Anchor" href="#72-编辑距离"></a> <a href="https://leetcode-cn.com/problems/edit-distance/">72. 编辑距离</a></h3><ul><li><p><code>dp[i][j]</code> 代表 <code>word1</code> 中前 <code>i</code> 个字符，变换到 <code>word2</code> 中前 <code>j</code> 个字符，最短需要操作的次数</p></li><li><p>增，<code>dp[i][j] = dp[i][j-1] + 1</code></p></li><li><p>删，<code>dp[i][j] = dp[i - 1][j] + 1</code></p></li><li><p>改，<code>dp[i][j] = dp[i - 1][j - 1] + 1</code></p></li></ul><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(string word1, string word2)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(word1.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(word2.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br><br>        <span class="hljs-comment">//初始化额外的位置</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; dp.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = i;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; dp[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); j++) &#123;<br>            dp[<span class="hljs-number">0</span>][j] = j;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; dp.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; dp[i].<span class="hljs-built_in">size</span>(); j++) &#123;<br>                dp[i][j] = <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>], <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>])) + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (word1[i - <span class="hljs-number">1</span>] == word2[j - <span class="hljs-number">1</span>]) &#123;<br>                    dp[i][j] = <span class="hljs-built_in">min</span>(dp[i][j], dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp.<span class="hljs-built_in">back</span>().<span class="hljs-built_in">back</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="1143-最长公共子序列"><a class="markdownIt-Anchor" href="#1143-最长公共子序列"></a> <a href="https://leetcode-cn.com/problems/longest-common-subsequence/">1143. 最长公共子序列</a></h3><p>二维dp，<code>dp[i][j]</code> 保存 A 字符串的第 i 位和 B 字符串的第 j 位之前的最大公共子序列。</p><ul><li>如果 <code>text1[i] == text2[j]</code>，说明可以继承 <code>dp[i-1][j-1]</code> 位置上的子序列，<code>dp[i][j] = dp[i - 1][j - 1] + 1</code></li><li>如果 <code>text1[i] != text2[j]</code>，考虑向两个方向寻找，<code>dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])</code></li></ul><p><img src="https://cdn.jsdelivr.net/gh/TBDGF/TBDGF.github.io@master/img/9160/1617411822-KhEKGw-image.png" alt="image.png" /></p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(string text1, string text2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = text1.<span class="hljs-built_in">size</span>(), n = text2.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">//为省略边界判断，将矩阵扩大一圈，边界就自动初始化为 0 了</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>));<br>        <span class="hljs-comment">//因为扩大了矩阵，i 和 j 都从 1 开始遍历</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>            <span class="hljs-type">char</span> ch1 = text1[i - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++j) &#123;<br>                <span class="hljs-type">char</span> ch2 = text2[j - <span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span> (ch1 == ch2)<br>                    <span class="hljs-comment">//继承</span><br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span><br>                    <span class="hljs-comment">//向两个方向寻找最大值</span><br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h2><h3 id="440-字典序的第k小数字"><a class="markdownIt-Anchor" href="#440-字典序的第k小数字"></a> <a href="https://leetcode-cn.com/problems/k-th-smallest-in-lexicographical-order/">440. 字典序的第K小数字</a></h3><p>根本不理解，直接背吧。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 返回从prefix出发, 小于等于n的个数</span><br>    <span class="hljs-comment">// 思路就是从位数考虑, 比如给出prefix = 45, n = 4566</span><br>    <span class="hljs-comment">// 先考虑两位的情况(对答案的贡献), 即45 (等于46 - 45)</span><br>    <span class="hljs-comment">// 在考虑三位的情况, 即450 ~ 459 (等于460 - 450)</span><br>    <span class="hljs-comment">// 在考虑四位的情况, 即4500 ~ 4599 (等于std::min(4566 + 1, 4600) - 4500)</span><br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">get_count</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> prefix, <span class="hljs-type">long</span> <span class="hljs-type">long</span> n)</span> </span>&#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> ret = <span class="hljs-number">0</span>, upper = prefix + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (prefix &lt;= n) &#123;<br>            ret += std::<span class="hljs-built_in">min</span>(n + <span class="hljs-number">1</span>, upper) - prefix;<br>            prefix *= <span class="hljs-number">10</span>;<br>            upper *= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">findKthNumber</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> n, <span class="hljs-type">long</span> <span class="hljs-type">long</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">// std::cout &lt;&lt; get_count(45, 4566) &lt;&lt; std::endl;</span><br>        <span class="hljs-comment">// std::cout &lt;&lt; get_count(1, 2) &lt;&lt; std::endl;</span><br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> p = <span class="hljs-number">1</span>, prefix = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (p &lt; k) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-type">long</span> cnt = <span class="hljs-built_in">get_count</span>(prefix, n);<br>            <span class="hljs-keyword">if</span> (p + cnt &lt;= k) &#123;<br>                <span class="hljs-comment">// 将以prefix为根的子树遍历完都还小于等于k, 所以下一个遍历为prefix + 1</span><br>                p += cnt;<br>                prefix += <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 以prefix为根的子树遍历完大于k, 所以答案一定在prefix为根的子树里, 所以往左走一步</span><br>                p += <span class="hljs-number">1</span>;<br>                prefix *= <span class="hljs-number">10</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> prefix;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="974-和可被-k-整除的子数组"><a class="markdownIt-Anchor" href="#974-和可被-k-整除的子数组"></a> <a href="https://leetcode-cn.com/problems/subarray-sums-divisible-by-k/">974. 和可被 K 整除的子数组</a></h3><p>通常，涉及连续子数组问题的时候，我们使用前缀和来解决。</p><p>本题部分思路与 <a href="https://blog.allenji.cn/p/9160/">面试算法题 03 - Allen Ji’s blog</a> 中的 ”求出反转的数字对“ 类似。都是保存出现过的次数，每次向结果上累加该次数。</p><p>我们令前缀和 <code>P[i] = nums[0] + nums[1] + ... + nums[i]</code>，那么每个连续从 i 到 j 的子数组的和 <code>sum(i, j)</code> 就可以写成 <code>P[j] - P[i-1]</code> 的形式。因此判断能否被 k 整除等价于判断 <code>(P[j] - P[i-1]) % k == 0</code> 。</p><p>根据<strong>同余定理</strong>，上面的判断式可转化为 <code>P[j] % k == P[i-1] % k</code>。</p><p>因此，我们只需要保存 <code>P[i] % k</code> 的值到 map 中，同时记录出现过的次数，即可记录出有多少子数组。（每出现一对左右边界，相当于出现一次子数组，所以本题与 ”求出反转的数组对“ 思路非常相近）</p><p>注意边界，考虑第一个子数组就能被 k 整除的情况，这时没有记录过左边界，所以我们在 map 中初始化进左边界。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">subarraysDivByK</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">//初始化，考虑前缀和被 k 整除的情况，即第一个子数组就能被 k 整除</span><br>        map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; record = &#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>        <span class="hljs-comment">//sum 记录前缀和，ans记录结果</span><br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            sum += nums[i];<br>            <span class="hljs-comment">//c++ 对负数取模结果为负数，通过先加 k 再模 k 来纠正</span><br>            <span class="hljs-type">int</span> modulus = (sum % k + k) % k;<br>            <span class="hljs-keyword">if</span> (record.<span class="hljs-built_in">count</span>(modulus) != <span class="hljs-number">0</span>)<br>                <span class="hljs-comment">//当多次出现同模的结果时，加上之前保存过的对数</span><br>                ans += record[modulus];<br>            <span class="hljs-comment">//对数增加</span><br>            record[modulus]++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="149-直线上最多的点数"><a class="markdownIt-Anchor" href="#149-直线上最多的点数"></a> <a href="https://leetcode-cn.com/problems/max-points-on-a-line/">149. 直线上最多的点数</a></h3><p>我们可以考虑枚举所有的点，假设直线经过该点时，该直线所能经过的最多的点数。</p><p>假设我们当前枚举到点 ii，如果直线同时经过另外两个不同的点 jj 和 kk，那么可以发现点 ii 和点 jj 所连直线的斜率恰等于点 ii 和点 kk 所连直线的斜率。</p><p>于是我们可以统计其他所有点与点 ii 所连直线的斜率，出现次数最多的斜率即为经过点数最多的直线的斜率，其经过的点数为该斜率出现的次数加一（点 ii 自身也要被统计）。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> b ? <span class="hljs-built_in">gcd</span>(b, a % b) : a;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxPoints</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;points)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = points.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> n;<br>        &#125;<br>        <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (ret &gt;= n - i || ret &gt; n / <span class="hljs-number">2</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-type">int</span> x = points[i][<span class="hljs-number">0</span>] - points[j][<span class="hljs-number">0</span>];<br>                <span class="hljs-type">int</span> y = points[i][<span class="hljs-number">1</span>] - points[j][<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) &#123;<br>                    y = <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (y == <span class="hljs-number">0</span>) &#123;<br>                    x = <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (y &lt; <span class="hljs-number">0</span>) &#123;<br>                        x = -x;<br>                        y = -y;<br>                    &#125;<br>                    <span class="hljs-type">int</span> gcdXY = <span class="hljs-built_in">gcd</span>(<span class="hljs-built_in">abs</span>(x), <span class="hljs-built_in">abs</span>(y));<br>                    x /= gcdXY, y /= gcdXY;<br>                &#125;<br>                mp[y + x * <span class="hljs-number">20001</span>]++;<br>            &#125;<br>            <span class="hljs-type">int</span> maxn = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp;[_, num]: mp) &#123;<br>                maxn = <span class="hljs-built_in">max</span>(maxn, num + <span class="hljs-number">1</span>);<br>            &#125;<br>            ret = <span class="hljs-built_in">max</span>(ret, maxn);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="15-三数之和"><a class="markdownIt-Anchor" href="#15-三数之和"></a> <a href="https://leetcode-cn.com/problems/3sum/">15. 三数之和</a></h3><p>排序+双指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums) &#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-comment">// 枚举 a</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> first = <span class="hljs-number">0</span>; first &lt; n; ++first) &#123;<br>            <span class="hljs-comment">// 需要和上一次枚举的数不相同</span><br>            <span class="hljs-keyword">if</span> (first &gt; <span class="hljs-number">0</span> &amp;&amp; nums[first] == nums[first - <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">// c 对应的指针初始指向数组的最右端</span><br>            <span class="hljs-type">int</span> third = n - <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> target = -nums[first];<br>            <span class="hljs-comment">// 枚举 b</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> second = first + <span class="hljs-number">1</span>; second &lt; n; ++second) &#123;<br>                <span class="hljs-comment">// 需要和上一次枚举的数不相同</span><br>                <span class="hljs-keyword">if</span> (second &gt; first + <span class="hljs-number">1</span> &amp;&amp; nums[second] == nums[second - <span class="hljs-number">1</span>]) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-comment">// 需要保证 b 的指针在 c 的指针的左侧</span><br>                <span class="hljs-keyword">while</span> (second &lt; third &amp;&amp; nums[second] + nums[third] &gt; target) &#123;<br>                    --third;<br>                &#125;<br>                <span class="hljs-comment">// 如果指针重合，随着 b 后续的增加</span><br>                <span class="hljs-comment">// 就不会有满足 a+b+c=0 并且 b&lt;c 的 c 了，可以退出循环</span><br>                <span class="hljs-keyword">if</span> (second == third) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (nums[second] + nums[third] == target) &#123;<br>                    ans.<span class="hljs-built_in">push_back</span>(&#123;nums[first], nums[second], nums[third]&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="41-缺失的第一个正数"><a class="markdownIt-Anchor" href="#41-缺失的第一个正数"></a> <a href="https://leetcode-cn.com/problems/first-missing-positive/">41. 缺失的第一个正数</a></h3><p>交换。每一个错误的位置就代表了一个缺失的正数。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">firstMissingPositive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">while</span> (nums[i] &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[nums[i] - <span class="hljs-number">1</span>] != nums[i]) &#123;<br>                <span class="hljs-built_in">swap</span>(nums[nums[i] - <span class="hljs-number">1</span>], nums[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] != i + <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="128-最长连续序列"><a class="markdownIt-Anchor" href="#128-最长连续序列"></a> <a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/">128. 最长连续序列</a></h3><p>set</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; num_set;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; num : nums) &#123;<br>            num_set.<span class="hljs-built_in">insert</span>(num);<br>        &#125;<br><br>        <span class="hljs-type">int</span> longestStreak = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; num : num_set) &#123;<br>            <span class="hljs-keyword">if</span> (!num_set.<span class="hljs-built_in">count</span>(num - <span class="hljs-number">1</span>)) &#123;<br>                <span class="hljs-type">int</span> currentNum = num;<br>                <span class="hljs-type">int</span> currentStreak = <span class="hljs-number">1</span>;<br><br>                <span class="hljs-keyword">while</span> (num_set.<span class="hljs-built_in">count</span>(currentNum + <span class="hljs-number">1</span>)) &#123;<br>                    currentNum += <span class="hljs-number">1</span>;<br>                    currentStreak += <span class="hljs-number">1</span>;<br>                &#125;<br><br>                longestStreak = <span class="hljs-built_in">max</span>(longestStreak, currentStreak);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> longestStreak;           <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>map</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span> </span>&#123;<br>        map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; map;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            map[nums[i]] = nums[i];<br>        &#125;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (!map.<span class="hljs-built_in">count</span>(nums[i]<span class="hljs-number">-1</span>)) &#123;<br>                <span class="hljs-type">int</span> right = map[nums[i]];<br>                <span class="hljs-keyword">while</span> (map.<span class="hljs-built_in">count</span>(right + <span class="hljs-number">1</span>)) &#123;<br>                    right = map[right + <span class="hljs-number">1</span>];<br>                &#125;<br>                map[nums[i]] = right;<br>                ans = <span class="hljs-built_in">max</span>(ans, right - nums[i] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="剑指-offer-ii-076-数组中的第-k-大的数字"><a class="markdownIt-Anchor" href="#剑指-offer-ii-076-数组中的第-k-大的数字"></a> <a href="https://leetcode-cn.com/problems/xx4gT2/">剑指 Offer II 076. 数组中的第 k 大的数字</a></h3><p>小根堆</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; minHeap;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (minHeap.<span class="hljs-built_in">size</span>() &lt; k) &#123;<br>                minHeap.<span class="hljs-built_in">push</span>(nums[i]);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] &gt; minHeap.<span class="hljs-built_in">top</span>()) &#123;<br>                minHeap.<span class="hljs-built_in">pop</span>();<br>                minHeap.<span class="hljs-built_in">push</span>(nums[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> minHeap.<span class="hljs-built_in">top</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>快速选择，找第 k + 1 小</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span> || nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//第 n 大，则为第 n + 1 小</span><br>        <span class="hljs-built_in">quickSelect</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, nums.<span class="hljs-built_in">size</span>() - k + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//第k大的所在的位置</span><br>        <span class="hljs-keyword">return</span> nums[nums.<span class="hljs-built_in">size</span>() - k];<br>    &#125;<br><br>    <span class="hljs-comment">//快速选择，遇到返回的位置</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quickSelect</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (left &gt;= right)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">//idx 为分割后的 pivot 位置</span><br>        <span class="hljs-type">int</span> idx = <span class="hljs-built_in">partition</span>(nums, left, right);<br>        <span class="hljs-comment">//len 为刚刚一趟分割后 pivot 左边的序列长度</span><br>        <span class="hljs-type">int</span> len = idx - left + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (len == k) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k &lt; len)<br>            <span class="hljs-comment">//需要的比分割好的小，说明分割的粒度太粗，重新往小了分割</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">quickSelect</span>(nums, left, idx - <span class="hljs-number">1</span>, k);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-comment">//需要的比分割好的大，说明分割的不够，重新往大了分割</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">quickSelect</span>(nums, idx + <span class="hljs-number">1</span>, right, k - len);<br>    &#125;<br><br>    <span class="hljs-comment">//随机锚点分割函数，返回 pivot 在数组中的位置</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-comment">//随机锚点</span><br>        <span class="hljs-type">int</span> randomIndex = left + <span class="hljs-number">1</span> + <span class="hljs-built_in">rand</span>() % (right - left);<br>        <span class="hljs-built_in">swap</span>(nums[left], nums[randomIndex]);<br><br>        <span class="hljs-type">int</span> pivot = left, slow = pivot + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> fast = slow; fast &lt;= right; fast++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[fast] &lt; nums[pivot]) &#123;<br>                <span class="hljs-built_in">swap</span>(nums[fast], nums[slow]);<br>                slow++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">swap</span>(nums[pivot], nums[slow - <span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">return</span> slow - <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="343-整数拆分"><a class="markdownIt-Anchor" href="#343-整数拆分"></a> <a href="https://leetcode-cn.com/problems/integer-break/">343. 整数拆分</a></h3><p>数学方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">integerBreak</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">3</span>)<br>            <span class="hljs-keyword">return</span> n - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> a = n / <span class="hljs-number">3</span>, b = n % <span class="hljs-number">3</span>;<br>        <span class="hljs-comment">//3 的倍数</span><br>        <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) <span class="hljs-built_in">pow</span>(<span class="hljs-number">3</span>, a);<br>        <span class="hljs-comment">//模 3 余 1，</span><br>        <span class="hljs-keyword">if</span> (b == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) <span class="hljs-built_in">pow</span>(<span class="hljs-number">3</span>, a - <span class="hljs-number">1</span>) * <span class="hljs-number">4</span>;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) <span class="hljs-built_in">pow</span>(<span class="hljs-number">3</span>, a) * <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="求出反转的数字对"><a class="markdownIt-Anchor" href="#求出反转的数字对"></a> 求出反转的数字对</h3><p>遇到这种求左右两边相等的题，首先想到归项，将 i 和 j 归到一边，以满足一次遍历就能找到答案。</p><p>归项得 nums[i] - rev(nums[i]) = nums[j] - rev(nums[j])。</p><p>用 map 保存出现的次数。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span> </span>&#123;<br>        map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; map;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>, MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-type">int</span> temp = nums[i] - <span class="hljs-built_in">rev</span>(nums[i]);<br>            <span class="hljs-comment">//map中保存的是已经出现了多少次该值，就相当于与新的值结成了多少对</span><br>            cnt = (cnt + map[temp]) % MOD;<br>            map[temp]++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rev</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (num != <span class="hljs-number">0</span>) &#123;<br>            ret = ret * <span class="hljs-number">10</span> + num % <span class="hljs-number">10</span>;<br>            num /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="268-丢失的数字"><a class="markdownIt-Anchor" href="#268-丢失的数字"></a> <a href="https://leetcode-cn.com/problems/missing-number/">268. 丢失的数字</a></h3><p>位运算。从 0 到 n 都异或一遍。同时对数组内数字异或一遍，</p><p>缺失的数字只异或了一次，其他的数都异或两次。</p><p>最后剩下缺失的数字。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">missingNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            ans ^= nums[i];<br>            ans ^= i;<br>        &#125;<br>        ans ^= n;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="数组中最后负数与最前正数"><a class="markdownIt-Anchor" href="#数组中最后负数与最前正数"></a> 数组中最后负数与最前正数</h3><p>题目中描述的数组，求解结果是与0比较的，可以看做是有序的，分别二分查找，时间复杂度可以达到log(n)</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">BinSearch</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">empty</span>() || nums[<span class="hljs-number">0</span>] &gt;= <span class="hljs-number">0</span> || nums[nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>] &lt;= <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;;<br>    <span class="hljs-type">int</span> positive = <span class="hljs-number">0</span>, negative = <span class="hljs-number">0</span>, mid, left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        mid = (left + right) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &gt;= <span class="hljs-number">0</span>)<br>            right = mid - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span><br>            left = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>    ans.<span class="hljs-built_in">push_back</span>(nums[right]);<br>    right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        mid = (left + right) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt;= <span class="hljs-number">0</span>)<br>            left = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span><br>            right = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>    ans.<span class="hljs-built_in">push_back</span>(nums[left]);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>面试算法题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer 汇总</title>
    <link href="/p/7f86/"/>
    <url>/p/7f86/</url>
    
    <content type="html"><![CDATA[<p>剑指Offer 汇总</p><span id="more"></span><h2 id="链表"><a class="markdownIt-Anchor" href="#链表"></a> 链表</h2><h3 id="剑指-offer-06-从尾到头打印链表"><a class="markdownIt-Anchor" href="#剑指-offer-06-从尾到头打印链表"></a> <a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">剑指 Offer 06. 从尾到头打印链表</a></h3><p>用栈倒一下顺序</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    stack&lt;<span class="hljs-type">int</span>&gt; stack;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">reversePrint</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        ListNode *p = head;<br>        <span class="hljs-keyword">if</span> (!p) &#123;<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (p) &#123;<br>            stack.<span class="hljs-built_in">push</span>(p-&gt;val);<br>            p = p-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (!stack.<span class="hljs-built_in">empty</span>()) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(stack.<span class="hljs-built_in">top</span>());<br>            stack.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="剑指-offer-24-反转链表"><a class="markdownIt-Anchor" href="#剑指-offer-24-反转链表"></a> <a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/">剑指 Offer 24. 反转链表</a></h3><p>运用迭代，储存当前节点的next和prev。</p><p>prev用于反转链表，next用于将当前指针向下迭代。</p><p>每一次迭代，反转p和prev之间的指针。</p><p>由于头指针需要指向NULL，所以我们一开始将prev设为NULL，将p指向头指针。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        ListNode *p = head, *prev = <span class="hljs-literal">NULL</span>, *next;<br>        <span class="hljs-keyword">while</span> (p) &#123;<br>            next = p-&gt;next;<br>            p-&gt;next = prev;<br>            prev = p;<br>            p = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> prev;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="剑指-offer-35-复杂链表的复制"><a class="markdownIt-Anchor" href="#剑指-offer-35-复杂链表的复制"></a> <a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/">剑指 Offer 35. 复杂链表的复制</a></h3><p>我们使用递归求解此题，每当创建一个节点时，递归创建该节点的next和random节点。</p><p>我们用哈希表记录每一个节点对应新节点的创建情况。</p><p>我们需要首先检查当前节点是否被拷贝过，如果已经拷贝过，我们可以直接从哈希表中取出拷贝后的节点的指针并返回。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">// Definition for a Node.</span><br><span class="hljs-comment">class Node &#123;</span><br><span class="hljs-comment">public:  </span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    Node* next;</span><br><span class="hljs-comment">    Node* random;</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    Node(int _val) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">        next = NULL;</span><br><span class="hljs-comment">        random = NULL;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    map&lt;Node *, Node *&gt; map;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Node *<span class="hljs-title">copyRandomList</span><span class="hljs-params">(Node *head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!head) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!map.<span class="hljs-built_in">count</span>(head)) &#123;<br>            <span class="hljs-comment">//如果节点不存在，创建节点并加到map中</span><br>            Node *node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(head-&gt;val);<br>            map[head] = node;<br>            <span class="hljs-comment">//递归创建next</span><br>            node-&gt;next = <span class="hljs-built_in">copyRandomList</span>(head-&gt;next);<br>            <span class="hljs-comment">//递归创建random</span><br>            node-&gt;random = <span class="hljs-built_in">copyRandomList</span>(head-&gt;random);<br>        &#125;<br>        <span class="hljs-keyword">return</span> map[head];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="排序"><a class="markdownIt-Anchor" href="#排序"></a> 排序</h2><h3 id="剑指-offer-45-把数组排成最小的数"><a class="markdownIt-Anchor" href="#剑指-offer-45-把数组排成最小的数"></a> <a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">剑指 Offer 45. 把数组排成最小的数</a></h3><p>我们只关注排序规则，因为每个排序算法最后的顺序，只涉及到最基础两个元素之间的比较。</p><p>我们可以自定义 C++ sort 函数的排序规则。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">minNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span> </span>&#123;<br>        vector&lt;string&gt; strings;<br>        string ans;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            strings.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">to_string</span>(nums[i]));<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(strings.<span class="hljs-built_in">begin</span>(), strings.<span class="hljs-built_in">end</span>(), cmp);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; strings.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            ans.<span class="hljs-built_in">append</span>(strings[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(string &amp;str1, string &amp;str2)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> str1 + str2 &lt; str2 + str1;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="剑指-offer-61-扑克牌中的顺子"><a class="markdownIt-Anchor" href="#剑指-offer-61-扑克牌中的顺子"></a> <a href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/">剑指 Offer 61. 扑克牌中的顺子</a></h3><p>需满足 <code>max - min &lt; 5</code> 。</p><p>我们先排序，统计 joker 牌的数目。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isStraight</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> joker = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">0</span>)<br>                joker++;<br>            <span class="hljs-comment">//确保不重复，才能成顺子</span><br>            <span class="hljs-keyword">if</span> (nums[i] != <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i + <span class="hljs-number">1</span>])<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (nums[<span class="hljs-number">4</span>] - nums[joker] &lt; <span class="hljs-number">5</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="剑指-offer-40-最小的k个数"><a class="markdownIt-Anchor" href="#剑指-offer-40-最小的k个数"></a> <a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/">剑指 Offer 40. 最小的k个数</a></h3><p><strong>方法一</strong></p><p>大根堆，大根堆的顶部总是最大的值，如果新的值比堆顶的值大，则新值入堆，堆顶值出堆。</p><p>C++ 使用 priority_queue 来作为大根堆。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">getLeastNumbers</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> ans;<br>        <span class="hljs-comment">//priority_queue 即为大根堆</span><br>        priority_queue&lt;<span class="hljs-type">int</span>&gt; queue;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>            queue.<span class="hljs-built_in">push</span>(arr[i]);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = k; i &lt; arr.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">if</span> (arr[i] &lt; queue.<span class="hljs-built_in">top</span>()) &#123;<br>                queue.<span class="hljs-built_in">pop</span>();<br>                queue.<span class="hljs-built_in">push</span>(arr[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(queue.<span class="hljs-built_in">top</span>());<br>            queue.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>方法二</strong></p><p>快速选择，基于快速排序的思想。</p><p>参考 <a href="https://blog.allenji.cn/p/ef35/">排序算法 - Allen Ji’s blog</a> 中的快速排序，我们不需要对分割函数做出修改，只需要修改快速选择函数即可。</p><p>每次分割后我们能计算出 pivot 左边分割好的数组长度 num，将其与 k 比较。</p><ul><li><code>num == k</code>：直接返回。</li><li><code>k &lt; num</code>：需要的 k 比分割好的 num 小，说明分割的粒度太粗，重新往小了分割</li><li><code>k &lt; num</code>：需要的 k 比分割好的 num 大，说明分割的不够，重新往大了分割</li></ul><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">getLeastNumbers</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span> || arr.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> ans;<br>        <span class="hljs-built_in">quickSelect</span>(arr, <span class="hljs-number">0</span>, arr.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, k);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(arr[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-comment">//快速选择，遇到返回的位置</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quickSelect</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (left &gt;= right)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">//idx 为分割后的 pivot 位置</span><br>        <span class="hljs-type">int</span> idx = <span class="hljs-built_in">partition</span>(nums, left, right);<br>        <span class="hljs-comment">//len 为刚刚一趟分割后 pivot 左边的序列长度</span><br>        <span class="hljs-type">int</span> len = idx - left + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (len == k) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k &lt; len)<br>            <span class="hljs-comment">//需要的比分割好的小，说明分割的粒度太粗，重新往小了分割</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">quickSelect</span>(nums, left, idx - <span class="hljs-number">1</span>, k);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-comment">//需要的比分割好的大，说明分割的不够，重新往大了分割</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">quickSelect</span>(nums, idx + <span class="hljs-number">1</span>, right, k - len);<br>    &#125;<br><br>    <span class="hljs-comment">//随机锚点分割函数，返回 pivot 在数组中的位置</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-comment">//随机锚点</span><br>        <span class="hljs-type">int</span> randomIndex = left + <span class="hljs-number">1</span> + <span class="hljs-built_in">rand</span>() % (right - left);<br>        <span class="hljs-built_in">swap</span>(nums[left], nums[randomIndex]);<br><br>        <span class="hljs-type">int</span> pivot = left, slow = pivot + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> fast = slow; fast &lt;= right; fast++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[fast] &lt; nums[pivot]) &#123;<br>                <span class="hljs-built_in">swap</span>(nums[fast], nums[slow]);<br>                slow++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">swap</span>(nums[pivot], nums[slow - <span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">return</span> slow - <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="剑指-offer-41-数据流中的中位数"><a class="markdownIt-Anchor" href="#剑指-offer-41-数据流中的中位数"></a> <a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/">剑指 Offer 41. 数据流中的中位数</a></h3><p>本题使用两个堆，一个大顶堆 maxHeap 储存较小的元素，小顶堆 minHeap 储存较大的元素。</p><p>这样可以让我们随时访问较大的一半数中最小的元素，较小的一半数中最大的元素，然后进行中位数的计算。</p><p><strong>注意</strong></p><ul><li>当两个堆中元素数相同时，向大顶堆添加元素，不同时，向小顶堆添加元素</li><li>向大顶堆添加时，先向小顶堆中添加，拿到小顶堆中最小的元素，再将其添加到大顶堆</li><li>向小顶堆中添加同理</li></ul><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MedianFinder</span> &#123;<br>    <span class="hljs-comment">//左边的大顶堆</span><br>    priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, less&lt;<span class="hljs-type">int</span>&gt;&gt; maxHeap;<br>    <span class="hljs-comment">//右边的小顶堆</span><br>    priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; minHeap;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/** initialize your data structure here. */</span><br>    <span class="hljs-built_in">MedianFinder</span>() &#123;<br>        <span class="hljs-keyword">while</span> (!maxHeap.<span class="hljs-built_in">empty</span>())<br>            maxHeap.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">while</span> (!minHeap.<span class="hljs-built_in">empty</span>())<br>            minHeap.<span class="hljs-built_in">pop</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addNum</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (maxHeap.<span class="hljs-built_in">size</span>() == minHeap.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-comment">//大小相等，优先向大顶堆添加</span><br>            <span class="hljs-comment">//具体操作时先添加到小顶堆，拿到小顶堆中最小的，再添加到大顶堆中</span><br>            minHeap.<span class="hljs-built_in">push</span>(num);<br>            maxHeap.<span class="hljs-built_in">push</span>(minHeap.<span class="hljs-built_in">top</span>());<br>            minHeap.<span class="hljs-built_in">pop</span>();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//同理</span><br>            maxHeap.<span class="hljs-built_in">push</span>(num);<br>            minHeap.<span class="hljs-built_in">push</span>(maxHeap.<span class="hljs-built_in">top</span>());<br>            maxHeap.<span class="hljs-built_in">pop</span>();<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">findMedian</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (maxHeap.<span class="hljs-built_in">size</span>() == minHeap.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-comment">//大小相等，返回均值</span><br>            <span class="hljs-keyword">return</span> ((<span class="hljs-type">double</span>) maxHeap.<span class="hljs-built_in">top</span>() + minHeap.<span class="hljs-built_in">top</span>()) / <span class="hljs-number">2</span>;<br>        &#125; <span class="hljs-keyword">else</span><br>            <span class="hljs-comment">//大顶堆元素多，返回大顶堆的堆顶</span><br>            <span class="hljs-built_in">return</span> (<span class="hljs-type">double</span>) maxHeap.<span class="hljs-built_in">top</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MedianFinder object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MedianFinder* obj = new MedianFinder();</span><br><span class="hljs-comment"> * obj-&gt;addNum(num);</span><br><span class="hljs-comment"> * double param_2 = obj-&gt;findMedian();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="双指针"><a class="markdownIt-Anchor" href="#双指针"></a> 双指针</h2><h3 id="剑指-offer-18-删除链表的节点"><a class="markdownIt-Anchor" href="#剑指-offer-18-删除链表的节点"></a> <a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/">剑指 Offer 18. 删除链表的节点</a></h3><p>双指针遍历。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">deleteNode</span><span class="hljs-params">(ListNode *head, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-comment">//虚拟头节点，避免多余的判断</span><br>        ListNode *pre, *dummyNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>), *p = head;<br>        dummyNode-&gt;next = head;<br>        pre = dummyNode;<br>        <span class="hljs-keyword">while</span> (p-&gt;val != val) &#123;<br>            pre = p;<br>            p = p-&gt;next;<br>        &#125;<br>        pre-&gt;next = p-&gt;next;<br>        <span class="hljs-keyword">return</span> dummyNode-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="剑指-offer-22-链表中倒数第k个节点"><a class="markdownIt-Anchor" href="#剑指-offer-22-链表中倒数第k个节点"></a> <a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">剑指 Offer 22. 链表中倒数第k个节点</a></h3><p>快慢指针。</p><p>快指针先于k个位置出发，然后两个指针同步走。</p><p>快指针走到尾时，慢指针离尾有k的距离。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getKthFromEnd</span><span class="hljs-params">(ListNode *head, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        ListNode *fast = head, *slow = head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            fast = fast-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (fast) &#123;<br>            fast = fast-&gt;next;<br>            slow = slow-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="剑指-offer-25-合并两个排序的链表"><a class="markdownIt-Anchor" href="#剑指-offer-25-合并两个排序的链表"></a> <a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">剑指 Offer 25. 合并两个排序的链表</a></h3><p>合并两个链表。</p><ul><li>可使用头节点 head，方便操作。</li><li>使用 tail 指向链表的尾，tail-&gt;next 即是下次要添加的位置。</li></ul><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode *l1, ListNode *l2)</span> </span>&#123;<br>        ListNode *head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>), *tail = head;<br>        ListNode *aPtr = l1, *bPtr = l2;<br>        <span class="hljs-keyword">while</span> (aPtr &amp;&amp; bPtr) &#123;<br>            <span class="hljs-keyword">if</span> (aPtr-&gt;val &lt; bPtr-&gt;val) &#123;<br>                tail-&gt;next = aPtr;<br>                aPtr = aPtr-&gt;next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                tail-&gt;next = bPtr;<br>                bPtr = bPtr-&gt;next;<br>            &#125;<br>            tail = tail-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">//将未遍历完的链表直接添加到 tail 后</span><br>        tail-&gt;next = aPtr ? aPtr : bPtr;<br>        <span class="hljs-keyword">return</span> head-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="剑指-offer-52-两个链表的第一个公共节点"><a class="markdownIt-Anchor" href="#剑指-offer-52-两个链表的第一个公共节点"></a> <a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">剑指 Offer 52. 两个链表的第一个公共节点</a></h3><p>本题运用双指针。</p><blockquote><p>怎么让两个速度相同，跑道不同的人相遇？</p><p>答案是交换他们的跑道</p></blockquote><p>我们让两个指针分别从两条链表的头开始向后走，当其中一个链表走到尾端（即指向为空）时，让其从另一个链表头开始再走一遍，直到俩链表相遇或是都为空。</p><p>假设A链表长为A，B链表长为B，公共区域长为C。</p><p>从A出发的指针pA走完时，长度为A+C，相对的，pB走完时长度为B+C。</p><p>这时交换他们的跑道，pA走A+C+B，pB走B+C+A，因他们速度相同，要么在交点相遇，要么都走到空节点，此时返回他们指向的节点即可。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>        ListNode *aPtr = headA, *bPtr = headB;<br>        <span class="hljs-keyword">while</span> (aPtr &amp;&amp; bPtr) &#123;<br>            <span class="hljs-comment">//如果相同，则找到第一个公共节点</span><br>            <span class="hljs-keyword">if</span> (aPtr == bPtr)<br>                <span class="hljs-keyword">return</span> aPtr;<br>            aPtr = aPtr-&gt;next;<br>            bPtr = bPtr-&gt;next;<br>            <span class="hljs-comment">//如果都为空，说明无公共节点</span><br>            <span class="hljs-keyword">if</span> (!aPtr &amp;&amp; !bPtr)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>            <span class="hljs-comment">//两个指针走到尽头时，分别切换到另一个链表上</span><br>            <span class="hljs-keyword">if</span> (!aPtr)<br>                aPtr = headB;<br>            <span class="hljs-keyword">if</span> (!bPtr)<br>                bPtr = headA;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="剑指-offer-21-调整数组顺序使奇数位于偶数前面"><a class="markdownIt-Anchor" href="#剑指-offer-21-调整数组顺序使奇数位于偶数前面"></a> <a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</a></h3><p>头尾指针，头指针只选择偶数，尾指针只选择奇数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">exchange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>)<br>                left++;<br>            <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>                right--;<br>            <span class="hljs-built_in">swap</span>(nums[left], nums[right]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="剑指-offer-57-和为s的两个数字"><a class="markdownIt-Anchor" href="#剑指-offer-57-和为s的两个数字"></a> <a href="https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/">剑指 Offer 57. 和为s的两个数字</a></h3><p>头尾指针。</p><p>双指针之和大于 target ，尾指针减小，使和更小。</p><p>小于 target ，头指针增大，使和更大。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-type">int</span> sum = nums[left] + nums[right];<br>            <span class="hljs-keyword">if</span> (sum &lt; target)<br>                left++;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; target)<br>                right--;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        ans.<span class="hljs-built_in">push_back</span>(nums[left]);<br>        ans.<span class="hljs-built_in">push_back</span>(nums[right]);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="剑指-offer-58-i-翻转单词顺序"><a class="markdownIt-Anchor" href="#剑指-offer-58-i-翻转单词顺序"></a> <a href="https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/">剑指 Offer 58 - I. 翻转单词顺序</a></h3><p>倒序的快慢指针。</p><p>使用快慢指针搜索每一个单词，注意边界。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">reverseWords</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> fast = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, slow;<br>        vector&lt;string&gt; vector;<br>        string ans;<br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> ans;<br>        <span class="hljs-comment">//初始化到第一个非空字符</span><br>        <span class="hljs-keyword">while</span> (fast &gt;= <span class="hljs-number">0</span> &amp;&amp; s[fast] == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>            fast--;<br>        &#125;<br>        slow = fast;<br>        <span class="hljs-comment">//每次一个循环遍历一个单词加空隙</span><br>        <span class="hljs-keyword">while</span> (fast &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">//fast 指针遍历完整单词</span><br>            <span class="hljs-keyword">while</span> (fast &gt;= <span class="hljs-number">0</span> &amp;&amp; s[fast] != <span class="hljs-string">&#x27; &#x27;</span>)<br>                fast--;<br>            <span class="hljs-comment">//将单词添加到数组</span><br>            vector.<span class="hljs-built_in">push_back</span>(s.<span class="hljs-built_in">substr</span>(fast + <span class="hljs-number">1</span>, slow - fast));<br>            <span class="hljs-comment">//跳过空格</span><br>            <span class="hljs-keyword">while</span> (fast &gt;= <span class="hljs-number">0</span> &amp;&amp; s[fast] == <span class="hljs-string">&#x27; &#x27;</span>)<br>                fast--;<br>            slow = fast;<br>        &#125;<br>        <span class="hljs-comment">//拼接字符串</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; vector.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span>)<br>                ans += <span class="hljs-string">&#x27; &#x27;</span>;<br>            ans += vector[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="搜索与回溯算法"><a class="markdownIt-Anchor" href="#搜索与回溯算法"></a> 搜索与回溯算法</h2><h3 id="面试题32-i-从上到下打印二叉树"><a class="markdownIt-Anchor" href="#面试题32-i-从上到下打印二叉树"></a> <a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/">面试题32 - I. 从上到下打印二叉树</a></h3><p>最普通的层序遍历，使用队列。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    queue&lt;TreeNode *&gt; queue;<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">levelOrder</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root)<br>            <span class="hljs-keyword">return</span> ans;<br>        queue.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!queue.<span class="hljs-built_in">empty</span>()) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(queue.<span class="hljs-built_in">front</span>()-&gt;val);<br>            <span class="hljs-keyword">if</span> (queue.<span class="hljs-built_in">front</span>()-&gt;left)<br>                queue.<span class="hljs-built_in">push</span>(queue.<span class="hljs-built_in">front</span>()-&gt;left);<br>            <span class="hljs-keyword">if</span> (queue.<span class="hljs-built_in">front</span>()-&gt;right)<br>                queue.<span class="hljs-built_in">push</span>(queue.<span class="hljs-built_in">front</span>()-&gt;right);<br>            queue.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="剑指-offer-32-ii-从上到下打印二叉树-ii"><a class="markdownIt-Anchor" href="#剑指-offer-32-ii-从上到下打印二叉树-ii"></a> <a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">剑指 Offer 32 - II. 从上到下打印二叉树 II</a></h3><p>层序遍历我们一般使用队列，从左向右遍历时，将下一层的节点加入队列。</p><p>此题需要我们进行分层，我们便在while语句中进一步用for来细化各层，将开启每一层时队列的大小当作循环条件。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    queue&lt;TreeNode *&gt; queue;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode *root) &#123;<br>        <span class="hljs-keyword">if</span> (!root)<br>            <span class="hljs-keyword">return</span> ans;<br>        queue.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!queue.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">int</span> levelSize = queue.<span class="hljs-built_in">size</span>();<br>            ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; levelSize; ++i) &#123;<br>                ans.<span class="hljs-built_in">back</span>().<span class="hljs-built_in">push_back</span>(queue.<span class="hljs-built_in">front</span>()-&gt;val);<br>                <span class="hljs-keyword">if</span> (queue.<span class="hljs-built_in">front</span>()-&gt;left)<br>                    queue.<span class="hljs-built_in">push</span>(queue.<span class="hljs-built_in">front</span>()-&gt;left);<br>                <span class="hljs-keyword">if</span> (queue.<span class="hljs-built_in">front</span>()-&gt;right)<br>                    queue.<span class="hljs-built_in">push</span>(queue.<span class="hljs-built_in">front</span>()-&gt;right);<br>                queue.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="剑指-offer-32-iii-从上到下打印二叉树-iii"><a class="markdownIt-Anchor" href="#剑指-offer-32-iii-从上到下打印二叉树-iii"></a> <a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/">剑指 Offer 32 - III. 从上到下打印二叉树 III</a></h3><p>我们将奇数层和偶数层的操作分开。</p><p>level从0开始计数。</p><ul><li>奇数层：队首读，队尾入。</li><li>偶数层：队尾读，队首入。</li></ul><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    deque&lt;TreeNode *&gt; deque;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode *root) &#123;<br>        <span class="hljs-keyword">if</span> (!root)<br>            <span class="hljs-keyword">return</span> ans;<br>        deque.<span class="hljs-built_in">push_back</span>(root);<br>        <span class="hljs-type">int</span> level = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!deque.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">int</span> levelSize = deque.<span class="hljs-built_in">size</span>();<br>            ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; levelSize; ++i) &#123;<br>                <span class="hljs-keyword">if</span> (level % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">//偶数层，从队尾读，队首入</span><br>                    ans.<span class="hljs-built_in">back</span>().<span class="hljs-built_in">push_back</span>(deque.<span class="hljs-built_in">back</span>()-&gt;val);<br>                    <span class="hljs-keyword">if</span> (deque.<span class="hljs-built_in">back</span>()-&gt;left)<br>                        deque.<span class="hljs-built_in">push_front</span>(deque.<span class="hljs-built_in">back</span>()-&gt;left);<br>                    <span class="hljs-keyword">if</span> (deque.<span class="hljs-built_in">back</span>()-&gt;right)<br>                        deque.<span class="hljs-built_in">push_front</span>(deque.<span class="hljs-built_in">back</span>()-&gt;right);<br>                    deque.<span class="hljs-built_in">pop_back</span>();<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//奇数层，队首读，队尾入</span><br>                    ans.<span class="hljs-built_in">back</span>().<span class="hljs-built_in">push_back</span>(deque.<span class="hljs-built_in">front</span>()-&gt;val);<br>                    <span class="hljs-keyword">if</span> (deque.<span class="hljs-built_in">front</span>()-&gt;right)<br>                        deque.<span class="hljs-built_in">push_back</span>(deque.<span class="hljs-built_in">front</span>()-&gt;right);<br>                    <span class="hljs-keyword">if</span> (deque.<span class="hljs-built_in">front</span>()-&gt;left)<br>                        deque.<span class="hljs-built_in">push_back</span>(deque.<span class="hljs-built_in">front</span>()-&gt;left);<br>                    deque.<span class="hljs-built_in">pop_front</span>();<br>                &#125;<br>            &#125;<br>            level++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="剑指-offer-26-树的子结构"><a class="markdownIt-Anchor" href="#剑指-offer-26-树的子结构"></a> <a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/">剑指 Offer 26. 树的子结构</a></h3><p>我们先找到A中与B的根节点数值相同的节点。</p><p>然后再用递归比对B是否为A的子结构。</p><p><strong>策略</strong></p><ul><li>判断当前节点值是否相等，不等则返回 false，相等则递归继续判断。</li><li>如果B先递归完，说明之前的判断都没有问题，B为A的子结构，返回 true。</li><li>如果A先递归完，说明B的结构比A的长，B不为A的子结构，返回 false。</li></ul><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//遍历 A 的节点</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSubStructure</span><span class="hljs-params">(TreeNode *A, TreeNode *B)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!A || !B)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">//判断是否相等并且为子结构</span><br>        <span class="hljs-keyword">if</span> (A-&gt;val == B-&gt;val &amp;&amp; <span class="hljs-built_in">recur</span>(A, B))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//递归搜索</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isSubStructure</span>(A-&gt;left, B) || <span class="hljs-built_in">isSubStructure</span>(A-&gt;right, B);<br>    &#125;<br><br>    <span class="hljs-comment">//检查两棵树是否出现子结构</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">recur</span><span class="hljs-params">(TreeNode *A, TreeNode *B)</span> </span>&#123;<br>        <span class="hljs-comment">//如果 B 先走完，说明 A 包含 B</span><br>        <span class="hljs-keyword">if</span> (!B)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//如果 A 先走完，说明 A 不包含 B</span><br>        <span class="hljs-keyword">if</span> (!A)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">//如果在 B 走完之前出现节点值不相等，说明不包含子结构</span><br>        <span class="hljs-keyword">if</span> (A-&gt;val != B-&gt;val)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">//递归继续判断</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">recur</span>(A-&gt;left, B-&gt;left) &amp;&amp; <span class="hljs-built_in">recur</span>(A-&gt;right, B-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="剑指-offer-27-二叉树的镜像"><a class="markdownIt-Anchor" href="#剑指-offer-27-二叉树的镜像"></a> <a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/">剑指 Offer 27. 二叉树的镜像</a></h3><p>本体应用较基础的递归思想，直接递归交换即可。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode *<span class="hljs-title">mirrorTree</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-built_in">swapNode</span>(root);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-comment">//递归交换</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swapNode</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root)<br>            <span class="hljs-keyword">return</span>;<br>        TreeNode *temp = root-&gt;left;<br>        root-&gt;left = root-&gt;right;<br>        root-&gt;right = temp;<br>        <span class="hljs-built_in">swapNode</span>(root-&gt;left);<br>        <span class="hljs-built_in">swapNode</span>(root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="剑指-offer-28-对称的二叉树"><a class="markdownIt-Anchor" href="#剑指-offer-28-对称的二叉树"></a> <a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/">剑指 Offer 28. 对称的二叉树</a></h3><p>当有两个对称节点，他们应满足以下条件：</p><ul><li>两个节点值相同</li><li>左节点的右子节点与右节点的左子节点相同</li><li>左节点的左子节点与右节点的右子节点相同</li></ul><p>我们可以每次递归判断第一个条件，其他的则由递归来完成。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">recue</span>(root-&gt;left, root-&gt;right);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">recue</span><span class="hljs-params">(TreeNode *left, TreeNode *right)</span> </span>&#123;<br>        <span class="hljs-comment">//两节点都为空，对称</span><br>        <span class="hljs-keyword">if</span> (!left &amp;&amp; !right)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//其中一个为空，不对称</span><br>        <span class="hljs-keyword">if</span> (left &amp;&amp; !right || !left &amp;&amp; right)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">//两节点值相等，递归判断子节点</span><br>        <span class="hljs-keyword">if</span> (left-&gt;val == right-&gt;val)<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">recue</span>(left-&gt;left, right-&gt;right) &amp;&amp; <span class="hljs-built_in">recue</span>(left-&gt;right, right-&gt;left);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="剑指-offer-12-矩阵中的路径"><a class="markdownIt-Anchor" href="#剑指-offer-12-矩阵中的路径"></a> <a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/">剑指 Offer 12. 矩阵中的路径</a></h3><p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p><strong>题解</strong></p><p>DFS + 回溯。</p><p>本题 DFS 返回值为是否搜索到。</p><p>通过把访问过的 board 元素改为 <code>#</code> 。在原地实现了 isVisited 矩阵的功能，无需开辟新空间。</p><p>回溯时需要将 board 恢复，避免影响别的层搜索。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> rows, cols;<br>    string str;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">exist</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; &amp;board, string word)</span> </span>&#123;<br>        rows = board.<span class="hljs-built_in">size</span>();<br>        cols = board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        str = word;<br>        <span class="hljs-comment">//每一位都要当作起点搜一遍</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++) &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(board, i, j, <span class="hljs-number">0</span>))<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; &amp;board, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, <span class="hljs-type">int</span> depth)</span> </span>&#123;<br>        <span class="hljs-comment">//越界或已经搜索或当前字符不匹配</span><br>        <span class="hljs-keyword">if</span> (row &gt;= rows || row &lt; <span class="hljs-number">0</span> || col &gt;= cols || col &lt; <span class="hljs-number">0</span> || board[row][col] != str[depth])<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">//搜索到最后一层，返回</span><br>        <span class="hljs-keyword">if</span> (depth == str.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        board[row][col] = <span class="hljs-string">&#x27;#&#x27;</span>;<br>        <span class="hljs-type">bool</span> res = <span class="hljs-built_in">dfs</span>(board, row + <span class="hljs-number">1</span>, col, depth + <span class="hljs-number">1</span>) || <span class="hljs-built_in">dfs</span>(board, row - <span class="hljs-number">1</span>, col, depth + <span class="hljs-number">1</span>) ||<br>                   <span class="hljs-built_in">dfs</span>(board, row, col + <span class="hljs-number">1</span>, depth + <span class="hljs-number">1</span>) || <span class="hljs-built_in">dfs</span>(board, row, col - <span class="hljs-number">1</span>, depth + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//回溯，避免影响别的层的搜索</span><br>        board[row][col] = str[depth];<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="剑指-offer-13-机器人的运动范围"><a class="markdownIt-Anchor" href="#剑指-offer-13-机器人的运动范围"></a> <a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/">剑指 Offer 13. 机器人的运动范围</a></h3><p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p><p><strong>题解</strong></p><p>DFS + 回溯。</p><p>本题 DFS 返回值为当前可到达的格子数。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> rows, cols, kk;<br>    vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; isVisited;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">movingCount</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        isVisited = vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n));<br>        rows = m;<br>        cols = n;<br>        kk = k;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col)</span> </span>&#123;<br>        <span class="hljs-comment">//越界或是否已访问或不满足条件</span><br>        <span class="hljs-keyword">if</span> (row &gt; rows - <span class="hljs-number">1</span> || col &gt; cols - <span class="hljs-number">1</span> || isVisited[row][col] || kk &lt; <span class="hljs-built_in">bitSum</span>(row) + <span class="hljs-built_in">bitSum</span>(col))<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        isVisited[row][col] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-built_in">dfs</span>(row + <span class="hljs-number">1</span>, col) + <span class="hljs-built_in">dfs</span>(row, col + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//求数位和</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bitSum</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;<br>            sum += n % <span class="hljs-number">10</span>;<br>            n /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="剑指-offer-34-二叉树中和为某一值的路径"><a class="markdownIt-Anchor" href="#剑指-offer-34-二叉树中和为某一值的路径"></a> <a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">剑指 Offer 34. 二叉树中和为某一值的路径</a></h3><p>给你二树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</p><p>叶子节点 是指没有子节点的节点。</p><p><strong>题解</strong></p><p>DFS + 回溯。</p><p>满足叶子节点且路径和为零时，保存路径。</p><p>可用 target 减去路径值来代替每次计算路径和。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">pathSum</span>(TreeNode *root, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-built_in">dfs</span>(root, target);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">//修改状态</span><br>        path.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        target -= root-&gt;val;<br>        <span class="hljs-comment">//检查是否为叶子节点，并且 target 为零</span><br>        <span class="hljs-keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; target == <span class="hljs-number">0</span>)<br>            ans.<span class="hljs-built_in">push_back</span>(path);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left, target);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right, target);<br>        <span class="hljs-comment">//回溯，恢复原状</span><br>        path.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="剑指-offer-36-二叉搜索树与双向链表"><a class="markdownIt-Anchor" href="#剑指-offer-36-二叉搜索树与双向链表"></a> <a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/">剑指 Offer 36. 二叉搜索树与双向链表</a></h3><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p><p><strong>题解</strong></p><p>DFS。</p><p>利用中序遍历生成有序序列。并维护 pre 值。</p><p>每次操作根节点时，将当前节点与 pre 值建立连接。</p><p>最后操作头尾节点。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">// Definition for a Node.</span><br><span class="hljs-comment">class Node &#123;</span><br><span class="hljs-comment">public:</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    Node* left;</span><br><span class="hljs-comment">    Node* right;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Node() &#123;&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Node(int _val) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">        left = NULL;</span><br><span class="hljs-comment">        right = NULL;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Node(int _val, Node* _left, Node* _right) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">        left = _left;</span><br><span class="hljs-comment">        right = _right;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    Node *pre, *head;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Node *<span class="hljs-title">treeToDoublyList</span><span class="hljs-params">(Node *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-comment">//最后处理头尾节点</span><br>        head-&gt;left = pre;<br>        pre-&gt;right = head;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(Node *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">//递归操作左子树</span><br>        <span class="hljs-built_in">dfs</span>(root-&gt;left);<br>        <span class="hljs-comment">//当前节点操作</span><br>        <span class="hljs-keyword">if</span> (!pre) &#123;<br>            <span class="hljs-comment">//如果 pre 为空，说明当前节点是头节点，赋值给 head</span><br>            head = root;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//如果不为空，将当前节点与 pre 建立连接</span><br>            pre-&gt;right = root;<br>            root-&gt;left = pre;<br>        &#125;<br>        <span class="hljs-comment">//更新 pre 的值为当前节点</span><br>        pre = root;<br>        <span class="hljs-comment">//递归操作右子树</span><br>        <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="剑指-offer-54-二叉搜索树的第k大节点"><a class="markdownIt-Anchor" href="#剑指-offer-54-二叉搜索树的第k大节点"></a> <a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">剑指 Offer 54. 二叉搜索树的第k大节点</a></h3><p>给定一棵二叉搜索树，请找出其中第 k 大的节点的值。</p><p><strong>题解</strong></p><p>中序便利的逆序。</p><p>直接计数。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> ans, kNum;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kthLargest</span><span class="hljs-params">(TreeNode *root, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        kNum = k;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>        kNum--;<br>        <span class="hljs-keyword">if</span> (kNum == <span class="hljs-number">0</span>) &#123;<br>            ans = root-&gt;val;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="剑指-offer-55-i-二叉树的深度"><a class="markdownIt-Anchor" href="#剑指-offer-55-i-二叉树的深度"></a> <a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/">剑指 Offer 55 - I. 二叉树的深度</a></h3><p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p><p><strong>题解</strong></p><p>经典问题，递归求解。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span>(<span class="hljs-built_in">maxDepth</span>(root-&gt;left), <span class="hljs-built_in">maxDepth</span>(root-&gt;right));<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="剑指-offer-55-ii-平衡二叉树"><a class="markdownIt-Anchor" href="#剑指-offer-55-ii-平衡二叉树"></a> <a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/">剑指 Offer 55 - II. 平衡二叉树</a></h3><p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p><p><strong>题解</strong></p><p>平衡二叉树</p><ul><li>空树</li><li>节点的左右子树的深度相差不超过 1 且左右子树也是平衡二叉树</li></ul><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//判断高度</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(<span class="hljs-built_in">maxDepth</span>(root-&gt;left) - <span class="hljs-built_in">maxDepth</span>(root-&gt;right)) &gt; <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">//判断左右子树</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isBalanced</span>(root-&gt;left) &amp;&amp; <span class="hljs-built_in">isBalanced</span>(root-&gt;right);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span>(<span class="hljs-built_in">maxDepth</span>(root-&gt;left), <span class="hljs-built_in">maxDepth</span>(root-&gt;right));<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="剑指-offer-64-求12n"><a class="markdownIt-Anchor" href="#剑指-offer-64-求12n"></a> <a href="https://leetcode-cn.com/problems/qiu-12n-lcof/">剑指 Offer 64. 求1+2+…+n</a></h3><p>求 <code>1+2+...+n</code> ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p><p><strong>题解</strong></p><p>逻辑符短路。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumNums</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        n &gt; <span class="hljs-number">1</span> &amp;&amp; (n += <span class="hljs-built_in">sumNums</span>(n - <span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">return</span> n;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="剑指-offer-68-i-二叉搜索树的最近公共祖先"><a class="markdownIt-Anchor" href="#剑指-offer-68-i-二叉搜索树的最近公共祖先"></a> <a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/">剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</a></h3><p>迭代。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode *<span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode *root, TreeNode *p, TreeNode *q)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (root) &#123;<br>            <span class="hljs-keyword">if</span> (root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val) &#123;<br>                root = root-&gt;left;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val) &#123;<br>                root = root-&gt;right;<br>            &#125; <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="剑指-offer-68-ii-二叉树的最近公共祖先"><a class="markdownIt-Anchor" href="#剑指-offer-68-ii-二叉树的最近公共祖先"></a> <a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/">剑指 Offer 68 - II. 二叉树的最近公共祖先</a></h3><p>DFS</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode *<span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode *root, TreeNode *p, TreeNode *q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span> || root == p || root == q) <span class="hljs-keyword">return</span> root;<br>        TreeNode *left = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);<br>        TreeNode *right = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);<br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> right;<br>        <span class="hljs-keyword">if</span> (right == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> left;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="位运算"><a class="markdownIt-Anchor" href="#位运算"></a> 位运算</h2><h3 id="剑指-offer-15-二进制中1的个数"><a class="markdownIt-Anchor" href="#剑指-offer-15-二进制中1的个数"></a> <a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/">剑指 Offer 15. 二进制中1的个数</a></h3><p>用每位去和 1 与，结果为 1 说明该位为 1。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>)<br>                cnt++;<br>            n = n &gt;&gt; <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="剑指-offer-65-不用加减乘除做加法"><a class="markdownIt-Anchor" href="#剑指-offer-65-不用加减乘除做加法"></a> <a href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/">剑指 Offer 65. 不用加减乘除做加法</a></h3><p>全加器的原理。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (b) &#123;<br>            <span class="hljs-type">int</span> carry = a &amp; b; <span class="hljs-comment">// 计算 进位</span><br>            a = a ^ b; <span class="hljs-comment">// 计算 本位</span><br>            b = (<span class="hljs-type">unsigned</span>)carry &lt;&lt; <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="剑指-offer-56-i-数组中数字出现的次数"><a class="markdownIt-Anchor" href="#剑指-offer-56-i-数组中数字出现的次数"></a> <a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/">剑指 Offer 56 - I. 数组中数字出现的次数</a></h3><p>一个整型数组 <code>nums</code> 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p><p><strong>题解</strong></p><p>先全部按位异或，结果就是两个数字异或的结果。</p><p>保存该结果中 1 出现的最低位，该位即是两个数字不同的最低位。</p><p>用该位将数组分组异或，得到的结果就是两个数。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">singleNumbers</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> z = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            z ^= nums[i];<br>        &#125;<br>        <span class="hljs-type">int</span> m = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (!(m &amp; z))<br>            m &lt;&lt;= <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)<br>            <span class="hljs-keyword">if</span> (m &amp; nums[i])<br>                a ^= nums[i];<br>            <span class="hljs-keyword">else</span><br>                b ^= nums[i];<br>        <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-type">int</span>&gt;&#123;a, b&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="剑指-offer-56-ii-数组中数字出现的次数-ii"><a class="markdownIt-Anchor" href="#剑指-offer-56-ii-数组中数字出现的次数-ii"></a> <a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/">剑指 Offer 56 - II. 数组中数字出现的次数 II</a></h3><p>在一个数组 <code>nums</code> 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p><p><strong>题解</strong></p><p>按位加，模 3 后得到结果</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">counts</span><span class="hljs-params">(<span class="hljs-number">32</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">32</span>; j++) &#123;<br>                counts[j] += nums[i] &amp; <span class="hljs-number">1</span>;<br>                nums[i] &gt;&gt;= <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>, MOD = <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++) &#123;<br>            ans &lt;&lt;= <span class="hljs-number">1</span>;<br>            ans |= counts[<span class="hljs-number">31</span> - i] % MOD;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="栈与队列"><a class="markdownIt-Anchor" href="#栈与队列"></a> 栈与队列</h2><h3 id="剑指-offer-09-用两个栈实现队列"><a class="markdownIt-Anchor" href="#剑指-offer-09-用两个栈实现队列"></a> <a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">剑指 Offer 09. 用两个栈实现队列</a></h3><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p><p><strong>题解</strong></p><p>维护两个栈，一个栈stack_in只负责输出，另一个栈stack_out只负责输入。</p><p>当stack_out为空时，将stack_in倒入stack_out中。</p><p>因为栈的先入后出特性，此过程完成了一次反转，变成了先入先出，符合队列的特性</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CQueue</span> &#123;<br>    stack&lt;<span class="hljs-type">int</span>&gt; stack_in, stack_out;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">CQueue</span>() &#123;<br>        <span class="hljs-keyword">while</span> (!stack_in.<span class="hljs-built_in">empty</span>()) &#123;<br>            stack_in.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">while</span> (!stack_out.<span class="hljs-built_in">empty</span>()) &#123;<br>            stack_out.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">appendTail</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>        stack_in.<span class="hljs-built_in">push</span>(value);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">deleteHead</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//输出栈为空，将输入栈倒入输出栈中</span><br>        <span class="hljs-keyword">if</span> (stack_out.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">while</span> (!stack_in.<span class="hljs-built_in">empty</span>()) &#123;<br>                stack_out.<span class="hljs-built_in">push</span>(stack_in.<span class="hljs-built_in">top</span>());<br>                stack_in.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//如果倾倒完，输出栈还为空，说明队列为空</span><br>        <span class="hljs-keyword">if</span> (stack_out.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> ret = stack_out.<span class="hljs-built_in">top</span>();<br>            stack_out.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">return</span> ret;<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your CQueue object will be instantiated and called as such:</span><br><span class="hljs-comment"> * CQueue* obj = new CQueue();</span><br><span class="hljs-comment"> * obj-&gt;appendTail(value);</span><br><span class="hljs-comment"> * int param_2 = obj-&gt;deleteHead();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h3 id="剑指-offer-30-包含min函数的栈"><a class="markdownIt-Anchor" href="#剑指-offer-30-包含min函数的栈"></a> <a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/">剑指 Offer 30. 包含min函数的栈</a></h3><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p><p><strong>题解</strong></p><p><strong>解法一 保存最小元素信息</strong></p><p>由于栈的特性，每个元素退出、插入后、访问时，该栈的结构不会发生变化，所以我们可以在插入元素时存：<strong>到该元素为止最小的元素</strong>。</p><p>这样，每次访问一个元素时，当前栈中最小的元素值一定是该位置保存的最小元素值。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">MinNode</span> &#123;<br>        <span class="hljs-type">int</span> min;<br>        <span class="hljs-type">int</span> value;<br><br>        <span class="hljs-built_in">MinNode</span>(<span class="hljs-type">int</span> min, <span class="hljs-type">int</span> value) : <span class="hljs-built_in">min</span>(min), <span class="hljs-built_in">value</span>(value) &#123;&#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">typedef</span> MinNode *PtrToNode;<br>    stack&lt;PtrToNode&gt; stack;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/** initialize your data structure here. */</span><br>    <span class="hljs-built_in">MinStack</span>() &#123;<br>        <span class="hljs-keyword">while</span> (!stack.<span class="hljs-built_in">empty</span>()) &#123;<br>            stack.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (stack.<span class="hljs-built_in">empty</span>()) &#123;<br>            stack.<span class="hljs-built_in">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">MinNode</span>(x, x));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (x &lt; stack.<span class="hljs-built_in">top</span>()-&gt;min) &#123;<br>                stack.<span class="hljs-built_in">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">MinNode</span>(x, x));<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                stack.<span class="hljs-built_in">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">MinNode</span>(stack.<span class="hljs-built_in">top</span>()-&gt;min, x));<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        stack.<span class="hljs-built_in">pop</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stack.<span class="hljs-built_in">top</span>()-&gt;value;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">min</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stack.<span class="hljs-built_in">top</span>()-&gt;min;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MinStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MinStack* obj = new MinStack();</span><br><span class="hljs-comment"> * obj-&gt;push(x);</span><br><span class="hljs-comment"> * obj-&gt;pop();</span><br><span class="hljs-comment"> * int param_3 = obj-&gt;top();</span><br><span class="hljs-comment"> * int param_4 = obj-&gt;min();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p><strong>解法二 单调栈</strong></p><p>使用单调栈，我们维护栈中元素递减。</p><p>为了不丢失信息，我们在新元素不符合递减时不弹出栈中元素，而是在符合递减时才加入新元素。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br>    <span class="hljs-comment">//递减栈</span><br>    stack&lt;<span class="hljs-type">int</span>&gt; minStack;<br>    stack&lt;<span class="hljs-type">int</span>&gt; stack;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/** initialize your data structure here. */</span><br>    <span class="hljs-built_in">MinStack</span>() &#123;<br>        <span class="hljs-keyword">while</span> (!stack.<span class="hljs-built_in">empty</span>())<br>            stack.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">while</span> (!minStack.<span class="hljs-built_in">empty</span>()) &#123;<br>            minStack.<span class="hljs-built_in">empty</span>();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        stack.<span class="hljs-built_in">push</span>(x);<br>        <span class="hljs-keyword">if</span> (minStack.<span class="hljs-built_in">empty</span>() || x &lt;= minStack.<span class="hljs-built_in">top</span>())<br>            minStack.<span class="hljs-built_in">push</span>(x);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (stack.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (stack.<span class="hljs-built_in">top</span>() == minStack.<span class="hljs-built_in">top</span>())<br>            minStack.<span class="hljs-built_in">pop</span>();<br>        stack.<span class="hljs-built_in">pop</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (stack.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> stack.<span class="hljs-built_in">top</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">min</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (stack.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> minStack.<span class="hljs-built_in">top</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MinStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MinStack* obj = new MinStack();</span><br><span class="hljs-comment"> * obj-&gt;push(x);</span><br><span class="hljs-comment"> * obj-&gt;pop();</span><br><span class="hljs-comment"> * int param_3 = obj-&gt;top();</span><br><span class="hljs-comment"> * int param_4 = obj-&gt;min();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="字符串"><a class="markdownIt-Anchor" href="#字符串"></a> 字符串</h2><h3 id="剑指-offer-05-替换空格"><a class="markdownIt-Anchor" href="#剑指-offer-05-替换空格"></a> <a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">剑指 Offer 05. 替换空格</a></h3><p>请实现一个函数，把字符串 s 中的每个空格替换成&quot;%20&quot;。</p><p><strong>题解</strong></p><p>没啥好说的，直接遍历</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">replaceSpace</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        string ans;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ch:s) &#123;<br>            <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;%&#x27;</span>);<br>                ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;2&#x27;</span>);<br>                ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;0&#x27;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(ch);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="剑指-offer-58-ii-左旋转字符串"><a class="markdownIt-Anchor" href="#剑指-offer-58-ii-左旋转字符串"></a> <a href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">剑指 Offer 58 - II. 左旋转字符串</a></h3><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串&quot;abcdefg&quot;和数字2，该函数将返回左旋转两位得到的结果&quot;cdefgab&quot;。</p><p><strong>题解</strong></p><p>使用string类的substr()方法，直接拼接字符串。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">reverseLeftWords</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        string ans;<br>        ans = s.<span class="hljs-built_in">substr</span>(n);<br>        ans += s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, n);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="分治算法"><a class="markdownIt-Anchor" href="#分治算法"></a> 分治算法</h2><h3 id="剑指-offer-07-重建二叉树"><a class="markdownIt-Anchor" href="#剑指-offer-07-重建二叉树"></a> <a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/">剑指 Offer 07. 重建二叉树</a></h3><p>输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。</p><p>假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><p><strong>题解</strong></p><p>分治。</p><p>对于任意一颗树而言，前序遍历的形式总是</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[ 根节点, <span class="hljs-comment">[左子树的前序遍历结果]</span>, <span class="hljs-comment">[右子树的前序遍历结果]</span> ]</span><br></code></pre></td></tr></table></figure><p>即根节点总是前序遍历中的第一个节点。而中序遍历的形式总是</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[ <span class="hljs-comment">[左子树的中序遍历结果]</span>, 根节点, <span class="hljs-comment">[右子树的中序遍历结果]</span> ]</span><br></code></pre></td></tr></table></figure><ul><li>使用 map 对应，便于定位该值在 inorder 中的位置。</li><li>左子树在前序中的根节点位于：<code>pre_root + 1</code>,左子树在中序中的边界：<code>[in_left, in_root - 1]</code></li><li>右子树在前序中的根节点位于：根节点+左子树长度+1 = <code>pre_root + in_root - in_left + 1</code>，右子树在中序中的边界：<code>[in_root + 1, in_right]</code></li></ul><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; map;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode *<span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;preorder, vector&lt;<span class="hljs-type">int</span>&gt; &amp;inorder)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; inorder.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            map[inorder[i]] = i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">build</span>(preorder, inorder, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, inorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function">TreeNode *<span class="hljs-title">build</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;preorder, vector&lt;<span class="hljs-type">int</span>&gt; &amp;inorder, <span class="hljs-type">int</span> pre_root, <span class="hljs-type">int</span> in_left, <span class="hljs-type">int</span> in_right)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (in_left &gt; in_right)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        TreeNode *root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(preorder[pre_root]);<br>        <span class="hljs-comment">// 根节点在中序序列中的位置，用于划分左右子树的边界</span><br>        <span class="hljs-type">int</span> in_root = map[preorder[pre_root]];<br>        <span class="hljs-comment">// 左子树在前序中的根节点位于：pre_root+1,左子树在中序中的边界：[in_left,in_root-1]</span><br>        root-&gt;left = <span class="hljs-built_in">build</span>(preorder, inorder, pre_root + <span class="hljs-number">1</span>, in_left, in_root - <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 右子树在前序中的根节点位于：根节点+左子树长度+1 = pre_root+in_root-in_left+1</span><br>        <span class="hljs-comment">// 右子树在中序中的边界：[in_root+1,in_right]</span><br>        root-&gt;right = <span class="hljs-built_in">build</span>(preorder, inorder, pre_root + in_root - in_left + <span class="hljs-number">1</span>, in_root + <span class="hljs-number">1</span>, in_right);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="剑指-offer-16-数值的整数次方"><a class="markdownIt-Anchor" href="#剑指-offer-16-数值的整数次方"></a> <a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/">剑指 Offer 16. 数值的整数次方</a></h3><p>实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。</p><p><strong>题解</strong></p><p>快速幂。</p><p>通过对 1 左移去判断当前位需不需要乘进 ans 中。同时保持 x 的自增长。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">myPow</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">bool</span> isNegative = <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> N = n;<br>        <span class="hljs-keyword">if</span> (N == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//对 n 取反</span><br>        <span class="hljs-keyword">if</span> (N &lt; <span class="hljs-number">0</span>)<br>            isNegative = <span class="hljs-literal">true</span>, N = -N;<br>        <span class="hljs-type">double</span> ret = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; ++i) &#123;<br>            <span class="hljs-keyword">if</span> ((<span class="hljs-number">1</span> &lt;&lt; i) &amp; N)<br>                ret *= x;<br>            x = x * x;<br>        &#125;<br>        <span class="hljs-comment">//本质上的差别只是最后的返回值</span><br>        <span class="hljs-keyword">if</span> (isNegative)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span> / ret;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="剑指-offer-33-二叉搜索树的后序遍历序列"><a class="markdownIt-Anchor" href="#剑指-offer-33-二叉搜索树的后序遍历序列"></a> <a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/">剑指 Offer 33. 二叉搜索树的后序遍历序列</a></h3><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。</p><p><strong>题解</strong></p><p>分治，二叉搜索树的左子树应当都比根节点小，右子树应当都比根节点大。</p><p>所以我们可以把遇到的第一个比根节点大的数定义为右子树的左区间端点，如果其中再出现比根节点小的数，证明不是二叉搜索树。</p><p>同时需要左右子树都是二叉搜索数。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">verifyPostorder</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;postorder)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">recur</span>(postorder, <span class="hljs-number">0</span>, postorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">recur</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;postorder, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (left &gt;= right)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">int</span> p = left;<br>        <span class="hljs-keyword">while</span> (postorder[p] &lt; postorder[right])<br>            p++;<br>        <span class="hljs-type">int</span> m = p;<br>        <span class="hljs-keyword">while</span> (postorder[p] &gt; postorder[right])<br>            p++;<br>        <span class="hljs-keyword">return</span> p == right &amp;&amp; <span class="hljs-built_in">recur</span>(postorder, left, m - <span class="hljs-number">1</span>) &amp;&amp; <span class="hljs-built_in">recur</span>(postorder, m, right - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划"></a> 动态规划</h2><h3 id="剑指-offer-10-i-斐波那契数列"><a class="markdownIt-Anchor" href="#剑指-offer-10-i-斐波那契数列"></a> <a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">剑指 Offer 10- I. 斐波那契数列</a></h3><p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">F</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span> = <span class="hljs-number">0</span>,   <span class="hljs-built_in">F</span>(<span class="hljs-number">1</span>) = <span class="hljs-number">1</span><br><span class="hljs-function"><span class="hljs-title">F</span><span class="hljs-params">(N)</span></span> = <span class="hljs-built_in">F</span>(N - <span class="hljs-number">1</span>) + <span class="hljs-built_in">F</span>(N - <span class="hljs-number">2</span>), 其中 N &gt; <span class="hljs-number">1</span>.<br></code></pre></td></tr></table></figure><p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p><strong>题解</strong></p><p>普通的递归会超时，因为有很多的重复计算，需要优化。</p><p>在这里我们使用动态规划。</p><p>维护一个滑动窗口，根据前两个值直接计算出第三个值。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-type">int</span> first = <span class="hljs-number">0</span>, second = <span class="hljs-number">0</span>, third = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i) &#123;<br>            first = second;<br>            second = third;<br>            third = (first + second) % MOD;<br>        &#125;<br>        <span class="hljs-keyword">return</span> third;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="剑指-offer-10-ii-青蛙跳台阶问题"><a class="markdownIt-Anchor" href="#剑指-offer-10-ii-青蛙跳台阶问题"></a> <a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/">剑指 Offer 10- II. 青蛙跳台阶问题</a></h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p><strong>题解</strong></p><p>我们从后往前看，当青蛙要跳上 n 阶时，要么跳一步，要么跳两步。</p><p>所以 n 阶的跳法就是 n-1 阶和 n-2阶的和。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">dp<span class="hljs-comment">[i]</span>=dp<span class="hljs-comment">[i-1]</span> + dp<span class="hljs-comment">[i-2]</span><br></code></pre></td></tr></table></figure><p>本体与斐波那契数列类似，都可以用动态规划。</p><p>注意边界条件</p><blockquote><p>dp[0]=1</p><p>dp[1]=1</p></blockquote><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numWays</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> first = <span class="hljs-number">0</span>, second = <span class="hljs-number">1</span>, third = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i) &#123;<br>            first = second;<br>            second = third;<br>            third = (first + second) % MOD;<br>        &#125;<br>        <span class="hljs-keyword">return</span> third;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="剑指-offer-63-股票的最大利润"><a class="markdownIt-Anchor" href="#剑指-offer-63-股票的最大利润"></a> <a href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/">剑指 Offer 63. 股票的最大利润</a></h3><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p><p><strong>题解</strong></p><p>直接保存历史最低价格，与每天的价格比较，记录最大利润。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;prices)</span> </span>&#123;<br>        <span class="hljs-type">int</span> min = INT_MAX, ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; prices.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">if</span> (prices[i] &lt; min)<br>                min = prices[i];<br>            <span class="hljs-keyword">if</span> (prices[i] - min &gt; ans)<br>                ans = prices[i] - min;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="剑指-offer-42-连续子数组的最大和"><a class="markdownIt-Anchor" href="#剑指-offer-42-连续子数组的最大和"></a> <a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/">剑指 Offer 42. 连续子数组的最大和</a></h3><p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p><p>要求时间复杂度为O(n)。</p><p><strong>题解</strong></p><p>动态规划。</p><p>dp数组存到每个位置为止的最大子列和。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">dp[i] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>] + nums[i], nums[i]);<br></code></pre></td></tr></table></figure><p>将前一位的最大子列和与本位相加</p><ul><li>如果小于本位，则说明本位可另起最大子列。</li><li>如果大于本位，则本位储存该结果，表示到该位为止的最大子列和</li></ul><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size())</span></span>;<br>        <span class="hljs-type">int</span> ans = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-comment">//边界判断</span><br>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;<br>                dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">//递推关系，比较本位和本位加上前一位的最大子列和，得出本位的最大子列和</span><br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>] + nums[i], nums[i]);<br>            <span class="hljs-comment">//储存结果</span><br>            <span class="hljs-keyword">if</span> (dp[i] &gt; ans)<br>                ans = dp[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="剑指-offer-47-礼物的最大价值"><a class="markdownIt-Anchor" href="#剑指-offer-47-礼物的最大价值"></a> <a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/">剑指 Offer 47. 礼物的最大价值</a></h3><p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p><p><strong>题解</strong></p><p>动态规划。</p><p>二维dp，dp矩阵的每个值储存到该位置为止，拿到的最大价值。</p><p>因为每个位置可从上边或者左边拿，所以比较两个位置的最大值，再加上本位的价值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]) + grid[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure><p>可以用新数组，最左列和最上列初始化为0，可省略边界判断。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxValue</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;grid)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(grid.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//初始化，避免边界判断</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; dp.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            dp[i] = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; dp.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; dp[i].<span class="hljs-built_in">size</span>(); ++j) &#123;<br>                <span class="hljs-comment">//递推关系，从左和上两个方向选出最大值，加上本位价值，得出到本位的最大价值</span><br>                dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]) + grid[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                <span class="hljs-comment">//保存结果</span><br>                ans = <span class="hljs-built_in">max</span>(dp[i][j], ans);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="剑指-offer-46-把数字翻译成字符串"><a class="markdownIt-Anchor" href="#剑指-offer-46-把数字翻译成字符串"></a> <a href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/">剑指 Offer 46. 把数字翻译成字符串</a></h3><p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p><p><strong>题解</strong></p><p>类似于跳台阶，区别在于，需要判断能不能跳两个台阶。</p><p>dp 数组储存到当前位置为止的跳法数量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">translateNum</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>        string str = <span class="hljs-built_in">to_string</span>(num);<br>        <span class="hljs-keyword">if</span> (str.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(str.length())</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">stoi</span>(str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>)) &lt; <span class="hljs-number">26</span>)<br>            dp[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">else</span><br>            dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; str.<span class="hljs-built_in">length</span>(); ++i) &#123;<br>            <span class="hljs-type">int</span> num_two = <span class="hljs-built_in">stoi</span>(str.<span class="hljs-built_in">substr</span>(i - <span class="hljs-number">1</span>, <span class="hljs-number">2</span>));<br>            <span class="hljs-keyword">if</span> (num_two &gt; <span class="hljs-number">9</span> &amp;&amp; num_two &lt; <span class="hljs-number">26</span>)<br>                dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">else</span><br>                dp[i] = dp[i - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[str.<span class="hljs-built_in">length</span>() - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="剑指-offer-48-最长不含重复字符的子字符串"><a class="markdownIt-Anchor" href="#剑指-offer-48-最长不含重复字符的子字符串"></a> <a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/">剑指 Offer 48. 最长不含重复字符的子字符串</a></h3><p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p><p><strong>题解</strong></p><p>动态规划。</p><p>使用 dp 数组存到当前位置为止，最长不重复子串。用 map 存每个字符在当前子串里的位置。</p><p>当遇到重复字符，我们用当前位置减去字符在上一个子串里的位置得到裁剪出的新串长度。</p><p>但如果裁剪出的新串长度大于累加得到的新串长度，说明该字符已经在过去被裁剪过，现在只要累加就好。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; map;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(s.size())</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        map[s[<span class="hljs-number">0</span>]] = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">if</span> (map.<span class="hljs-built_in">count</span>(s[i]) &gt; <span class="hljs-number">0</span> &amp;&amp; i - map[s[i]] &lt; dp[i - <span class="hljs-number">1</span>]+<span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-comment">//裁剪出的新串长度小于累加得到的新串长度，说明该字符在过去被裁剪过</span><br>                dp[i] = i - map[s[i]];<br>            &#125; <span class="hljs-keyword">else</span><br>                dp[i] = dp[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            ans = <span class="hljs-built_in">max</span>(dp[i], ans);<br>            map[s[i]] = i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="查找算法"><a class="markdownIt-Anchor" href="#查找算法"></a> 查找算法</h2><h3 id="剑指-offer-03-数组中重复的数字"><a class="markdownIt-Anchor" href="#剑指-offer-03-数组中重复的数字"></a> <a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">剑指 Offer 03. 数组中重复的数字</a></h3><p>找出数组中重复的数字。</p><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p><p><strong>题解</strong></p><p><strong>解法一</strong></p><p>遍历，保存到set里</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    set&lt;<span class="hljs-type">int</span>&gt; set;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findRepeatNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> item:nums) &#123;<br>            <span class="hljs-keyword">if</span> (set.<span class="hljs-built_in">count</span>(item) &gt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> item;<br>            set.<span class="hljs-built_in">insert</span>(item);<br>        &#125;<br>        <span class="hljs-comment">//题目保证有重复，这里返回什么都可以</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>解法二</strong></p><p>原地交换。</p><p>遍历时，将元素与元素值对应的索引地址交换，形成 <code>nums[i] == nums[nums[i]]</code> 。</p><p>这样，下次遇到相同的 <code>nums[i]</code> 想交换时，会发现目标位置已经有重复值，最后返回这个重复值</p><p><strong>注意</strong></p><p>如果进行了一次交换，<code>i</code> 不要增加，因为不能保证交换过来的元素（也就是 <code>i</code> 位置当前的元素）处于正确的位置，所以我们需要再对 <code>i</code> 位置判断一次。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findRepeatNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] != i) &#123;<br>                <span class="hljs-keyword">if</span> (nums[i] == nums[nums[i]])<br>                    <span class="hljs-keyword">return</span> nums[i];<br>                <span class="hljs-built_in">swap</span>(nums[i], nums[nums[i]]);<br>                <span class="hljs-comment">//i不增加，对当前位置再判断一次</span><br>                i--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="剑指-offer-53-i-在排序数组中查找数字-i"><a class="markdownIt-Anchor" href="#剑指-offer-53-i-在排序数组中查找数字-i"></a> <a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/">剑指 Offer 53 - I. 在排序数组中查找数字 I</a></h3><p>统计一个数字在排序数组中出现的次数。</p><p><strong>题解</strong></p><p>两次二分，分别找 <code>target</code> 的上界和下界，返回差值。</p><p>注意二分的边界和落点判断。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, mid;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            mid = (left + right) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &lt; target)<br>                left = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> lBound = left;<br>        left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            mid = (left + right) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &lt;= target)<br>                left = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> rBound = left;<br>        <span class="hljs-keyword">return</span> rBound - lBound;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="剑指-offer-53-ii-0~n-1中缺失的数字"><a class="markdownIt-Anchor" href="#剑指-offer-53-ii-0~n-1中缺失的数字"></a> <a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/">剑指 Offer 53 - II. 0～n-1中缺失的数字</a></h3><p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p><p><strong>题解</strong></p><p>排序数组，优先使用二分法。</p><p>思考缺失的位置有什么特殊点（可比较点）。</p><p>缺失的位置左边都应是 <code>nums[i]=i</code> ，所以我们直接寻找该序列的最右端，最右端右侧的位置就是缺失的位置。</p><p>注意二分的边界和落点判断。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">missingNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, mid;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            mid = (left + right) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] == mid)<br>                left = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="剑指-offer-04-二维数组中的查找"><a class="markdownIt-Anchor" href="#剑指-offer-04-二维数组中的查找"></a> <a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">剑指 Offer 04. 二维数组中的查找</a></h3><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p><strong>题解</strong></p><p>参考：<a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/solution/mian-shi-ti-04-er-wei-shu-zu-zhong-de-cha-zhao-zuo/">面试题04. 二维数组中的查找（标志数，清晰图解） - 二维数组中的查找 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p>我们发现此排序矩阵类似二叉搜索树，对于每个元素，其“左分支”元素更小，“右分支”元素更大。</p><p><img src="https://cdn.jsdelivr.net/gh/TBDGF/TBDGF.github.io@master/img/970c/6584ea93812d27112043d203ea90e4b0950117d45e0452d0c630fcb247fbc4af-Picture1.png" alt="Picture1.png" /></p><p>所以我们可以从左下角或右上角开始，按照类似二叉搜索树方式遍历。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">findNumberIn2DArray</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;matrix, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (matrix.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">//这里我们选的从右上角开始遍历</span><br>        <span class="hljs-type">int</span> col = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, row = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> curr;<br>        <span class="hljs-comment">//设置边界条件，防止越界</span><br>        <span class="hljs-keyword">while</span> (col &gt;= <span class="hljs-number">0</span> &amp;&amp; row &lt;= matrix.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) &#123;<br>            curr = matrix[row][col];<br>            <span class="hljs-keyword">if</span> (curr == target)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (target &gt; curr)<br>                row++;<br>            <span class="hljs-keyword">else</span><br>                col--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="剑指-offer-11-旋转数组的最小数字"><a class="markdownIt-Anchor" href="#剑指-offer-11-旋转数组的最小数字"></a> <a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">剑指 Offer 11. 旋转数组的最小数字</a></h3><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。</p><p>给你一个可能存在 重复 元素值的数组 numbers ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一次旋转，该数组的最小值为1。</p><p><strong>题解</strong></p><p>本题为排序数组，所以用二分解。</p><p>二分的中心思想是不断地缩小边界，我们需要考虑各个情况如何缩小边界，最后到达左侧排序序列的右边界。</p><p><strong>首先判断mid落在哪里</strong></p><p>我们默认在到达边界之前，left都应在左序列，而right在右序列</p><ul><li>如果mid落在左排序序列</li></ul><p>此时mid大于等于left，同时也大于等于right。</p><ul><li>如果mid落在右排序序列</li></ul><p>此时mid小于等于left，同时也小于等于right。</p><p>由上可知，只需要单独关注left或者right就行，并且需要区分出相等的情况。在本题解，我们关注right。</p><ul><li>当mid等于right时</li></ul><p>我们只需要让right减小，以缩小边界。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;numbers)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (numbers.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> numbers[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = numbers.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, mid;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            mid = left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (numbers[mid] &lt; numbers[right])<br>                right = mid;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (numbers[mid] &gt; numbers[right])<br>                left = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                right--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> numbers[left];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="剑指-offer-50-第一个只出现一次的字符"><a class="markdownIt-Anchor" href="#剑指-offer-50-第一个只出现一次的字符"></a> <a href="https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/">剑指 Offer 50. 第一个只出现一次的字符</a></h3><p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。</p><p><strong>题解</strong></p><p>首先用map存储字符出现的频次，如果多次出现则置为-1。</p><p>其次我们需要第一个只出现一次的字符，很适合用队列（FIFO）</p><p>在每个字符第一次出现的时候，将其加入队列。</p><p>遍历完频次后，从队列头开始判断，如果value为-1说明多次出现，出队列。</p><p>第一个value为1的元素即是第一个出现一次的元素。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; map;<br>    queue&lt;<span class="hljs-type">char</span>&gt; queue;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">firstUniqChar</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ch:s) &#123;<br>            <span class="hljs-keyword">if</span> (map.<span class="hljs-built_in">count</span>(ch) == <span class="hljs-number">0</span>) &#123;<br>                map[ch] = <span class="hljs-number">1</span>;<br>                queue.<span class="hljs-built_in">push</span>(ch);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                map[ch] = <span class="hljs-number">-1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (!queue.<span class="hljs-built_in">empty</span>() &amp;&amp; map[queue.<span class="hljs-built_in">front</span>()] == <span class="hljs-number">-1</span>)<br>            queue.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span> (queue.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> queue.<span class="hljs-built_in">front</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>剑指Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer Day 26 字符串（中等）</title>
    <link href="/p/177f/"/>
    <url>/p/177f/</url>
    
    <content type="html"><![CDATA[<p>剑指Offer Day 26 字符串（中等）</p><span id="more"></span><h2 id="剑指-offer-20-表示数值的字符串"><a class="markdownIt-Anchor" href="#剑指-offer-20-表示数值的字符串"></a> <a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/">剑指 Offer 20. 表示数值的字符串</a></h2><h3 id="描述"><a class="markdownIt-Anchor" href="#描述"></a> 描述</h3><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。</p><p><strong>数值</strong>（按顺序）可以分成以下几个部分：</p><ol><li>若干空格</li><li>一个 小数 或者 整数</li><li>（可选）一个 ‘e’ 或 ‘E’ ，后面跟着一个 整数</li><li>若干空格</li></ol><p><strong>小数</strong>（按顺序）可以分成以下几个部分：</p><ol><li>（可选）一个符号字符（’+’ 或 ‘-’）</li><li>下述格式之一：<ol><li>至少一位数字，后面跟着一个点 ‘.’</li><li>至少一位数字，后面跟着一个点 ‘.’ ，后面再跟着至少一位数字</li><li>一个点 ‘.’ ，后面跟着至少一位数字</li></ol></li></ol><p><strong>整数</strong>（按顺序）可以分成以下几个部分：</p><ul><li>（可选）一个符号字符（’+’ 或 ‘-’）</li><li>至少一位数字</li></ul><p>部分<strong>数值</strong>列举如下：</p><ul><li>[&quot;+100&quot;, “5e2”, “-123”, “3.1416”, “-1E-16”, “0123”]</li></ul><p>部分<strong>非数值</strong>列举如下：</p><ul><li>[“12e”, “1a3.14”, “1.2.3”, “±5”, “12e+5.4”]</li></ul><p><strong>示例 1</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;0&quot;</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;e&quot;</span><br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>示例 3</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;.&quot;</span><br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>示例 4</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;    .1  &quot;</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>提示</strong></p><ul><li>1 &lt;= s.length &lt;= 20</li><li>s 仅含英文字母（大写和小写），数字（0-9），加号 ‘+’ ，减号 ‘-’ ，空格 ’ ’ 或者点 ‘.’ 。</li></ul><h3 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h3><p>确定有限状态自动机。</p><p>起初，这个自动机处于「初始状态」。随后，它顺序地读取字符串中的每一个字符，并根据当前状态和读入的字符，按照某个事先约定好的「转移规则」，从当前状态转移到下一个状态；当状态转移完成后，它就读取下一个字符。当字符串全部读取完毕后，如果自动机处于某个「接受状态」，则判定该字符串「被接受」；否则，判定该字符串「被拒绝」。</p><p>所有状态：</p><ol><li>起始的空格</li><li>符号位</li><li>整数部分</li><li>左侧有整数的小数点</li><li>左侧无整数的小数点（根据前面的第二条额外规则，需要对左侧有无整数的两种小数点做区分）</li><li>小数部分</li><li>字符 e</li><li>指数部分的符号位</li><li>指数部分的整数部分</li><li>末尾的空格</li></ol><p><img src="https://cdn.jsdelivr.net/gh/TBDGF/TBDGF.github.io@master/img/177f/jianzhi_20_fig1.png" alt="fig1" /></p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">State</span> &#123;<br>        StateInit,<br>        StateSign,<br>        StateInteger,<br>        StatePoint,<br>        StatePointWithoutInt,<br>        StateFraction,<br>        StateExp,<br>        StateExpSign,<br>        StateExpNumber,<br>        StateEnd,<br>    &#125;;<br><br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">CharType</span> &#123;<br>        CharSpace,<br>        CharNumber,<br>        CharSign,<br>        CharExp,<br>        CharPoint,<br>        CharIllegal,<br>    &#125;;<br><br>    <span class="hljs-function">CharType <span class="hljs-title">toCharType</span><span class="hljs-params">(<span class="hljs-type">char</span> ch)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>)<br>            <span class="hljs-keyword">return</span> CharNumber;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27; &#x27;</span>)<br>            <span class="hljs-keyword">return</span> CharSpace;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;-&#x27;</span> || ch == <span class="hljs-string">&#x27;+&#x27;</span>)<br>            <span class="hljs-keyword">return</span> CharSign;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;e&#x27;</span> || ch == <span class="hljs-string">&#x27;E&#x27;</span>)<br>            <span class="hljs-keyword">return</span> CharExp;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;.&#x27;</span>)<br>            <span class="hljs-keyword">return</span> CharPoint;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> CharIllegal;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isNumber</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-comment">//定义状态转移的方式</span><br>        map&lt;State, map&lt;CharType, State&gt;&gt; transfer = &#123;<br>                &#123;StateInit,            &#123;<br>                                                &#123;CharSpace,  StateInit&#125;,<br>                                                &#123;CharNumber, StateInteger&#125;,<br>                                                &#123;CharPoint, StatePointWithoutInt&#125;,<br>                                                &#123;CharSign, StateSign&#125;,<br>                                        &#125;<br>                &#125;,<br>                &#123;StateSign,            &#123;<br>                                                &#123;CharNumber, StateInteger&#125;,<br>                                                &#123;CharPoint,  StatePointWithoutInt&#125;,<br>                                        &#125;<br>                &#125;,<br>                &#123;StateInteger,          &#123;<br>                                                &#123;CharNumber, StateInteger&#125;,<br>                                                &#123;CharSpace,  StateEnd&#125;,<br>                                                &#123;CharPoint, StatePoint&#125;,<br>                                                &#123;CharExp,  StateExp&#125;,<br>                                        &#125;<br>                &#125;,<br>                &#123;StatePoint,            &#123;<br>                                                &#123;CharNumber, StateFraction&#125;,<br>                                                &#123;CharSpace,  StateEnd&#125;,<br>                                                &#123;CharExp,   StateExp&#125;,<br>                                        &#125;<br>                &#125;,<br>                &#123;StatePointWithoutInt, &#123;<br>                                                &#123;CharNumber, StateFraction&#125;,<br>                                        &#125;<br>                &#125;,<br>                &#123;StateFraction,         &#123;<br>                                                &#123;CharNumber, StateFraction&#125;,<br>                                                &#123;CharSpace,  StateEnd&#125;,<br>                                                &#123;CharExp,   StateExp&#125;,<br>                                        &#125;<br>                &#125;,<br>                &#123;StateExp,              &#123;<br>                                                &#123;CharSign,   StateExpSign&#125;,<br>                                                &#123;CharNumber, StateExpNumber&#125;,<br>                                        &#125;<br>                &#125;,<br>                &#123;StateExpSign,          &#123;<br>                                                &#123;CharNumber, StateExpNumber&#125;,<br>                                        &#125;<br>                &#125;,<br>                &#123;StateExpNumber,        &#123;<br>                                                &#123;CharNumber, StateExpNumber&#125;,<br>                                                &#123;CharSpace,  StateEnd&#125;,<br>                                        &#125;<br>                &#125;,<br>                &#123;StateEnd,              &#123;<br>                                                &#123;CharSpace,  StateEnd&#125;,<br>                                        &#125;<br>                &#125;,<br>        &#125;;<br><br>        State state = StateInit;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-comment">//拿到当前遍历到的字符类型</span><br>            CharType charType = <span class="hljs-built_in">toCharType</span>(s[i]);<br>            <span class="hljs-comment">//根据当前类型转移状态</span><br>            <span class="hljs-keyword">if</span> (transfer[state].<span class="hljs-built_in">count</span>(charType) == <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">else</span><br>                state = transfer[state][charType];<br>        &#125;<br>        <span class="hljs-keyword">return</span> state == StateInteger || state == StatePoint || state == StateFraction ||<br>               state == StateExpNumber || state == StateEnd;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="剑指-offer-67-把字符串转换成整数"><a class="markdownIt-Anchor" href="#剑指-offer-67-把字符串转换成整数"></a> <a href="https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/">剑指 Offer 67. 把字符串转换成整数</a></h2><h3 id="描述-2"><a class="markdownIt-Anchor" href="#描述-2"></a> 描述</h3><p>写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。</p><p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p><p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p><p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p><p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p><p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p><p><strong>说明</strong></p><p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−2^31,  2^31 − 1]。如果数值超过这个范围，请返回  INT_MAX (2^31 − 1) 或 INT_MIN (−2^31) 。</p><p><strong>示例 1</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: &quot;42&quot;</span><br><span class="hljs-section">输出: 42</span><br></code></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: &quot;   -42&quot;</span><br><span class="hljs-section">输出: -42</span><br><span class="hljs-section">解释: 第一个非空白字符为 &#x27;-&#x27;, 它是一个负号。</span><br>     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。<br></code></pre></td></tr></table></figure><p><strong>示例 3</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: &quot;4193 with words&quot;</span><br><span class="hljs-section">输出: 4193</span><br><span class="hljs-section">解释: 转换截止于数字 &#x27;3&#x27; ，因为它的下一个字符不为数字。</span><br></code></pre></td></tr></table></figure><p><strong>示例 4</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: &quot;words and 987&quot;</span><br><span class="hljs-section">输出: 0</span><br><span class="hljs-section">解释: 第一个非空字符是 &#x27;w&#x27;, 但它不是数字或正、负号。</span><br>     因此无法执行有效的转换。<br></code></pre></td></tr></table></figure><p><strong>示例 5</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入: &quot;-<span class="hljs-number">91283472332</span>&quot;<br>输出: -<span class="hljs-number">2147483648</span><br>解释: 数字 &quot;-<span class="hljs-number">91283472332</span>&quot; 超过 <span class="hljs-number">32</span> 位有符号整数范围。 <br>     因此返回 INT_MIN (−<span class="hljs-number">231</span>) 。<br></code></pre></td></tr></table></figure><p><strong>注意</strong></p><p>本题与主站 8 题相同：<a href="https://leetcode-cn.com/problems/string-to-integer-atoi/">https://leetcode-cn.com/problems/string-to-integer-atoi/</a></p><h3 id="题解-2"><a class="markdownIt-Anchor" href="#题解-2"></a> 题解</h3><p>确定有限状态自动机。</p><p>所有的状态：</p><ol><li>初始的空格</li><li>符号</li><li>整数</li><li>结束（隐含状态，如果不能满足下面的转移过程，即为结束）</li></ol><pre><code class=" mermaid">graph LRInit--&gt;InitInit--&gt;SignInit--&gt;IntegerSign--&gt;IntegerInteger--&gt;Integer</code></pre><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">State</span> &#123;<br>        StateInit,<br>        StateInteger,<br>        StateSign,<br>    &#125;;<br><br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">CharType</span> &#123;<br>        CharSpace,<br>        CharNumber,<br>        CharSign,<br>        CharIllegal,<br>    &#125;;<br><br>    <span class="hljs-function">CharType <span class="hljs-title">toCharType</span><span class="hljs-params">(<span class="hljs-type">char</span> ch)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>)<br>            <span class="hljs-keyword">return</span> CharNumber;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27; &#x27;</span>)<br>            <span class="hljs-keyword">return</span> CharSpace;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;-&#x27;</span> || ch == <span class="hljs-string">&#x27;+&#x27;</span>)<br>            <span class="hljs-keyword">return</span> CharSign;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> CharIllegal;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">strToInt</span><span class="hljs-params">(string str)</span> </span>&#123;<br>        map&lt;State, map&lt;CharType, State&gt;&gt; transfer&#123;<br>                &#123;StateInit,    &#123;<br>                                       &#123;CharSpace,  StateInit&#125;,<br>                                       &#123;CharSign, StateSign&#125;,<br>                                       &#123;CharNumber, StateInteger&#125;,<br>                               &#125;<br>                &#125;,<br>                &#123;StateSign,    &#123;<br>                                       &#123;CharNumber, StateInteger&#125;,<br>                               &#125;<br>                &#125;,<br>                &#123;StateInteger, &#123;<br>                                       &#123;CharNumber, StateInteger&#125;,<br>                               &#125;<br>                &#125;,<br>        &#125;;<br>        <span class="hljs-comment">//使用 long long 存放答案，避免越界溢出</span><br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//判断是否为正数</span><br>        <span class="hljs-type">bool</span> isPositive = <span class="hljs-literal">true</span>;<br>        State state = StateInit;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            CharType charType = <span class="hljs-built_in">toCharType</span>(str[i]);<br>            <span class="hljs-keyword">if</span> (transfer[state].<span class="hljs-built_in">count</span>(charType) == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">//状态结束，直接返回</span><br>                <span class="hljs-keyword">return</span> isPositive ? ans : -ans;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//状态转移</span><br>                state = transfer[state][charType];<br>            &#125;<br>            <span class="hljs-comment">//如果当前在符号位，判断正负</span><br>            <span class="hljs-keyword">if</span> (state == StateSign &amp;&amp; str[i] == <span class="hljs-string">&#x27;-&#x27;</span>)<br>                isPositive = <span class="hljs-literal">false</span>;<br>            <span class="hljs-comment">//如果在整数位</span><br>            <span class="hljs-keyword">if</span> (state == StateInteger) &#123;<br>                ans = ans * <span class="hljs-number">10</span> + str[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>                <span class="hljs-comment">//根据正负分别判断是否越界</span><br>                <span class="hljs-keyword">if</span> (isPositive)<br>                    ans = ans &gt; INT32_MAX ? INT32_MAX : ans;<br>                <span class="hljs-keyword">else</span><br>                    ans = ans &gt; -(<span class="hljs-type">long</span> <span class="hljs-type">long</span>) INT32_MIN ? -(<span class="hljs-type">long</span> <span class="hljs-type">long</span>) INT32_MIN : ans;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> isPositive ? ans : -ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>剑指Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法</title>
    <link href="/p/ef35/"/>
    <url>/p/ef35/</url>
    
    <content type="html"><![CDATA[<p>排序算法</p><span id="more"></span><p><a href="https://www.cnblogs.com/onepixel/articles/7674659.html">十大经典排序算法（动图演示） - 一像素 - 博客园 (cnblogs.com)</a></p><h2 id="时间空间复杂度"><a class="markdownIt-Anchor" href="#时间空间复杂度"></a> 时间空间复杂度</h2><p><img src="https://cdn.jsdelivr.net/gh/TBDGF/TBDGF.github.io@master/img/ef35/849589-20180402133438219-1946132192.png" alt="img" /></p><h2 id="归并排序"><a class="markdownIt-Anchor" href="#归并排序"></a> 归并排序</h2><h3 id="分而治之"><a class="markdownIt-Anchor" href="#分而治之"></a> 分而治之</h3><p><img src="https://cdn.jsdelivr.net/gh/TBDGF/TBDGF.github.io@master/img/ef35/1024555-20161218163120151-452283750.png" alt="img" /></p><h3 id="合并相邻有序子序列"><a class="markdownIt-Anchor" href="#合并相邻有序子序列"></a> 合并相邻有序子序列</h3><p><img src="https://cdn.jsdelivr.net/gh/TBDGF/TBDGF.github.io@master/img/ef35/1024555-20161218194621308-588010220.png" alt="img" /></p><p><img src="https://cdn.jsdelivr.net/gh/TBDGF/TBDGF.github.io@master/img/ef35/1024555-20161218194508761-468169540.png" alt="img" /></p><p><img src="https://cdn.jsdelivr.net/gh/TBDGF/TBDGF.github.io@master/img/ef35/1024555-20161218194621308-588010221.png" alt="img" /></p><h3 id="c-代码实现"><a class="markdownIt-Anchor" href="#c-代码实现"></a> C++ 代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//辅助数组</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; temp;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mergeSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span> </span>&#123;<br>        <span class="hljs-comment">//为辅助数组重新指定大小</span><br>        temp = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(nums.<span class="hljs-built_in">size</span>());<br>        <span class="hljs-built_in">sort</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-comment">//确定左序列和右序列的开始位置，使用 idx 同步修改辅助数组中的值</span><br>        <span class="hljs-type">int</span> leftIdx = left, rightIdx = mid + <span class="hljs-number">1</span>, idx = left;<br>        <span class="hljs-comment">//合并</span><br>        <span class="hljs-keyword">while</span> (leftIdx &lt;= mid &amp;&amp; rightIdx &lt;= right) &#123;<br>            <span class="hljs-keyword">if</span> (nums[leftIdx] &lt; nums[rightIdx]) &#123;<br>                temp[idx] = nums[leftIdx];<br>                leftIdx++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                temp[idx] = nums[rightIdx];<br>                rightIdx++;<br>            &#125;<br>            idx++;<br>        &#125;<br>        <span class="hljs-comment">//合并两序列中剩余元素</span><br>        <span class="hljs-keyword">while</span> (leftIdx &lt;= mid) &#123;<br>            temp[idx] = nums[leftIdx];<br>            idx++;<br>            leftIdx++;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (rightIdx &lt;= right) &#123;<br>            temp[idx] = nums[rightIdx];<br>            idx++;<br>            rightIdx++;<br>        &#125;<br>        <span class="hljs-comment">//将辅助数组里的内容保存到主数组中</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = left; i &lt;= right; ++i) &#123;<br>            nums[i] = temp[i];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-comment">//如果不满足条件，说明已经不能再分</span><br>        <span class="hljs-keyword">if</span> (left &gt;= right)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">//分</span><br>        <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">sort</span>(nums, left, mid);<br>        <span class="hljs-built_in">sort</span>(nums, mid + <span class="hljs-number">1</span>, right);<br>        <span class="hljs-comment">//治</span><br>        <span class="hljs-built_in">merge</span>(nums, left, mid, right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="快速排序"><a class="markdownIt-Anchor" href="#快速排序"></a> 快速排序</h2><p>通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><h3 id="分割"><a class="markdownIt-Anchor" href="#分割"></a> 分割</h3><p><img src="https://cdn.jsdelivr.net/gh/TBDGF/TBDGF.github.io@master/img/ef35/1024555-20170108162758159-793891242.png" alt="img" /></p><p><img src="https://cdn.jsdelivr.net/gh/TBDGF/TBDGF.github.io@master/img/ef35/1024555-20170108162855675-777137351.png" alt="img" /></p><h3 id="c-代码实现-2"><a class="markdownIt-Anchor" href="#c-代码实现-2"></a> C++ 代码实现</h3><p>对于分割操作，我们从序列最左端取 pivot。并且使用快慢指针法，快速交换左右两序列的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">quickSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span> </span>&#123;<br>        ans = nums;<br>        <span class="hljs-built_in">sort</span>(<span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-type">int</span> idx;<br>        <span class="hljs-keyword">if</span> (left &lt; right) &#123;<br>            <span class="hljs-comment">//分治策略，idx 就像 mid ，在其两边继续分治</span><br>            idx = <span class="hljs-built_in">partition</span>(left, right);<br>            <span class="hljs-built_in">sort</span>(left, idx - <span class="hljs-number">1</span>);<br>            <span class="hljs-built_in">sort</span>(idx + <span class="hljs-number">1</span>, right);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//分割左右序列，将 left 作为 pivot，并返回分割好的位置</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-comment">//随机锚点</span><br>        <span class="hljs-type">int</span> randomIndex = left + <span class="hljs-number">1</span> + <span class="hljs-built_in">rand</span>() % (right - left);<br>        <span class="hljs-built_in">swap</span>(nums[left], nums[randomIndex]);<br>        <br>        <span class="hljs-type">int</span> pivot = left, slow = pivot + <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//快慢指针，slow 指向比 pivot 小的数，fast 指向比 pivot 大的数</span><br>        <span class="hljs-comment">//原理可理解为：slow 和 fast 同时走，但 slow 遇到符合条件的会停下来</span><br>        <span class="hljs-comment">//当 fast 不满足条件时，交换 slow 和 fast</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> fast = slow; fast &lt;= right; ++fast) &#123;<br>            <span class="hljs-keyword">if</span> (ans[fast] &lt; ans[pivot]) &#123;<br>                <span class="hljs-built_in">swap</span>(ans[fast], ans[slow]);<br>                slow++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//最后将 slow 指向的最后一个比 pivot 小的数与 pivot 交换</span><br>        <span class="hljs-comment">//达成 pivot 左边都比他小，右边都比他大的效果</span><br>        <span class="hljs-built_in">swap</span>(ans[pivot], ans[slow - <span class="hljs-number">1</span>]);<br>        <span class="hljs-comment">//返回 pivot 的位置</span><br>        <span class="hljs-keyword">return</span> slow - <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer Day 28 搜索与回溯算法（困难）</title>
    <link href="/p/cf0/"/>
    <url>/p/cf0/</url>
    
    <content type="html"><![CDATA[<p>剑指Offer Day-28 搜索与回溯算法（困难）</p><span id="more"></span><h2 id="剑指-offer-37-序列化二叉树"><a class="markdownIt-Anchor" href="#剑指-offer-37-序列化二叉树"></a> <a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/">剑指 Offer 37. 序列化二叉树</a></h2><h3 id="描述"><a class="markdownIt-Anchor" href="#描述"></a> 描述</h3><p>请实现两个函数，分别用来序列化和反序列化二叉树。</p><p>你需要设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p><p>提示：输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p><p><strong>示例</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><p><strong>注意</strong></p><p>本题与主站 297 题相同：<a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/">https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/</a></p><h3 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h3><p>BFS层序遍历，使用 stringstream 流恢复树。</p><p>层序遍历生成序列，元素之间空格间隔。</p><p>恢复时也用层序遍历。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Codec</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-comment">// Encodes a tree to a single string.</span><br>    <span class="hljs-function">string <span class="hljs-title">serialize</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root)<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        string ans;<br>        queue&lt;TreeNode *&gt; queue;<br>        queue.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!queue.<span class="hljs-built_in">empty</span>()) &#123;<br>            TreeNode *front = queue.<span class="hljs-built_in">front</span>();<br>            <span class="hljs-comment">//空节点，序列化为 #</span><br>            <span class="hljs-keyword">if</span> (!front) &#123;<br>                ans += <span class="hljs-string">&quot;# &quot;</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                queue.<span class="hljs-built_in">push</span>(front-&gt;left);<br>                queue.<span class="hljs-built_in">push</span>(front-&gt;right);<br>                ans += <span class="hljs-built_in">to_string</span>(front-&gt;val) + <span class="hljs-string">&quot; &quot;</span>;<br>            &#125;<br>            queue.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-comment">//序列化后的树以空格为间隔，方便使用 stringstream</span><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-comment">// Decodes your encoded data to tree.</span><br>    <span class="hljs-function">TreeNode *<span class="hljs-title">deserialize</span><span class="hljs-params">(string data)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (data.<span class="hljs-built_in">length</span>() == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-comment">//stringstream 流</span><br>        stringstream stream;<br>        string str;<br>        <span class="hljs-comment">//流读入数据</span><br>        stream &lt;&lt; data;<br>        <span class="hljs-comment">//流读出数据</span><br>        stream &gt;&gt; str;<br>        <span class="hljs-comment">//stoi 将 string 转为 int</span><br>        TreeNode *root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-built_in">stoi</span>(str));<br>        queue&lt;TreeNode *&gt; queue;<br>        queue.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!queue.<span class="hljs-built_in">empty</span>()) &#123;<br>            TreeNode *front = queue.<span class="hljs-built_in">front</span>();<br>            stream &gt;&gt; str;<br>            <span class="hljs-keyword">if</span> (str != <span class="hljs-string">&quot;#&quot;</span>) &#123;<br>                front-&gt;left = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-built_in">stoi</span>(str));<br>                queue.<span class="hljs-built_in">push</span>(front-&gt;left);<br>            &#125;<br>            stream &gt;&gt; str;<br>            <span class="hljs-keyword">if</span> (str != <span class="hljs-string">&quot;#&quot;</span>) &#123;<br>                front-&gt;right = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-built_in">stoi</span>(str));<br>                queue.<span class="hljs-built_in">push</span>(front-&gt;right);<br>            &#125;<br>            queue.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// Your Codec object will be instantiated and called as such:</span><br><span class="hljs-comment">// Codec codec;</span><br><span class="hljs-comment">// codec.deserialize(codec.serialize(root));</span><br></code></pre></td></tr></table></figure><h2 id="剑指-offer-38-字符串的排列"><a class="markdownIt-Anchor" href="#剑指-offer-38-字符串的排列"></a> <a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/">剑指 Offer 38. 字符串的排列</a></h2><p><a href="https://blog.allenji.cn/p/9230/">面试算法题-02 - Allen Ji’s blog</a></p>]]></content>
    
    
    <categories>
      
      <category>剑指Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer Day 27 栈与队列（困难）</title>
    <link href="/p/a0f5/"/>
    <url>/p/a0f5/</url>
    
    <content type="html"><![CDATA[<p>剑指Offer Day 27 栈与队列（困难）</p><span id="more"></span><h2 id="剑指-offer-59-i-滑动窗口的最大值"><a class="markdownIt-Anchor" href="#剑指-offer-59-i-滑动窗口的最大值"></a> <a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/">剑指 Offer 59 - I. 滑动窗口的最大值</a></h2><h3 id="描述"><a class="markdownIt-Anchor" href="#描述"></a> 描述</h3><p>给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。</p><p><strong>示例</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><pre><code class="hljs subunit">输入: nums = [1,3,<span class="hljs-string">-1</span>,<span class="hljs-string">-3</span>,5,3,6,7], 和 k = 3<br>输出: [3,3,5,5,6,7] <br>解释: <br><br>  滑动窗口的位置                最大值<br><br>---------------               -----<br><br>[1  3  <span class="hljs-string">-1</span>] <span class="hljs-string">-3</span>  5  3  6  7       3<br> 1 [3  <span class="hljs-string">-1</span>  <span class="hljs-string">-3</span>] 5  3  6  7       3<br> 1  3 [<span class="hljs-string">-1</span>  <span class="hljs-string">-3</span>  5] 3  6  7       5<br> 1  3  <span class="hljs-string">-1</span> [<span class="hljs-string">-3</span>  5  3] 6  7       5<br> 1  3  <span class="hljs-string">-1</span>  <span class="hljs-string">-3</span> [5  3  6] 7       6<br> 1  3  <span class="hljs-string">-1</span>  <span class="hljs-string">-3</span>  5 [3  6  7]      7<br></code></pre></td></tr></table></figure><p><strong>提示</strong></p><p>你可以假设 k 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。</p><p><strong>注意</strong></p><p>本题与主站 239 题相同：<a href="https://leetcode-cn.com/problems/sliding-window-maximum/">https://leetcode-cn.com/problems/sliding-window-maximum/</a></p><h3 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h3><p>本体使用类似单调栈的思路，维护一个单调结构。</p><p>因为我们需要所有滑动窗口里最大的值，所以维护一个单调递减的队列，这样可以让队首的元素永远是最大的。</p><p>当队首元素出滑动窗口时，注意让其出队。</p><p>本题里我们保存下标。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        deque&lt;<span class="hljs-type">int</span>&gt; deque;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">empty</span>() || k == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> ans;<br>        <span class="hljs-comment">//形成初始窗口</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>            <span class="hljs-keyword">while</span> (!deque.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i] &gt; nums[deque.<span class="hljs-built_in">back</span>()]) &#123;<br>                deque.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>            deque.<span class="hljs-built_in">push_back</span>(i);<br>        &#125;<br>        ans.<span class="hljs-built_in">push_back</span>(nums[deque.<span class="hljs-built_in">front</span>()]);<br>        <span class="hljs-comment">//形成窗口后</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = k; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">if</span> (deque.<span class="hljs-built_in">front</span>() == i - k) &#123;<br>                deque.<span class="hljs-built_in">pop_front</span>();<br>            &#125;<br>            <span class="hljs-keyword">while</span> (!deque.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i] &gt; nums[deque.<span class="hljs-built_in">back</span>()]) &#123;<br>                deque.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>            deque.<span class="hljs-built_in">push_back</span>(i);<br>            ans.<span class="hljs-built_in">push_back</span>(nums[deque.<span class="hljs-built_in">front</span>()]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="剑指-offer-59-ii-队列的最大值"><a class="markdownIt-Anchor" href="#剑指-offer-59-ii-队列的最大值"></a> <a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/">剑指 Offer 59 - II. 队列的最大值</a></h2><h3 id="描述-2"><a class="markdownIt-Anchor" href="#描述-2"></a> 描述</h3><p>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。</p><p>若队列为空，pop_front 和 max_value 需要返回 -1</p><p><strong>示例 1</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入: <br>[<span class="hljs-string">&quot;MaxQueue&quot;</span>,<span class="hljs-string">&quot;push_back&quot;</span>,<span class="hljs-string">&quot;push_back&quot;</span>,<span class="hljs-string">&quot;max_value&quot;</span>,<span class="hljs-string">&quot;pop_front&quot;</span>,<span class="hljs-string">&quot;max_value&quot;</span>]<br>[[],[<span class="hljs-number">1</span>],[<span class="hljs-number">2</span>],[],[],[]]<br>输出: [null,null,null,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入: <br>[<span class="hljs-string">&quot;MaxQueue&quot;</span>,<span class="hljs-string">&quot;pop_front&quot;</span>,<span class="hljs-string">&quot;max_value&quot;</span>]<br>[[],[],[]]<br>输出: [null,<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>]<br></code></pre></td></tr></table></figure><p><strong>限制</strong></p><ul><li>1 &lt;= push_back,pop_front,max_value的总操作数 &lt;= 10000</li><li>1 &lt;= value &lt;= 10^5</li></ul><h3 id="题解-2"><a class="markdownIt-Anchor" href="#题解-2"></a> 题解</h3><p>参考上题，本题可用单调队列。</p><p>额外维护一个递减队列存最大值，当有新的值比队尾大时依次弹出队尾，被它弹出的元素永远比该新值小。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MaxQueue</span> &#123;<br>    deque&lt;<span class="hljs-type">int</span>&gt; deque;<br>    queue&lt;<span class="hljs-type">int</span>&gt; queue;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MaxQueue</span>() &#123;<br>        <span class="hljs-keyword">while</span> (!deque.<span class="hljs-built_in">empty</span>())<br>            deque.<span class="hljs-built_in">pop_back</span>();<br>        <span class="hljs-keyword">while</span> (!queue.<span class="hljs-built_in">empty</span>())<br>            queue.<span class="hljs-built_in">pop</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">max_value</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (queue.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> deque.<span class="hljs-built_in">front</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>        queue.<span class="hljs-built_in">push</span>(value);<br>        <span class="hljs-keyword">while</span> (!deque.<span class="hljs-built_in">empty</span>() &amp;&amp; value &gt; deque.<span class="hljs-built_in">back</span>()) &#123;<br>            deque.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>        deque.<span class="hljs-built_in">push_back</span>(value);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop_front</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (queue.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> front = queue.<span class="hljs-built_in">front</span>();<br>        <span class="hljs-keyword">if</span> (deque.<span class="hljs-built_in">front</span>() == front)<br>            deque.<span class="hljs-built_in">pop_front</span>();<br>        queue.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> front;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MaxQueue object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MaxQueue* obj = new MaxQueue();</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;max_value();</span><br><span class="hljs-comment"> * obj-&gt;push_back(value);</span><br><span class="hljs-comment"> * int param_3 = obj-&gt;pop_front();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>剑指Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL练习题</title>
    <link href="/p/2815/"/>
    <url>/p/2815/</url>
    
    <content type="html"><![CDATA[<p>SQL练习题</p><span id="more"></span><p>转载自：</p><p><a href="https://blog.csdn.net/paul0127/article/details/82529216">经典SQL练习题(MySQL版)_廖致君的博客-CSDN博客_mysql练习</a></p><h2 id="数据表结构"><a class="markdownIt-Anchor" href="#数据表结构"></a> 数据表结构</h2><p><strong>学生表 Student</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> Student(Sid <span class="hljs-type">varchar</span>(<span class="hljs-number">6</span>), Sname <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>), Sage datetime, Ssex <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>));<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Student <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;01&#x27;</span> , <span class="hljs-string">&#x27;赵雷&#x27;</span> , <span class="hljs-string">&#x27;1990-01-01&#x27;</span> , <span class="hljs-string">&#x27;男&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Student <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;02&#x27;</span> , <span class="hljs-string">&#x27;钱电&#x27;</span> , <span class="hljs-string">&#x27;1990-12-21&#x27;</span> , <span class="hljs-string">&#x27;男&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Student <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;03&#x27;</span> , <span class="hljs-string">&#x27;孙风&#x27;</span> , <span class="hljs-string">&#x27;1990-05-20&#x27;</span> , <span class="hljs-string">&#x27;男&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Student <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;04&#x27;</span> , <span class="hljs-string">&#x27;李云&#x27;</span> , <span class="hljs-string">&#x27;1990-08-06&#x27;</span> , <span class="hljs-string">&#x27;男&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Student <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;05&#x27;</span> , <span class="hljs-string">&#x27;周梅&#x27;</span> , <span class="hljs-string">&#x27;1991-12-01&#x27;</span> , <span class="hljs-string">&#x27;女&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Student <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;06&#x27;</span> , <span class="hljs-string">&#x27;吴兰&#x27;</span> , <span class="hljs-string">&#x27;1992-03-01&#x27;</span> , <span class="hljs-string">&#x27;女&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Student <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;07&#x27;</span> , <span class="hljs-string">&#x27;郑竹&#x27;</span> , <span class="hljs-string">&#x27;1989-07-01&#x27;</span> , <span class="hljs-string">&#x27;女&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Student <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;08&#x27;</span> , <span class="hljs-string">&#x27;王菊&#x27;</span> , <span class="hljs-string">&#x27;1990-01-20&#x27;</span> , <span class="hljs-string">&#x27;女&#x27;</span>);<br></code></pre></td></tr></table></figure><p><strong>成绩表 SC</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> SC(Sid <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>), Cid <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>), score <span class="hljs-type">decimal</span>(<span class="hljs-number">18</span>,<span class="hljs-number">1</span>));<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;01&#x27;</span> , <span class="hljs-string">&#x27;01&#x27;</span> , <span class="hljs-number">80</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;01&#x27;</span> , <span class="hljs-string">&#x27;02&#x27;</span> , <span class="hljs-number">90</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;01&#x27;</span> , <span class="hljs-string">&#x27;03&#x27;</span> , <span class="hljs-number">99</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;02&#x27;</span> , <span class="hljs-string">&#x27;01&#x27;</span> , <span class="hljs-number">70</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;02&#x27;</span> , <span class="hljs-string">&#x27;02&#x27;</span> , <span class="hljs-number">60</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;02&#x27;</span> , <span class="hljs-string">&#x27;03&#x27;</span> , <span class="hljs-number">80</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;03&#x27;</span> , <span class="hljs-string">&#x27;01&#x27;</span> , <span class="hljs-number">80</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;03&#x27;</span> , <span class="hljs-string">&#x27;02&#x27;</span> , <span class="hljs-number">80</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;03&#x27;</span> , <span class="hljs-string">&#x27;03&#x27;</span> , <span class="hljs-number">80</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;04&#x27;</span> , <span class="hljs-string">&#x27;01&#x27;</span> , <span class="hljs-number">50</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;04&#x27;</span> , <span class="hljs-string">&#x27;02&#x27;</span> , <span class="hljs-number">30</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;04&#x27;</span> , <span class="hljs-string">&#x27;03&#x27;</span> , <span class="hljs-number">20</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;05&#x27;</span> , <span class="hljs-string">&#x27;01&#x27;</span> , <span class="hljs-number">76</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;05&#x27;</span> , <span class="hljs-string">&#x27;02&#x27;</span> , <span class="hljs-number">87</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;06&#x27;</span> , <span class="hljs-string">&#x27;01&#x27;</span> , <span class="hljs-number">31</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;06&#x27;</span> , <span class="hljs-string">&#x27;03&#x27;</span> , <span class="hljs-number">34</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;07&#x27;</span> , <span class="hljs-string">&#x27;02&#x27;</span> , <span class="hljs-number">89</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;07&#x27;</span> , <span class="hljs-string">&#x27;03&#x27;</span> , <span class="hljs-number">98</span>);<br></code></pre></td></tr></table></figure><p><strong>课程表 Course</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> Course(Cid <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>),Cname <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>),Tid <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>));<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Course <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;01&#x27;</span> , <span class="hljs-string">&#x27;语文&#x27;</span> , <span class="hljs-string">&#x27;02&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Course <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;02&#x27;</span> , <span class="hljs-string">&#x27;数学&#x27;</span> , <span class="hljs-string">&#x27;01&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Course <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;03&#x27;</span> , <span class="hljs-string">&#x27;英语&#x27;</span> , <span class="hljs-string">&#x27;03&#x27;</span>);<br></code></pre></td></tr></table></figure><p><strong>教师表 Teacher</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> Teacher(Tid <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>),Tname <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>));<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Teacher <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;01&#x27;</span> , <span class="hljs-string">&#x27;张三&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Teacher <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;02&#x27;</span> , <span class="hljs-string">&#x27;李四&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Teacher <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;03&#x27;</span> , <span class="hljs-string">&#x27;王五&#x27;</span>);<br></code></pre></td></tr></table></figure><h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2><h3 id="行转列"><a class="markdownIt-Anchor" href="#行转列"></a> 行转列</h3><p>子查询</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select user,<br>       year,<br>       IFNULL((select amount from test t where quarter = 1 and t.year = test.year), 0)            as &#x27;季度1&#x27;,<br>       IFNULL((select ifnull(amount, 0) from test t where quarter = 2 and t.year = test.year), 0) as &#x27;季度2&#x27;,<br>       IFNULL((select ifnull(amount, 0) from test t where quarter = 3 and t.year = test.year), 0) as &#x27;季度3&#x27;,<br>       IFNULL((select ifnull(amount, 0) from test t where quarter = 4 and t.year = test.year), 0) as &#x27;季度4&#x27;<br>from test<br>group by user, year<br></code></pre></td></tr></table></figure><p>sum case when</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select user,<br>       year,<br>       sum(CASE quarter when 1 then amount else 0 end)  &#x27;季度1&#x27;,<br>       sum(CASE quarter when 2 then amount else 0 end)  &#x27;季度2&#x27;,<br>       sum(CASE quarter when 3 then amount else 0 end)  &#x27;季度3&#x27;,<br>       sum(CASE quarter when 4 then amount else 0 end)  &#x27;季度4&#x27;<br>from test<br>group by user, year<br></code></pre></td></tr></table></figure><h3 id="查询-01-课程比-02-课程成绩高的学生的信息及课程分数"><a class="markdownIt-Anchor" href="#查询-01-课程比-02-课程成绩高的学生的信息及课程分数"></a> 查询 “01” 课程比 “02” 课程成绩高的学生的信息及课程分数</h3><p>首先从 student 表选择所有学生信息， sc 表分别选择两个课程的成绩。</p><p>where 语句控制 01 课程比 02 课程成绩高，同时将 select 回来的三个结果连在一起</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> s.<span class="hljs-operator">*</span>, sc_01.score <span class="hljs-keyword">as</span> score_01, sc_01.score <span class="hljs-keyword">as</span> score_02<br><span class="hljs-keyword">from</span> student s,<br>     (<span class="hljs-keyword">select</span> Sid, score <span class="hljs-keyword">from</span> sc <span class="hljs-keyword">where</span> Cid <span class="hljs-operator">=</span> <span class="hljs-number">01</span>) sc_01,<br>     (<span class="hljs-keyword">select</span> Sid, score <span class="hljs-keyword">from</span> sc <span class="hljs-keyword">where</span> Cid <span class="hljs-operator">=</span> <span class="hljs-number">02</span>) sc_02<br><span class="hljs-keyword">where</span> sc_01.Sid <span class="hljs-operator">=</span> sc_02.Sid<br>  <span class="hljs-keyword">and</span> sc_01.score <span class="hljs-operator">&gt;</span> sc_02.score<br>  <span class="hljs-keyword">and</span> s.Sid <span class="hljs-operator">=</span> sc_01.Sid;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">+</span><span class="hljs-comment">------+--------+---------------------+------+----------+----------+</span><br><span class="hljs-operator">|</span> Sid  <span class="hljs-operator">|</span> Sname  <span class="hljs-operator">|</span> Sage                <span class="hljs-operator">|</span> Ssex <span class="hljs-operator">|</span> score_01 <span class="hljs-operator">|</span> score_02 <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------+--------+---------------------+------+----------+----------+</span><br><span class="hljs-operator">|</span> <span class="hljs-number">02</span>   <span class="hljs-operator">|</span> 钱电   <span class="hljs-operator">|</span> <span class="hljs-number">1990</span><span class="hljs-number">-12</span><span class="hljs-number">-21</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-operator">|</span> 男   <span class="hljs-operator">|</span>     <span class="hljs-number">70.0</span> <span class="hljs-operator">|</span>     <span class="hljs-number">60.0</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">04</span>   <span class="hljs-operator">|</span> 李云   <span class="hljs-operator">|</span> <span class="hljs-number">1990</span><span class="hljs-number">-08</span><span class="hljs-number">-06</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-operator">|</span> 男   <span class="hljs-operator">|</span>     <span class="hljs-number">50.0</span> <span class="hljs-operator">|</span>     <span class="hljs-number">30.0</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------+--------+---------------------+------+----------+----------+</span><br><span class="hljs-number">2</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><h3 id="查询平均成绩大于等于60分的同学的学生编号和学生姓名和平均成绩"><a class="markdownIt-Anchor" href="#查询平均成绩大于等于60分的同学的学生编号和学生姓名和平均成绩"></a> 查询平均成绩大于等于60分的同学的学生编号和学生姓名和平均成绩</h3><p>从 student 表和 sc 表选择信息。</p><p>按学生编号分组后，求出 score 的平均值，并筛选。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> s.sid, sname, <span class="hljs-built_in">avg</span>(score) <span class="hljs-keyword">as</span> avg_score<br><span class="hljs-keyword">from</span> student <span class="hljs-keyword">as</span> s,<br>     sc<br><span class="hljs-keyword">where</span> s.sid <span class="hljs-operator">=</span> sc.sid<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> s.sid<br><span class="hljs-keyword">having</span> avg_score <span class="hljs-operator">&gt;</span> <span class="hljs-number">60</span>;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">+</span><span class="hljs-comment">------+--------+-----------+</span><br><span class="hljs-operator">|</span> sid  <span class="hljs-operator">|</span> sname  <span class="hljs-operator">|</span> avg_score <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------+--------+-----------+</span><br><span class="hljs-operator">|</span> <span class="hljs-number">01</span>   <span class="hljs-operator">|</span> 赵雷   <span class="hljs-operator">|</span>  <span class="hljs-number">89.66667</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">02</span>   <span class="hljs-operator">|</span> 钱电   <span class="hljs-operator">|</span>  <span class="hljs-number">70.00000</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">03</span>   <span class="hljs-operator">|</span> 孙风   <span class="hljs-operator">|</span>  <span class="hljs-number">80.00000</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">05</span>   <span class="hljs-operator">|</span> 周梅   <span class="hljs-operator">|</span>  <span class="hljs-number">81.50000</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">07</span>   <span class="hljs-operator">|</span> 郑竹   <span class="hljs-operator">|</span>  <span class="hljs-number">93.50000</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------+--------+-----------+</span><br><span class="hljs-number">5</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><h3 id="查询-sc-表存在成绩的学生信息"><a class="markdownIt-Anchor" href="#查询-sc-表存在成绩的学生信息"></a> 查询 SC 表存在成绩的学生信息</h3><p>查询 student 表。</p><p>筛选条件放在where语句里。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> student s<br><span class="hljs-keyword">where</span> Sid <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> Sid <span class="hljs-keyword">from</span> sc <span class="hljs-keyword">where</span> score <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>)<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">+</span><span class="hljs-comment">------+--------+---------------------+------+</span><br><span class="hljs-operator">|</span> Sid  <span class="hljs-operator">|</span> Sname  <span class="hljs-operator">|</span> Sage                <span class="hljs-operator">|</span> Ssex <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------+--------+---------------------+------+</span><br><span class="hljs-operator">|</span> <span class="hljs-number">01</span>   <span class="hljs-operator">|</span> 赵雷   <span class="hljs-operator">|</span> <span class="hljs-number">1990</span><span class="hljs-number">-01</span><span class="hljs-number">-01</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-operator">|</span> 男   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">02</span>   <span class="hljs-operator">|</span> 钱电   <span class="hljs-operator">|</span> <span class="hljs-number">1990</span><span class="hljs-number">-12</span><span class="hljs-number">-21</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-operator">|</span> 男   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">03</span>   <span class="hljs-operator">|</span> 孙风   <span class="hljs-operator">|</span> <span class="hljs-number">1990</span><span class="hljs-number">-05</span><span class="hljs-number">-20</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-operator">|</span> 男   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">04</span>   <span class="hljs-operator">|</span> 李云   <span class="hljs-operator">|</span> <span class="hljs-number">1990</span><span class="hljs-number">-08</span><span class="hljs-number">-06</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-operator">|</span> 男   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">05</span>   <span class="hljs-operator">|</span> 周梅   <span class="hljs-operator">|</span> <span class="hljs-number">1991</span><span class="hljs-number">-12</span><span class="hljs-number">-01</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-operator">|</span> 女   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">06</span>   <span class="hljs-operator">|</span> 吴兰   <span class="hljs-operator">|</span> <span class="hljs-number">1992</span><span class="hljs-number">-03</span><span class="hljs-number">-01</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-operator">|</span> 女   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">07</span>   <span class="hljs-operator">|</span> 郑竹   <span class="hljs-operator">|</span> <span class="hljs-number">1989</span><span class="hljs-number">-07</span><span class="hljs-number">-01</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-operator">|</span> 女   <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------+--------+---------------------+------+</span><br><span class="hljs-number">7</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><h3 id="查询所有同学的学生编号-学生姓名-选课总数-所有课程的总成绩没成绩的显示为-null"><a class="markdownIt-Anchor" href="#查询所有同学的学生编号-学生姓名-选课总数-所有课程的总成绩没成绩的显示为-null"></a> 查询所有同学的学生编号、学生姓名、选课总数、所有课程的总成绩(没成绩的显示为 null )</h3><p>因为有空值，所以用 join。且因为空值是在 sc 里，让 sc left join student 表。</p><p>同时对学生编号分组，统计每个人的选课总数和总成绩。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> s.Sid, s.Sname, <span class="hljs-built_in">count</span>(Cid) <span class="hljs-keyword">as</span> count_course, <span class="hljs-built_in">sum</span>(score) <span class="hljs-keyword">as</span> sum_score<br><span class="hljs-keyword">from</span> student s<br>         <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> sc <span class="hljs-keyword">on</span> s.Sid <span class="hljs-operator">=</span> sc.Sid<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> s.Sid<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">+</span><span class="hljs-comment">------+--------+--------------+-----------+</span><br><span class="hljs-operator">|</span> sid  <span class="hljs-operator">|</span> sname  <span class="hljs-operator">|</span> 选课总数     <span class="hljs-operator">|</span> 总成绩    <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------+--------+--------------+-----------+</span><br><span class="hljs-operator">|</span> <span class="hljs-number">01</span>   <span class="hljs-operator">|</span> 赵雷   <span class="hljs-operator">|</span>            <span class="hljs-number">3</span> <span class="hljs-operator">|</span>     <span class="hljs-number">269.0</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">02</span>   <span class="hljs-operator">|</span> 钱电   <span class="hljs-operator">|</span>            <span class="hljs-number">3</span> <span class="hljs-operator">|</span>     <span class="hljs-number">210.0</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">03</span>   <span class="hljs-operator">|</span> 孙风   <span class="hljs-operator">|</span>            <span class="hljs-number">3</span> <span class="hljs-operator">|</span>     <span class="hljs-number">240.0</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">04</span>   <span class="hljs-operator">|</span> 李云   <span class="hljs-operator">|</span>            <span class="hljs-number">3</span> <span class="hljs-operator">|</span>     <span class="hljs-number">100.0</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">05</span>   <span class="hljs-operator">|</span> 周梅   <span class="hljs-operator">|</span>            <span class="hljs-number">2</span> <span class="hljs-operator">|</span>     <span class="hljs-number">163.0</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">06</span>   <span class="hljs-operator">|</span> 吴兰   <span class="hljs-operator">|</span>            <span class="hljs-number">2</span> <span class="hljs-operator">|</span>      <span class="hljs-number">65.0</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">07</span>   <span class="hljs-operator">|</span> 郑竹   <span class="hljs-operator">|</span>            <span class="hljs-number">2</span> <span class="hljs-operator">|</span>     <span class="hljs-number">187.0</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">08</span>   <span class="hljs-operator">|</span> 王菊   <span class="hljs-operator">|</span>            <span class="hljs-number">0</span> <span class="hljs-operator">|</span>      <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------+--------+--------------+-----------+</span><br><span class="hljs-number">8</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><h3 id="查带有成绩的学生信息"><a class="markdownIt-Anchor" href="#查带有成绩的学生信息"></a> 查带有成绩的学生信息</h3><p>行转列时，使用 sum(case when … then …)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> s.Sid,<br>       s.Sname,<br>       <span class="hljs-built_in">count</span>(Cid)                                       <span class="hljs-keyword">as</span> count_course,<br>       <span class="hljs-built_in">sum</span>(score)                                       <span class="hljs-keyword">as</span> sum_score,<br>       <span class="hljs-built_in">sum</span>(<span class="hljs-keyword">case</span> <span class="hljs-keyword">when</span> Cid <span class="hljs-operator">=</span> <span class="hljs-number">01</span> <span class="hljs-keyword">then</span> score <span class="hljs-keyword">else</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">end</span>) <span class="hljs-keyword">as</span> score_01,<br>       <span class="hljs-built_in">sum</span>(<span class="hljs-keyword">case</span> <span class="hljs-keyword">when</span> Cid <span class="hljs-operator">=</span> <span class="hljs-number">02</span> <span class="hljs-keyword">then</span> score <span class="hljs-keyword">else</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">end</span>) <span class="hljs-keyword">as</span> score_02,<br>       <span class="hljs-built_in">sum</span>(<span class="hljs-keyword">case</span> <span class="hljs-keyword">when</span> Cid <span class="hljs-operator">=</span> <span class="hljs-number">03</span> <span class="hljs-keyword">then</span> score <span class="hljs-keyword">else</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">end</span>) <span class="hljs-keyword">as</span> score_03<br><span class="hljs-keyword">from</span> student s,<br>     sc<br><span class="hljs-keyword">where</span> s.Sid <span class="hljs-operator">=</span> sc.Sid<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> s.Sid<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">+</span><span class="hljs-comment">------+--------+--------------+-----------+----------+----------+----------+</span><br><span class="hljs-operator">|</span> sid  <span class="hljs-operator">|</span> sname  <span class="hljs-operator">|</span> 选课总数     <span class="hljs-operator">|</span> 总成绩    <span class="hljs-operator">|</span> score_01 <span class="hljs-operator">|</span> score_02 <span class="hljs-operator">|</span> score_03 <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------+--------+--------------+-----------+----------+----------+----------+</span><br><span class="hljs-operator">|</span> <span class="hljs-number">01</span>   <span class="hljs-operator">|</span> 赵雷   <span class="hljs-operator">|</span>            <span class="hljs-number">3</span> <span class="hljs-operator">|</span>     <span class="hljs-number">269.0</span> <span class="hljs-operator">|</span>     <span class="hljs-number">80.0</span> <span class="hljs-operator">|</span>     <span class="hljs-number">90.0</span> <span class="hljs-operator">|</span>     <span class="hljs-number">99.0</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">02</span>   <span class="hljs-operator">|</span> 钱电   <span class="hljs-operator">|</span>            <span class="hljs-number">3</span> <span class="hljs-operator">|</span>     <span class="hljs-number">210.0</span> <span class="hljs-operator">|</span>     <span class="hljs-number">70.0</span> <span class="hljs-operator">|</span>     <span class="hljs-number">60.0</span> <span class="hljs-operator">|</span>     <span class="hljs-number">80.0</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">03</span>   <span class="hljs-operator">|</span> 孙风   <span class="hljs-operator">|</span>            <span class="hljs-number">3</span> <span class="hljs-operator">|</span>     <span class="hljs-number">240.0</span> <span class="hljs-operator">|</span>     <span class="hljs-number">80.0</span> <span class="hljs-operator">|</span>     <span class="hljs-number">80.0</span> <span class="hljs-operator">|</span>     <span class="hljs-number">80.0</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">04</span>   <span class="hljs-operator">|</span> 李云   <span class="hljs-operator">|</span>            <span class="hljs-number">3</span> <span class="hljs-operator">|</span>     <span class="hljs-number">100.0</span> <span class="hljs-operator">|</span>     <span class="hljs-number">50.0</span> <span class="hljs-operator">|</span>     <span class="hljs-number">30.0</span> <span class="hljs-operator">|</span>     <span class="hljs-number">20.0</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">05</span>   <span class="hljs-operator">|</span> 周梅   <span class="hljs-operator">|</span>            <span class="hljs-number">2</span> <span class="hljs-operator">|</span>     <span class="hljs-number">163.0</span> <span class="hljs-operator">|</span>     <span class="hljs-number">76.0</span> <span class="hljs-operator">|</span>     <span class="hljs-number">87.0</span> <span class="hljs-operator">|</span>     <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">06</span>   <span class="hljs-operator">|</span> 吴兰   <span class="hljs-operator">|</span>            <span class="hljs-number">2</span> <span class="hljs-operator">|</span>      <span class="hljs-number">65.0</span> <span class="hljs-operator">|</span>     <span class="hljs-number">31.0</span> <span class="hljs-operator">|</span>     <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span>     <span class="hljs-number">34.0</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">07</span>   <span class="hljs-operator">|</span> 郑竹   <span class="hljs-operator">|</span>            <span class="hljs-number">2</span> <span class="hljs-operator">|</span>     <span class="hljs-number">187.0</span> <span class="hljs-operator">|</span>     <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span>     <span class="hljs-number">89.0</span> <span class="hljs-operator">|</span>     <span class="hljs-number">98.0</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------+--------+--------------+-----------+----------+----------+----------+</span><br><span class="hljs-number">7</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><h3 id="查询李姓老师的数量"><a class="markdownIt-Anchor" href="#查询李姓老师的数量"></a> 查询「李」姓老师的数量</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(Tid)<br><span class="hljs-keyword">from</span> teacher t<br><span class="hljs-keyword">where</span> Tname <span class="hljs-keyword">like</span> &quot;李%&quot;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">+</span><span class="hljs-comment">--------------+</span><br><span class="hljs-operator">|</span> <span class="hljs-built_in">count</span>(tname) <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------------+</span><br><span class="hljs-operator">|</span>            <span class="hljs-number">1</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------------+</span><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><h3 id="查询学过张三老师授课的同学的信息"><a class="markdownIt-Anchor" href="#查询学过张三老师授课的同学的信息"></a> 查询学过「张三」老师授课的同学的信息</h3><p>个人解法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> s.<span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> student s,<br>     teacher t,<br>     sc,<br>     course c<br><span class="hljs-keyword">where</span> sc.Sid <span class="hljs-operator">=</span> s.Sid<br>  <span class="hljs-keyword">and</span> c.Tid <span class="hljs-operator">=</span> t.Tid<br>  <span class="hljs-keyword">and</span> c.Cid <span class="hljs-operator">=</span> sc.Cid<br>  <span class="hljs-keyword">and</span> t.Tname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;张三&#x27;</span><br></code></pre></td></tr></table></figure><p>优质解法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> student<br><span class="hljs-keyword">where</span> sid <span class="hljs-keyword">in</span> (<br>    <span class="hljs-keyword">select</span> sid<br>    <span class="hljs-keyword">from</span> sc,<br>         course,<br>         teacher<br>    <span class="hljs-keyword">where</span> sc.cid <span class="hljs-operator">=</span> course.cid<br>      <span class="hljs-keyword">and</span> course.tid <span class="hljs-operator">=</span> teacher.tid<br>      <span class="hljs-keyword">and</span> tname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;张三&#x27;</span><br>)<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">+</span><span class="hljs-comment">------+--------+---------------------+------+</span><br><span class="hljs-operator">|</span> Sid  <span class="hljs-operator">|</span> Sname  <span class="hljs-operator">|</span> Sage                <span class="hljs-operator">|</span> Ssex <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------+--------+---------------------+------+</span><br><span class="hljs-operator">|</span> <span class="hljs-number">01</span>   <span class="hljs-operator">|</span> 赵雷   <span class="hljs-operator">|</span> <span class="hljs-number">1990</span><span class="hljs-number">-01</span><span class="hljs-number">-01</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-operator">|</span> 男   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">02</span>   <span class="hljs-operator">|</span> 钱电   <span class="hljs-operator">|</span> <span class="hljs-number">1990</span><span class="hljs-number">-12</span><span class="hljs-number">-21</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-operator">|</span> 男   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">03</span>   <span class="hljs-operator">|</span> 孙风   <span class="hljs-operator">|</span> <span class="hljs-number">1990</span><span class="hljs-number">-05</span><span class="hljs-number">-20</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-operator">|</span> 男   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">04</span>   <span class="hljs-operator">|</span> 李云   <span class="hljs-operator">|</span> <span class="hljs-number">1990</span><span class="hljs-number">-08</span><span class="hljs-number">-06</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-operator">|</span> 男   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">05</span>   <span class="hljs-operator">|</span> 周梅   <span class="hljs-operator">|</span> <span class="hljs-number">1991</span><span class="hljs-number">-12</span><span class="hljs-number">-01</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-operator">|</span> 女   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">07</span>   <span class="hljs-operator">|</span> 郑竹   <span class="hljs-operator">|</span> <span class="hljs-number">1989</span><span class="hljs-number">-07</span><span class="hljs-number">-01</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-operator">|</span> 女   <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------+--------+---------------------+------+</span><br><span class="hljs-number">6</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><h3 id="查询没有学全所有课程的同学的信息"><a class="markdownIt-Anchor" href="#查询没有学全所有课程的同学的信息"></a> 查询没有学全所有课程的同学的信息</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> student<br><span class="hljs-keyword">where</span> sid <span class="hljs-keyword">in</span> (<br>    <span class="hljs-keyword">select</span> sid<br>    <span class="hljs-keyword">from</span> sc<br>    <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> sid<br>    <span class="hljs-keyword">having</span> <span class="hljs-built_in">count</span>(sc.Cid) <span class="hljs-operator">&lt;</span> <span class="hljs-number">3</span><br>)<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">+</span><span class="hljs-comment">------+--------+---------------------+------+</span><br><span class="hljs-operator">|</span> Sid  <span class="hljs-operator">|</span> Sname  <span class="hljs-operator">|</span> Sage                <span class="hljs-operator">|</span> Ssex <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------+--------+---------------------+------+</span><br><span class="hljs-operator">|</span> <span class="hljs-number">05</span>   <span class="hljs-operator">|</span> 周梅   <span class="hljs-operator">|</span> <span class="hljs-number">1991</span><span class="hljs-number">-12</span><span class="hljs-number">-01</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-operator">|</span> 女   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">06</span>   <span class="hljs-operator">|</span> 吴兰   <span class="hljs-operator">|</span> <span class="hljs-number">1992</span><span class="hljs-number">-03</span><span class="hljs-number">-01</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-operator">|</span> 女   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">07</span>   <span class="hljs-operator">|</span> 郑竹   <span class="hljs-operator">|</span> <span class="hljs-number">1989</span><span class="hljs-number">-07</span><span class="hljs-number">-01</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-operator">|</span> 女   <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------+--------+---------------------+------+</span><br><span class="hljs-number">3</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><h3 id="查询和-01-号的同学学习的课程完全相同的其他同学的信息"><a class="markdownIt-Anchor" href="#查询和-01-号的同学学习的课程完全相同的其他同学的信息"></a> 查询和 “01” 号的同学学习的课程完全相同的其他同学的信息</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> student<br><span class="hljs-keyword">where</span> sid <span class="hljs-keyword">in</span> (<br>    <span class="hljs-keyword">select</span> sid<br>    <span class="hljs-keyword">from</span> sc<br>    <span class="hljs-keyword">where</span> cid <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> cid <span class="hljs-keyword">from</span> sc <span class="hljs-keyword">where</span> sid <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;01&#x27;</span>)<br>      <span class="hljs-keyword">and</span> sc.Sid <span class="hljs-operator">&lt;&gt;</span> <span class="hljs-string">&#x27;01&#x27;</span><br>    <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> sid<br>    <span class="hljs-keyword">having</span> <span class="hljs-built_in">count</span>(sc.Cid) <span class="hljs-operator">&gt;=</span> <span class="hljs-number">3</span><br>)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">+------+--------+---------------------+------+<br>| Sid  | Sname  | Sage                | Ssex |<br>+------+--------+---------------------+------+<br>| 02   | 钱电   | 1990-12-21 00:00:00 | 男   |<br>| 03   | 孙风   | 1990-05-20 00:00:00 | 男   |<br>| 04   | 李云   | 1990-08-06 00:00:00 | 男   |<br>+------+--------+---------------------+------+<br>3 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h3 id="查询至少有一门课与学号为-01-的同学所学相同的同学的信息"><a class="markdownIt-Anchor" href="#查询至少有一门课与学号为-01-的同学所学相同的同学的信息"></a> 查询至少有一门课与学号为&quot; 01 &quot;的同学所学相同的同学的信息</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select *<br>from Student<br>where Sid in (<br>    select distinct Sid<br>    from SC<br>    where Cid in (<br>        select Cid<br>        from SC<br>        where Sid = &#x27;01&#x27;<br>    )<br>)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">+------+--------+---------------------+------+<br>| Sid  | Sname  | Sage                | Ssex |<br>+------+--------+---------------------+------+<br>| 01   | 赵雷   | 1990-01-01 00:00:00 | 男   |<br>| 02   | 钱电   | 1990-12-21 00:00:00 | 男   |<br>| 03   | 孙风   | 1990-05-20 00:00:00 | 男   |<br>| 04   | 李云   | 1990-08-06 00:00:00 | 男   |<br>| 05   | 周梅   | 1991-12-01 00:00:00 | 女   |<br>| 06   | 吴兰   | 1992-03-01 00:00:00 | 女   |<br>| 07   | 郑竹   | 1989-07-01 00:00:00 | 女   |<br>+------+--------+---------------------+------+<br>7 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>sqss</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[课题设计]校园导航</title>
    <link href="/p/eb1f/"/>
    <url>/p/eb1f/</url>
    
    <content type="html"><![CDATA[<p>本实验目的为构建大学地标导航，采用前后端分离的实现形式。前端使用React框架，后端使用SpringBoot，通过api接口来通信。本文主要介绍后端部分。</p><span id="more"></span><h2 id="概览"><a class="markdownIt-Anchor" href="#概览"></a> 概览</h2><p>网页展示：<a href="http://hbu-navigation.allenji.cn">http://hbu-navigation.allenji.cn</a></p><p>前端代码仓库：<a href="https://github.com/TBDGF/hbu-navigation-frontend">TBDGF/hbu-navigation-frontend (github.com)</a></p><p>后端代码仓库：<a href="https://github.com/TBDGF/hbu-navigation">TBDGF/hbu-navigation (github.com)</a></p><p><img src="https://s2.loli.net/2021/12/10/Q8MuC5oIREadO7T.png" alt="全貌" /></p><p><img src="https://s2.loli.net/2021/12/10/mMNHZkhLp9r2WYT.png" alt="寻路预览" /></p><p><img src="https://s2.loli.net/2021/12/10/g7yYAlMfTBzNUhP.png" alt="带有中间点的寻路" /></p><h2 id="项目结构"><a class="markdownIt-Anchor" href="#项目结构"></a> 项目结构</h2><pre><code class=" mermaid">graph LRsubgraph 前端showGraph(展示图)showPath(展示路径)endsubgraph 后端graphStore(图存储)endgraphStore----&gt;showGraphgraphStore--算法处理--&gt;showPath</code></pre><h2 id="储存结构"><a class="markdownIt-Anchor" href="#储存结构"></a> 储存结构</h2><h3 id="图"><a class="markdownIt-Anchor" href="#图"></a> 图</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Graph</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;Vertex&gt; vertices = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(); <span class="hljs-comment">//邻接表，储存顶点List</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Vertex <span class="hljs-title function_">getVertex</span><span class="hljs-params">(<span class="hljs-type">int</span> Index)</span> &#123;<br>        <span class="hljs-keyword">return</span> vertices.get(Index);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Vertex <span class="hljs-title function_">getVertex</span><span class="hljs-params">(String label)</span> &#123;<br>        <span class="hljs-keyword">for</span> (Vertex vertex : vertices) &#123;<br>            <span class="hljs-keyword">if</span> (vertex.getLabel().equals(label))<br>                <span class="hljs-keyword">return</span> vertex;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Vertex&gt; <span class="hljs-title function_">getVertices</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> vertices;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addVertex</span><span class="hljs-params">(String label, String information, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>        <span class="hljs-keyword">for</span> (Vertex vertex : vertices) &#123;<br>            <span class="hljs-keyword">if</span> (vertex.getLabel().equals(label)) &#123;<br>                System.out.println(<span class="hljs-string">&quot;repeated vertex label&quot;</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>        vertices.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Vertex</span>(label, information, x, y));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addEdge</span><span class="hljs-params">(Vertex source, Vertex target, <span class="hljs-type">int</span> weight)</span> &#123;<br>        source.addEdge(target, weight);<br>        target.addEdge(source, weight);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getVertexIndex</span><span class="hljs-params">(String label)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; vertices.size(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (vertices.get(i).getLabel().equals(label))<br>                <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getVertexIndex</span><span class="hljs-params">(Vertex vertex)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; vertices.size(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (vertices.get(i).equals(vertex))<br>                <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="点"><a class="markdownIt-Anchor" href="#点"></a> 点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Vertex</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;Vertex&gt; &#123;  <span class="hljs-comment">//实现Comparable接口，用于优先队列</span><br>    <br>    <span class="hljs-keyword">private</span> String label;       <span class="hljs-comment">//储存节点的名称</span><br>    <span class="hljs-keyword">private</span> String information; <span class="hljs-comment">//储存节点详细信息</span><br>    <span class="hljs-keyword">private</span> List&lt;Edge&gt; edges;   <span class="hljs-comment">//储存边List</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> distance;       <span class="hljs-comment">//遍历时距起点距离，用于dijkstra算法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> x, y;<span class="hljs-comment">//在图上点的绝对位置，用于可视化</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Vertex</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.label = <span class="hljs-literal">null</span>;<br>        <span class="hljs-built_in">this</span>.information = <span class="hljs-literal">null</span>;<br>        <span class="hljs-built_in">this</span>.edges = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Vertex</span><span class="hljs-params">(String label, String information, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>        <span class="hljs-built_in">this</span>.label = label;<br>        <span class="hljs-built_in">this</span>.information = information;<br>        <span class="hljs-built_in">this</span>.edges = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-built_in">this</span>.x = x;<br>        <span class="hljs-built_in">this</span>.y = y;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addEdge</span><span class="hljs-params">(Vertex target, <span class="hljs-type">int</span> weight)</span> &#123;<br>        <span class="hljs-keyword">for</span> (Edge edge : edges) &#123;<br>            <span class="hljs-keyword">if</span> (edge.getTarget().equals(target)) &#123;<br>                System.out.println(<span class="hljs-string">&quot;repeated edge&quot;</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">this</span>.edges.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Edge</span>(<span class="hljs-built_in">this</span>, target, weight));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Edge <span class="hljs-title function_">getEdge</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.edges.get(index);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Vertex vertex)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.distance == vertex.distance) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.distance &lt; vertex.distance) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="边"><a class="markdownIt-Anchor" href="#边"></a> 边</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Edge</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> String id;      <span class="hljs-comment">//边的id，由起点和终点自动生成</span><br>    <span class="hljs-keyword">private</span> Vertex target;  <span class="hljs-comment">//目标节点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> weight;     <span class="hljs-comment">//权值</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Edge</span><span class="hljs-params">(Vertex target, <span class="hljs-type">int</span> weight)</span> &#123;<br>        <span class="hljs-built_in">this</span>.target = target;<br>        <span class="hljs-built_in">this</span>.weight = weight;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Edge</span><span class="hljs-params">(Vertex source, Vertex target, <span class="hljs-type">int</span> weight)</span> &#123;<br>        <span class="hljs-built_in">this</span>.target = target;<br>        <span class="hljs-built_in">this</span>.weight = weight;<br>        <span class="hljs-built_in">this</span>.id = source.getLabel() + <span class="hljs-string">&quot;-to-&quot;</span> + target.getLabel();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="核心算法"><a class="markdownIt-Anchor" href="#核心算法"></a> 核心算法</h2><h3 id="多源最短路径的寻找"><a class="markdownIt-Anchor" href="#多源最短路径的寻找"></a> 多源最短路径的寻找</h3><p>当然采用的是大名鼎鼎的floyd算法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INF</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) <span class="hljs-number">1e6</span>;<span class="hljs-comment">//设置足够大的常数，表示距离为无穷，即不可到达</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[][] adjMatrix;  <span class="hljs-comment">//用于floyd的邻接矩阵</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">floyd</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">graphSize</span> <span class="hljs-operator">=</span> Graph.getVertices().size();<br>    <span class="hljs-built_in">this</span>.adjMatrix = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[graphSize][graphSize]; <span class="hljs-comment">//初始化邻接矩阵</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; graphSize; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; graphSize; j++) &#123;<br>            <span class="hljs-built_in">this</span>.adjMatrix[i][j] = INF;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; graphSize; i++) &#123;   <span class="hljs-comment">//将以邻接表储存的图储存成临界矩阵的格式</span><br>        <span class="hljs-keyword">if</span> (!Graph.getVertex(i).getEdges().isEmpty()) &#123;<br>            <span class="hljs-keyword">for</span> (Edge edge : Graph.getVertex(i).getEdges()) &#123;<br>                adjMatrix[i][Graph.getVertexIndex(edge.getTarget())] = edge.getWeight();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; graphSize; k++) &#123;   <span class="hljs-comment">//执行floyd算法</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; graphSize; i++) &#123;<br>            <span class="hljs-keyword">if</span> (adjMatrix[i][k] != INF) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; graphSize; j++) &#123;<br>                    <span class="hljs-keyword">if</span> (adjMatrix[i][j] &gt; adjMatrix[i][k] + adjMatrix[k][j])<br>                        adjMatrix[i][j] = adjMatrix[i][k] + adjMatrix[k][j];<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="单源最短路径的寻找"><a class="markdownIt-Anchor" href="#单源最短路径的寻找"></a> 单源最短路径的寻找</h3><p>自然是同样大名鼎鼎的dijkstra算法，并使用优先队列优化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] pre;          <span class="hljs-comment">//记录前驱节点，pre[x]=y，在最短路径上，x的前一个节点是y</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] distance;     <span class="hljs-comment">//记录到起点的距离</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> start)</span> &#123;<br>    pre = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[Graph.getVertices().size()];<br>    distance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[Graph.getVertices().size()];<br>    <span class="hljs-type">boolean</span>[] hasFound = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[Graph.getVertices().size()];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; Graph.getVertices().size(); i++) &#123;<br>        distance[i] = INF;<br>        hasFound[i] = <span class="hljs-literal">false</span>;<br>    &#125;<br>    distance[start] = <span class="hljs-number">0</span>;<br>    PriorityQueue&lt;Vertex&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br>    Graph.getVertex(start).setDistance(distance[start]);<br>    queue.add(Graph.getVertex(start));<br>    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>        <span class="hljs-type">Vertex</span> <span class="hljs-variable">top</span> <span class="hljs-operator">=</span> queue.peek();<br>        queue.poll();<br>        <span class="hljs-keyword">if</span> (hasFound[Graph.getVertexIndex(top)]) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        hasFound[Graph.getVertexIndex(top)] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; top.getEdges().size(); i++) &#123;<br>            <span class="hljs-type">Edge</span> <span class="hljs-variable">edge</span> <span class="hljs-operator">=</span> top.getEdge(i);<br>            <span class="hljs-type">int</span> targetIndex=Graph.getVertexIndex(edge.getTarget());<br>            <span class="hljs-keyword">if</span> (hasFound[targetIndex])<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (distance[targetIndex] &gt; edge.getWeight() + top.getDistance()) &#123;<br>                distance[targetIndex] = edge.getWeight() + top.getDistance();<br>                edge.getTarget().setDistance(distance[targetIndex]);<br>                queue.add(edge.getTarget());<br>                pre[targetIndex] = Graph.getVertexIndex(top);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="含有必经点的路径查找"><a class="markdownIt-Anchor" href="#含有必经点的路径查找"></a> 含有必经点的路径查找</h3><ol><li>将始末点和必经点分开</li><li>将必经点全排列，作为中间路径</li><li>通过floyd便捷求得每一个中间路径的总路程，再将始末点与中间路径的距离求出后，得到最短路程</li><li>由于路径可能经过无关点（即非始末点和必经点），需要用dijkstra求出并保存每个节点之间的路径</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> WebPath <span class="hljs-title function_">getWebPath</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> destination)</span> &#123; <span class="hljs-comment">//调用dijkstra，并保存路径</span><br>    <span class="hljs-built_in">this</span>.dijkstra(start);<br>    webPath = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebPath</span>();<br>    traverseWebPath(start, destination);<br>    System.out.println(<span class="hljs-built_in">this</span>.distance[destination]);<br>    <span class="hljs-keyword">return</span> webPath;<br>&#125;<br><br><span class="hljs-keyword">public</span> List&lt;WebPath&gt; <span class="hljs-title function_">getPaths</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> destination, List&lt;Integer&gt; pass)</span> &#123;<br>    List&lt;WebPath&gt; paths = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-built_in">this</span>.floyd();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">minDistance</span> <span class="hljs-operator">=</span> INF;<br>    List&lt;Integer&gt; minList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    List&lt;List&lt;Integer&gt;&gt; passMatrix = Perm.permList(pass);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; passMatrix.size(); i++) &#123;<br>        List&lt;Integer&gt; passList = passMatrix.get(i);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; passList.size() - <span class="hljs-number">1</span>; j++) &#123;<br>            <span class="hljs-keyword">if</span> (adjMatrix[passList.get(j)][passList.get(j + <span class="hljs-number">1</span>)] != INF) &#123;<br>                cnt += adjMatrix[passList.get(j)][passList.get(j + <span class="hljs-number">1</span>)];<br>            &#125;<br>        &#125;<br>        cnt += adjMatrix[start][passList.get(<span class="hljs-number">0</span>)];<br>        cnt += adjMatrix[passList.get(passList.size() - <span class="hljs-number">1</span>)][destination];<br>        <span class="hljs-keyword">if</span> (minDistance &gt; cnt) &#123;<br>            minDistance = cnt;<br>            minList = passList;<br>        &#125;<br>    &#125;<br>    paths.add(getWebPath(start, minList.get(<span class="hljs-number">0</span>)));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; minList.size() - <span class="hljs-number">1</span>; i++)<br>        paths.add(getWebPath(minList.get(i), minList.get(i + <span class="hljs-number">1</span>)));<br>    paths.add(getWebPath(minList.get(minList.size() - <span class="hljs-number">1</span>), destination));<br>    System.out.println(paths);<br>    <span class="hljs-keyword">return</span> paths;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[mysql]MySQL ubuntu部署</title>
    <link href="/p/6601/"/>
    <url>/p/6601/</url>
    
    <content type="html"><![CDATA[<p>本文将演示如何在ubuntu上部署mysql，创建角色和赋予权限</p><span id="more"></span><h2 id="安装mysql"><a class="markdownIt-Anchor" href="#安装mysql"></a> 安装mysql</h2><p>使用命令行安装mysql</p><figure class="highlight pgsql"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs pgsql">sudo apt-<span class="hljs-keyword">get</span> install mysql-<span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><h2 id="配置mysql"><a class="markdownIt-Anchor" href="#配置mysql"></a> 配置mysql</h2><h3 id="1初始化"><a class="markdownIt-Anchor" href="#1初始化"></a> 1.初始化</h3><p>命令行</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo mysql_secure_installation</span><br></code></pre></td></tr></table></figure><p>配置项如下:</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">VALIDATE PASSWORD COMPONENT can be used <span class="hljs-built_in">to</span> test passwords<br><span class="hljs-keyword">and</span> improve security. It checks <span class="hljs-keyword">the</span> strength <span class="hljs-keyword">of</span> password<br><span class="hljs-keyword">and</span> allows <span class="hljs-keyword">the</span> users <span class="hljs-built_in">to</span> <span class="hljs-built_in">set</span> only those passwords which are<br>secure enough. Would you like <span class="hljs-built_in">to</span> setup VALIDATE PASSWORD component?<br><br>Press y|Y <span class="hljs-keyword">for</span> Yes, <span class="hljs-keyword">any</span> other key <span class="hljs-keyword">for</span> No: y<span class="hljs-comment">//是否开启强密码，避免出现过弱密码，这里选择Y</span><br><br>There are <span class="hljs-literal">three</span> levels <span class="hljs-keyword">of</span> password validation policy:<br><br>LOW    Length &gt;= <span class="hljs-number">8</span><br>MEDIUM Length &gt;= <span class="hljs-number">8</span>, <span class="hljs-keyword">numeric</span>, mixed <span class="hljs-keyword">case</span>, <span class="hljs-keyword">and</span> special <span class="hljs-keyword">characters</span><br>STRONG Length &gt;= <span class="hljs-number">8</span>, <span class="hljs-keyword">numeric</span>, mixed <span class="hljs-keyword">case</span>, special <span class="hljs-keyword">characters</span> <span class="hljs-keyword">and</span> dictionary                  <span class="hljs-built_in">file</span><br><br>Please enter <span class="hljs-number">0</span> = LOW, <span class="hljs-number">1</span> = MEDIUM <span class="hljs-keyword">and</span> <span class="hljs-number">2</span> = STRONG: <span class="hljs-number">1</span><span class="hljs-comment">//选择密码强度，这里选择1</span><br>Please <span class="hljs-built_in">set</span> <span class="hljs-keyword">the</span> password <span class="hljs-keyword">for</span> root here.<br><br>New password: <span class="hljs-comment">//输入密码</span><br><br>Re-enter <span class="hljs-built_in">new</span> password: <span class="hljs-comment">//再次输入密码</span><br><br>Estimated strength <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> password: <span class="hljs-number">100</span> <br>Do you wish <span class="hljs-built_in">to</span> continue <span class="hljs-keyword">with</span> <span class="hljs-keyword">the</span> password provided?(Press y|Y <span class="hljs-keyword">for</span> Yes, <span class="hljs-keyword">any</span> other key <span class="hljs-keyword">for</span> No) : y<span class="hljs-comment">//确认或再次输入其他密码</span><br><br>By default, <span class="hljs-keyword">a</span> MySQL installation has <span class="hljs-keyword">an</span> anonymous user,<br>allowing anyone <span class="hljs-built_in">to</span> <span class="hljs-built_in">log</span> <span class="hljs-keyword">into</span> MySQL <span class="hljs-keyword">without</span> having <span class="hljs-built_in">to</span> have<br><span class="hljs-keyword">a</span> user account created <span class="hljs-keyword">for</span> them. This is intended only <span class="hljs-keyword">for</span><br>testing, <span class="hljs-keyword">and</span> <span class="hljs-built_in">to</span> make <span class="hljs-keyword">the</span> installation go <span class="hljs-keyword">a</span> bit smoother.<br>You should remove them <span class="hljs-keyword">before</span> moving <span class="hljs-keyword">into</span> <span class="hljs-keyword">a</span> production<br>environment.<br><br>Remove anonymous users? (Press y|Y <span class="hljs-keyword">for</span> Yes, <span class="hljs-keyword">any</span> other key <span class="hljs-keyword">for</span> No) : y<span class="hljs-comment">//是否移除匿名用户</span><br>Success.<br><br><br>Normally, root should only be allowed <span class="hljs-built_in">to</span> connect <span class="hljs-built_in">from</span><br><span class="hljs-string">&#x27;localhost&#x27;</span>. This ensures that someone cannot guess <span class="hljs-keyword">at</span><br><span class="hljs-keyword">the</span> root password <span class="hljs-built_in">from</span> <span class="hljs-keyword">the</span> network.<br><br>Disallow root login remotely? (Press y|Y <span class="hljs-keyword">for</span> Yes, <span class="hljs-keyword">any</span> other key <span class="hljs-keyword">for</span> No) : n<span class="hljs-comment">//是否要禁止远程登陆，选择否</span><br><br> ... skipping.<br>By default, MySQL comes <span class="hljs-keyword">with</span> <span class="hljs-keyword">a</span> database named <span class="hljs-string">&#x27;test&#x27;</span> that<br>anyone can access. This is also intended only <span class="hljs-keyword">for</span> testing,<br><span class="hljs-keyword">and</span> should be removed <span class="hljs-keyword">before</span> moving <span class="hljs-keyword">into</span> <span class="hljs-keyword">a</span> production<br>environment.<br><br><br>Remove test database <span class="hljs-keyword">and</span> access <span class="hljs-built_in">to</span> <span class="hljs-keyword">it</span>? (Press y|Y <span class="hljs-keyword">for</span> Yes, <span class="hljs-keyword">any</span> other key <span class="hljs-keyword">for</span> No) : y<span class="hljs-comment">//是否移除初始数据库</span><br> - Dropping test database...<br>Success.<br><br> - Removing privileges <span class="hljs-keyword">on</span> <span class="hljs-title">test</span> <span class="hljs-title">database</span>...<br>Success.<br><br>Reloading <span class="hljs-keyword">the</span> privilege tables will ensure that all changes<br>made so far will take effect immediately.<br><br>Reload privilege tables now? (Press y|Y <span class="hljs-keyword">for</span> Yes, <span class="hljs-keyword">any</span> other key <span class="hljs-keyword">for</span> No) : y<span class="hljs-comment">//是否重载权限</span><br>Success.<br><br>All done! <br></code></pre></td></tr></table></figure><h3 id="2配置用户"><a class="markdownIt-Anchor" href="#2配置用户"></a> 2.配置用户</h3><p>用root进入mysql</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">sudo mysql -uroot -<span class="hljs-selector-tag">p</span><br></code></pre></td></tr></table></figure><p><strong>创建用户</strong></p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">user</span> MyUser@<span class="hljs-string">&#x27;localhost&#x27;</span> identified <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;MyPassword&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>授权（授予所有数据库的所有权限）</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">grant</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">privileges</span> <span class="hljs-keyword">on</span> *.* <span class="hljs-keyword">to</span> MyUser@<span class="hljs-string">&#x27;localhost&#x27;</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>mysql</tag>
      
      <tag>ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[python]爬虫实战-爬取豆瓣小组信息&amp;自动化处理验证码</title>
    <link href="/p/7f16/"/>
    <url>/p/7f16/</url>
    
    <content type="html"><![CDATA[<p>本文会介绍如何编写豆瓣爬虫，及相对应的验证码处理</p><p>本博客不会介绍一些比较基础的信息，需要读者自己学习，比如python的异步库asyncio</p><span id="more"></span><p>写代码好累</p><p>不要靠近编程，会让人不幸</p><p><img src="/img/%5Bpython%5D%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98-%E7%88%AC%E5%8F%96%E8%B1%86%E7%93%A3%E5%B0%8F%E7%BB%84%E4%BF%A1%E6%81%AF&amp;%E8%87%AA%E5%8A%A8%E5%8C%96%E5%A4%84%E7%90%86%E9%AA%8C%E8%AF%81%E7%A0%81/meme-tired.jpg" alt="" /></p><h1 id="第三方库选型"><a class="markdownIt-Anchor" href="#第三方库选型"></a> 第三方库选型</h1><h2 id="web库选型-aiohttp"><a class="markdownIt-Anchor" href="#web库选型-aiohttp"></a> web库选型 - aiohttp</h2><p>aiohttp可以看作requests的异步版本，同时支持客户端和服务端，继承requests简洁、明了的优点同时，又不易阻塞（虽然有时候该阻还是会阻会儿）</p><p><a href="https://docs.aiohttp.org/en/stable/">aiohttp官网</a></p><p>简单实现:</p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> aiohttp<br><span class="hljs-keyword">import</span> asyncio<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiohttp.ClientSession() <span class="hljs-keyword">as</span> session:<br>        <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">&#x27;http://python.org&#x27;</span>) <span class="hljs-keyword">as</span> response:<br><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Status:&quot;</span>, response.status)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Content-type:&quot;</span>, response.headers[<span class="hljs-string">&#x27;content-type&#x27;</span>])<br><br>            html = <span class="hljs-keyword">await</span> response.text()<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Body:&quot;</span>, html[:<span class="hljs-number">15</span>], <span class="hljs-string">&quot;...&quot;</span>)<br><br>loop = asyncio.get_event_loop()<br>loop.run_until_complete(main())<br></code></pre></td></tr></table></figure><p>同时，我们也不会放弃使用requests，可以用它来处理一些简单的中间请求</p><h2 id="html库-beautiful-soup"><a class="markdownIt-Anchor" href="#html库-beautiful-soup"></a> HTML库 - Beautiful Soup</h2><p>Beautiful Soup 是一个可以从HTML或XML文件中提取数据的Python库.它能够通过你喜欢的转换器实现惯用的文档导航,查找,修改文档的方式.Beautiful Soup会帮你节省数小时甚至数天的工作时间.</p><p><a href="https://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/">Beautiful Soup 中文文档 </a></p><p>简单实现:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br><br>soup = BeautifulSoup(html_text, <span class="hljs-string">&#x27;lxml&#x27;</span>)<span class="hljs-comment">#html_text为html字符串</span><br>link_elements = soup.find_all(<span class="hljs-string">&quot;a&quot;</span>)<br><br></code></pre></td></tr></table></figure><h2 id="ocr库-pytesseract"><a class="markdownIt-Anchor" href="#ocr库-pytesseract"></a> OCR库 - pytesseract</h2><p>Tesseract 是一个开源的ocr引擎，可以开箱即用，项目最初由惠普实验室支持，1996年被移植到Windows上，1998年进行了C++化。在2005年Tesseract 由惠普公司宣布开源。2006年到现在，都由Google公司开发。</p><p><a href="https://github.com/tesseract-ocr/tesseract/">仓库地址</a></p><p>pytesseract 则是Tesseract 的python接口库，pytesseract只是接口，我们需在本地单独安装Tesseract</p><p>我们使用pytesseract 库需要借助PIL(Python Image Library)库，该库提供了基本的图像处理功能</p><p>简单实现:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span>  PIL <span class="hljs-keyword">import</span>  Image<br><span class="hljs-keyword">import</span> pytesseract<br><br>img = Image.<span class="hljs-built_in">open</span>(img_path)<br>text = pytesseract.image_to_string(img,lang=<span class="hljs-string">&#x27;eng&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="mysql库-pymysql"><a class="markdownIt-Anchor" href="#mysql库-pymysql"></a> MySQL库 - pymysql</h2><p>PyMySQL 是在 Python3.x 版本中用于连接 MySQL 服务器的一个库，Python2中则使用mysqldb。</p><p><a href="https://www.runoob.com/python3/python3-mysql.html">pymysql-菜鸟教程</a></p><p>简单实现:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br> <br><span class="hljs-keyword">import</span> pymysql<br> <br><span class="hljs-comment"># 打开数据库连接</span><br>db = pymysql.connect(<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-string">&quot;testuser&quot;</span>,<span class="hljs-string">&quot;test123&quot;</span>,<span class="hljs-string">&quot;TESTDB&quot;</span> )<br> <br><span class="hljs-comment"># 使用 cursor() 方法创建一个游标对象 cursor</span><br>cursor = db.cursor()<br> <br><span class="hljs-comment"># 使用 execute()  方法执行 SQL 查询 </span><br>cursor.execute(<span class="hljs-string">&quot;SELECT VERSION()&quot;</span>)<br> <br><span class="hljs-comment"># 使用 fetchone() 方法获取单条数据.</span><br>data = cursor.fetchone()<br> <br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;Database version : %s &quot;</span> % data)<br> <br><span class="hljs-comment"># 关闭数据库连接</span><br>db.close()<br></code></pre></td></tr></table></figure><h2 id="工具库"><a class="markdownIt-Anchor" href="#工具库"></a> 工具库</h2><h3 id="dateutil"><a class="markdownIt-Anchor" href="#dateutil"></a> dateutil</h3><p>一个方便，开箱即用的时间转换库，帮助我们处理时间</p><p><a href="https://pypi.org/project/python-dateutil/">pypi地址</a></p><p>简单实现:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> dateutil.parser <span class="hljs-keyword">import</span> parse<br> <br><span class="hljs-meta">&gt;&gt;&gt; </span>parse(<span class="hljs-string">&quot;2018-10-21&quot;</span>)<br>datetime.datetime(<span class="hljs-number">2018</span>, <span class="hljs-number">10</span>, <span class="hljs-number">21</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br> <br><span class="hljs-meta">&gt;&gt;&gt; </span>parse(<span class="hljs-string">&quot;20181021&quot;</span>)<br>datetime.datetime(<span class="hljs-number">2018</span>, <span class="hljs-number">10</span>, <span class="hljs-number">21</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br> <br><span class="hljs-meta">&gt;&gt;&gt; </span>parse(<span class="hljs-string">&quot;2018/10/21&quot;</span>)<br>datetime.datetime(<span class="hljs-number">2018</span>, <span class="hljs-number">10</span>, <span class="hljs-number">21</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br> <br><span class="hljs-meta">&gt;&gt;&gt; </span>parse(<span class="hljs-string">&quot;10-21&quot;</span>)<br>datetime.datetime(<span class="hljs-number">2018</span>, <span class="hljs-number">10</span>, <span class="hljs-number">21</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br> <br><span class="hljs-meta">&gt;&gt;&gt; </span>parse(<span class="hljs-string">&quot;10/21&quot;</span>)<br>datetime.datetime(<span class="hljs-number">2018</span>, <span class="hljs-number">10</span>, <span class="hljs-number">21</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><h1 id="设计思路"><a class="markdownIt-Anchor" href="#设计思路"></a> 设计思路</h1><h2 id="总流程"><a class="markdownIt-Anchor" href="#总流程"></a> 总流程</h2><pre><code class=" mermaid">graph TB小组的原始积累--&gt;小组列表待添加小组列表--&gt;小组列表小组列表--处理验证码--&gt;遍历小组</code></pre><h2 id="获取信息"><a class="markdownIt-Anchor" href="#获取信息"></a> 获取信息</h2><pre><code class=" mermaid">graph LR获取信息--&gt;获取成功获取信息--&gt;获取失败获取失败--&gt;验证码处理--&gt;流程结束获取成功--&gt;流程结束--循环结构--&gt;获取信息</code></pre><h2 id="验证码处理"><a class="markdownIt-Anchor" href="#验证码处理"></a> 验证码处理</h2><p>由于豆瓣验证码并非可以直接OCR的图片，所以我们需要进行一些处理</p><p>Before:</p><p><img src="/img/%5Bpython%5D%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98-%E7%88%AC%E5%8F%96%E8%B1%86%E7%93%A3%E5%B0%8F%E7%BB%84%E4%BF%A1%E6%81%AF&amp;%E8%87%AA%E5%8A%A8%E5%8C%96%E5%A4%84%E7%90%86%E9%AA%8C%E8%AF%81%E7%A0%81/captcha-before.jpg" alt="captha-before" /></p><p>After:</p><p><img src="/img/%5Bpython%5D%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98-%E7%88%AC%E5%8F%96%E8%B1%86%E7%93%A3%E5%B0%8F%E7%BB%84%E4%BF%A1%E6%81%AF&amp;%E8%87%AA%E5%8A%A8%E5%8C%96%E5%A4%84%E7%90%86%E9%AA%8C%E8%AF%81%E7%A0%81/captcha-after.jpg" alt="captha-after" /></p><pre><code class=" mermaid">graph LR获取验证码图片--&gt;二值化去除背景--&gt;去除噪点--&gt;执行OCR--&gt;模拟提交表单</code></pre><h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1><h2 id="预定义常量"><a class="markdownIt-Anchor" href="#预定义常量"></a> 预定义常量</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 请求头</span><br>headers = &#123;<br>    <span class="hljs-string">&quot;User-Agent&quot;</span>: Secret.USER_AGENT,<br>    <span class="hljs-string">&quot;Cookie&quot;</span>: Secret.COOKIE<br>&#125;<br><br><span class="hljs-comment"># 数据库连接</span><br>conn = pymysql.connect(host=<span class="hljs-string">&quot;localhost&quot;</span>, user=Secret.DB_USER, password=Secret.DB_PASSWORD, database=<span class="hljs-string">&quot;doubantest&quot;</span>, port=<span class="hljs-number">3306</span>,<br>                       charset=<span class="hljs-string">&quot;utf8mb4&quot;</span>)<br>cursor = conn.cursor()<br><br><span class="hljs-comment"># 表单Body</span><br>form = &#123;<br>    <span class="hljs-string">&quot;ck&quot;</span>: <span class="hljs-string">&quot;Un0d&quot;</span>,<br>    <span class="hljs-string">&quot;captcha-solution&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>    <span class="hljs-string">&quot;captcha-id&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>    <span class="hljs-string">&quot;original-url&quot;</span>: <span class="hljs-string">&quot;https://www.douban.com/group/&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="主函数"><a class="markdownIt-Anchor" href="#主函数"></a> 主函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> traceback<br><span class="hljs-keyword">from</span> asyncio <span class="hljs-keyword">import</span> sleep<br><span class="hljs-keyword">import</span> pymysql<br><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br><span class="hljs-keyword">import</span> aiohttp<br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">from</span> dateutil.parser <span class="hljs-keyword">import</span> parse<br><span class="hljs-keyword">from</span> dateutil.relativedelta <span class="hljs-keyword">import</span> relativedelta<br><span class="hljs-keyword">import</span> datetime<br><span class="hljs-keyword">import</span> PostSolution<br><span class="hljs-keyword">import</span> Secret<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiohttp.ClientSession() <span class="hljs-keyword">as</span> session:<br>        group_list = <span class="hljs-keyword">await</span> get_group_id_list()  <span class="hljs-comment"># 从数据库读取小组列表</span><br>        <span class="hljs-comment"># await PostSolution.main()</span><br>        <span class="hljs-keyword">for</span> index, group_id <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(group_list):<br>            <span class="hljs-comment"># if index&lt;=786:</span><br>            <span class="hljs-comment">#     continue</span><br>            member = <span class="hljs-keyword">await</span> get_group_member(session, group_id)  <span class="hljs-comment"># 获取小组人数</span><br>            <span class="hljs-built_in">print</span>(group_id, member)<br>            <span class="hljs-built_in">sum</span> = <span class="hljs-keyword">await</span> get_group_comment(session, group_id)    <span class="hljs-comment"># 获取该小组讨论数</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-built_in">sum</span>)<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">sum</span> &lt;= <span class="hljs-number">100</span>:<br>                <span class="hljs-keyword">await</span> delete_group_list_by_group_id(group_id)   <span class="hljs-comment"># 如果讨论数小于100，则从数据库中删除</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">await</span> insert_group_info(group_id, member, <span class="hljs-built_in">sum</span>)  <span class="hljs-comment"># 将信息插入数据库</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;fetch over&quot;</span>)<br>        <span class="hljs-keyword">await</span> clean_group_info()    <span class="hljs-comment"># 清理无效小组信息</span><br>        <span class="hljs-keyword">await</span> replace_group_ranked()    <span class="hljs-comment"># 对小组排名并存进数据库，减少服务器压力</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    loop = asyncio.get_event_loop()<br>    loop.run_until_complete(main())<br></code></pre></td></tr></table></figure><h3 id="获取小组人数"><a class="markdownIt-Anchor" href="#获取小组人数"></a> 获取小组人数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_group_member</span>(<span class="hljs-params">session, group_id</span>):<br>    url = <span class="hljs-string">&quot;https://www.douban.com/group/&#123;0&#125;/&quot;</span>.<span class="hljs-built_in">format</span>(group_id)<br>    success = <span class="hljs-literal">None</span><br>    is_denied = <span class="hljs-literal">None</span><br>    cnt = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> success <span class="hljs-keyword">or</span> is_denied:  <span class="hljs-comment"># 循环结构</span><br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(url, headers=headers) <span class="hljs-keyword">as</span> response:  <span class="hljs-comment"># 获取网页HTML</span><br>                is_denied = response.url.__str__()[:<span class="hljs-number">33</span>] == <span class="hljs-string">&quot;https://www.douban.com/misc/sorry&quot;</span>  <span class="hljs-comment"># 判断是否被拒绝</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> is_denied:  <span class="hljs-comment"># 如果没有被拒绝，则获取网页元素</span><br>                    text = <span class="hljs-keyword">await</span> response.text()<br>                    soup = BeautifulSoup(text, <span class="hljs-string">&quot;lxml&quot;</span>)<br>                    member_element = soup.select(<br>                        <span class="hljs-string">&quot;#content &gt; div.grid-16-8.clearfix &gt; div.aside &gt; div.mod.side-nav &gt; p:nth-child(1) &gt; a&quot;</span>)<br>                    is_denied = <span class="hljs-built_in">len</span>(member_element) &lt;= <span class="hljs-number">0</span><br>                <span class="hljs-keyword">if</span> is_denied:  <span class="hljs-comment"># 如果被拒绝，则提交验证码，再次循环</span><br>                    <span class="hljs-keyword">await</span> PostSolution.main()<br>                    <span class="hljs-keyword">continue</span><br><br>                text = <span class="hljs-keyword">await</span> response.text()<br>                soup = BeautifulSoup(text, <span class="hljs-string">&quot;lxml&quot;</span>)<br>                member_element = soup.select(  <span class="hljs-comment"># 获取小组人数</span><br>                    <span class="hljs-string">&quot;#content &gt; div.grid-16-8.clearfix &gt; div.aside &gt; div.mod.side-nav &gt; p:nth-child(1) &gt; a&quot;</span>)<br><br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(member_element) &lt;= <span class="hljs-number">0</span>:  <span class="hljs-comment"># 如果没获取到人数，计数重复3次，如果失败则返回-1</span><br>                    cnt += <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">if</span> cnt &lt;= <span class="hljs-number">3</span>:<br>                        <span class="hljs-keyword">await</span> sleep(<span class="hljs-number">0.5</span>)<br>                    <span class="hljs-keyword">else</span>:<br>                        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    member_text = member_element[<span class="hljs-number">0</span>].get_text()<br>                    <span class="hljs-keyword">return</span> <span class="hljs-built_in">eval</span>(member_text[member_text.index(<span class="hljs-string">&quot;(&quot;</span>) + <span class="hljs-number">1</span>:-<span class="hljs-number">1</span>]) <span class="hljs-comment"># 返回小组人数</span><br>        <span class="hljs-keyword">except</span>:<br>            success = <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><h3 id="获取小组讨论"><a class="markdownIt-Anchor" href="#获取小组讨论"></a> 获取小组讨论</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_group_comment</span>(<span class="hljs-params">session, group_id</span>):<br>    success = <span class="hljs-literal">None</span><br>    is_denied = <span class="hljs-literal">None</span><br>    next_start = <span class="hljs-number">0</span><br>    comment_sum = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> success <span class="hljs-keyword">or</span> is_denied: <span class="hljs-comment"># 循环结构</span><br>        url = <span class="hljs-string">&quot;https://www.douban.com/group/&#123;0&#125;/discussion?start=&#123;1&#125;&quot;</span>.<span class="hljs-built_in">format</span>(group_id, next_start)<br>        <span class="hljs-keyword">await</span> sleep(<span class="hljs-number">0.5</span>)<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(url, headers=headers) <span class="hljs-keyword">as</span> response: <span class="hljs-comment"># 获取网页HTML</span><br>                is_denied = response.url.__str__()[:<span class="hljs-number">33</span>] == <span class="hljs-string">&quot;https://www.douban.com/misc/sorry&quot;</span>  <span class="hljs-comment"># 判断是否被拒绝</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> is_denied:   <span class="hljs-comment"># 如果没有被拒绝，则获取网页元素</span><br>                    text = <span class="hljs-keyword">await</span> response.text()<br>                    soup = BeautifulSoup(text, <span class="hljs-string">&quot;lxml&quot;</span>)<br>                    comment_elements = soup.find_all(<span class="hljs-string">&quot;td&quot;</span>, attrs=&#123;<span class="hljs-string">&quot;class&quot;</span>: <span class="hljs-string">&quot;r-count&quot;</span>&#125;)[<span class="hljs-number">1</span>:]<br>                    time_elements = soup.find_all(<span class="hljs-string">&quot;td&quot;</span>, attrs=&#123;<span class="hljs-string">&quot;class&quot;</span>: <span class="hljs-string">&quot;time&quot;</span>&#125;)<br>                    is_denied = <span class="hljs-built_in">len</span>(comment_elements) &lt;= <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">len</span>(time_elements) &lt;= <span class="hljs-number">0</span><br>                <span class="hljs-keyword">if</span> is_denied:   <span class="hljs-comment"># 如果被拒绝，则提交验证码，再次循环</span><br>                    <span class="hljs-keyword">await</span> PostSolution.main()<br>                    <span class="hljs-keyword">continue</span><br><br>                over_time = <span class="hljs-literal">False</span><br>                <span class="hljs-keyword">for</span> index, comment <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(comment_elements):  <span class="hljs-comment"># 判断评论是否过期并计数</span><br>                    time = parse(time_elements[index].get_text())<br>                    NOW = datetime.datetime.now()<br>                    text = comment.get_text()<br>                    <span class="hljs-keyword">if</span> time &gt; NOW + relativedelta(weeks=-<span class="hljs-number">1</span>):<br>                        <span class="hljs-keyword">if</span> text.isdigit():<br>                            num = <span class="hljs-built_in">eval</span>(text <span class="hljs-keyword">if</span> text != <span class="hljs-string">&quot;&quot;</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;1&quot;</span>)<br>                            comment_sum += num <span class="hljs-keyword">if</span> num &lt;= <span class="hljs-number">1000</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br>                    <span class="hljs-keyword">else</span>:<br>                        over_time = <span class="hljs-literal">True</span><br>                <span class="hljs-built_in">print</span>(next_start)<br><br>                <span class="hljs-comment"># 获取下一页地址</span><br>                next_start_element = soup.select(<span class="hljs-string">&quot;#content &gt; div &gt; div.article &gt; div.paginator &gt; span.next &gt; a&quot;</span>)<br>                is_end = <span class="hljs-built_in">len</span>(next_start_element) &lt;= <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> over_time<br><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> is_end:  <span class="hljs-comment"># 判断是否还有下一页，如果没有，结束循环</span><br>                next_start = next_start_element[<span class="hljs-number">0</span>].get(<span class="hljs-string">&#x27;href&#x27;</span>)<br>                next_start = next_start[next_start.index(<span class="hljs-string">&quot;=&quot;</span>) + <span class="hljs-number">1</span>:]<br>            <span class="hljs-keyword">else</span>:<br>                success = <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">except</span>:<br>            success = <span class="hljs-literal">None</span><br><br>    <span class="hljs-keyword">return</span> comment_sum<br></code></pre></td></tr></table></figure><h2 id="发送验证码"><a class="markdownIt-Anchor" href="#发送验证码"></a> 发送验证码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br><span class="hljs-keyword">import</span> aiohttp<br><span class="hljs-keyword">import</span> asyncio<br><br><span class="hljs-keyword">import</span> ImageOCR<br><span class="hljs-keyword">import</span> Secret<br><br>headers = &#123;<br>    <span class="hljs-string">&quot;User-Agent&quot;</span>: Secret.USER_AGENT,<br>    <span class="hljs-string">&quot;Cookie&quot;</span>: Secret.COOKIE,<br>    <span class="hljs-string">&quot;Host&quot;</span>: <span class="hljs-string">&quot;www.douban.com&quot;</span>,<br>    <span class="hljs-string">&quot;Origin&quot;</span>: <span class="hljs-string">&quot;https://www.douban.com&quot;</span>,<br>    <span class="hljs-string">&quot;Referer&quot;</span>: <span class="hljs-string">&quot;https://www.douban.com/misc/sorry?original-url=https://www.douban.com/group/&quot;</span>,<br>    <span class="hljs-string">&quot;Content-Type&quot;</span>: <span class="hljs-string">&quot;application/x-www-form-urlencoded&quot;</span><br>&#125;<br><br>form = &#123;<br>    <span class="hljs-string">&quot;ck&quot;</span>: <span class="hljs-string">&quot;Un0d&quot;</span>,<br>    <span class="hljs-string">&quot;captcha-solution&quot;</span>: <span class="hljs-string">&quot;money&quot;</span>,<br>    <span class="hljs-string">&quot;captcha-id&quot;</span>: <span class="hljs-string">&quot;iLO5m9Y0xdMKXkSzW8ML5Tqr:en&quot;</span>,<br>    <span class="hljs-string">&quot;original-url&quot;</span>: <span class="hljs-string">&quot;https://www.douban.com/group/&quot;</span><br>&#125;<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-params">session</span>):<br>    url = <span class="hljs-string">&quot;https://www.douban.com/misc/sorry&quot;</span><br>    is_access = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> is_access: <span class="hljs-comment"># 循环，上一次的结果在下一次循环时提交</span><br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.post(url, headers=headers, data=form) <span class="hljs-keyword">as</span> response:<br><br>                <span class="hljs-keyword">if</span> response.url.__str__()[:<span class="hljs-number">33</span>] != <span class="hljs-string">&quot;https://www.douban.com/misc/sorry&quot;</span>:<br>                    is_access = <span class="hljs-literal">True</span><br><br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> is_access:<br>                    text = <span class="hljs-keyword">await</span> response.text()<br>                    soup = BeautifulSoup(text, <span class="hljs-string">&quot;lxml&quot;</span>)<br>                    img_elements = soup.find_all(<span class="hljs-string">&quot;img&quot;</span>)<br>                    img_src = img_elements[<span class="hljs-number">0</span>].get(<span class="hljs-string">&#x27;src&#x27;</span>) <span class="hljs-comment"># 获取图片地址</span><br>                    img_id = img_src[<span class="hljs-number">39</span>:]   <span class="hljs-comment"># 获取图片id</span><br><br>                    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;list/captcha.jfif&quot;</span>, <span class="hljs-string">&#x27;wb+&#x27;</span>) <span class="hljs-keyword">as</span> f: <span class="hljs-comment"># 保存图片到本地</span><br>                        res = requests.get(img_src, headers=headers)<br>                        f.write(res.content)<br>                        f.close()<br>                    img = ImageOCR.Img()    <span class="hljs-comment"># 执行OCR</span><br>                    solution = img.deocr()<br><br>                form[<span class="hljs-string">&#x27;captcha-solution&#x27;</span>] = solution<br>                form[<span class="hljs-string">&#x27;captcha-id&#x27;</span>] = img_id<br>                <span class="hljs-built_in">print</span>(form)<br>        <span class="hljs-keyword">except</span>:<br>            is_access = <span class="hljs-literal">None</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;access&quot;</span>)<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiohttp.ClientSession() <span class="hljs-keyword">as</span> session:<br>        <span class="hljs-keyword">await</span> fetch(session)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    loop = asyncio.get_event_loop()<br>    loop.run_until_complete(main())<br><br></code></pre></td></tr></table></figure><h2 id="ocr"><a class="markdownIt-Anchor" href="#ocr"></a> OCR</h2><p>懒得写了现在，有时间再补吧</p>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>爬虫</tag>
      
      <tag>OCR</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[tampermonkey]Edge油猴插件安装教程</title>
    <link href="/p/51a9/"/>
    <url>/p/51a9/</url>
    
    <content type="html"><![CDATA[<p>本文旨在帮助读者进行油猴插件的安装，由于Edge平台没有需要翻墙的阻碍，所以我们选择他进行介绍</p><span id="more"></span><h2 id="从应用商店安装油猴"><a class="markdownIt-Anchor" href="#从应用商店安装油猴"></a> 从应用商店安装油猴</h2><p>使用最新版的Edge浏览器</p><p>打开<a href="https://microsoftedge.microsoft.com/addons/detail/tampermonkey/iikmkjmpaadaobahmlepeloendndfphd?source=sfw">Tampermonkey - Microsoft Edge Addons</a>，并进行安装</p><p>![](/img/[tampermonkey] Edge油猴插件安装教程/image-20210808173309417.png)</p><p>安装成功后，应该可以从右上角看到插件的图标</p><p>![](/img/[tampermonkey] Edge油猴插件安装教程/image-20210808173555488.png)</p><h2 id="从脚本网站加载脚本"><a class="markdownIt-Anchor" href="#从脚本网站加载脚本"></a> 从脚本网站加载脚本</h2><h3 id="greasyfork"><a class="markdownIt-Anchor" href="#greasyfork"></a> GreasyFork</h3><p><strong>通过链接打开</strong></p><p><a href="https://greasyfork.org/zh-CN">Greasy Fork - 安全、实用的用户脚本大全</a></p><p><strong>通过油猴插件打开</strong></p><p>点击插件，选择&quot;获取新脚本&quot;</p><p>![](/img/[tampermonkey] Edge油猴插件安装教程/image-20210808174148253.png)</p><p>然后在下面找到并点选GreasyFork链接</p><p>![](/img/[tampermonkey] Edge油猴插件安装教程/image-20210808174315114.png)</p><p>搜索自己需要的插件即可</p><h3 id="找脚本"><a class="markdownIt-Anchor" href="#找脚本"></a> 找脚本</h3><p><strong>通过链接打开</strong></p><p><a href="https://www.zhaojiaoben.cn/">找脚本——找任何你需要的脚本 (zhaojiaoben.cn)</a></p><p>搜索自己需要的插件即可</p><h2 id="安装脚本"><a class="markdownIt-Anchor" href="#安装脚本"></a> 安装脚本</h2><p>上面两个脚本网站安装脚本时都会弹出新界面，点击安装即可</p><p><strong>我们以刷课脚本为例</strong></p><p>打开<a href="https://www.zhaojiaoben.cn/">找脚本——找任何你需要的脚本 (zhaojiaoben.cn)</a></p><p>首页就有该脚本，点击直接安装</p><p>![](/img/[tampermonkey] Edge油猴插件安装教程/image-20210808175933672.png)</p><p>然后在弹出的界面选择安装即可</p><h2 id="管理脚本"><a class="markdownIt-Anchor" href="#管理脚本"></a> 管理脚本</h2><p>当脚本安装后，到可用网页会自动生效，油猴插件图标会自动亮起</p><p>![](/img/[tampermonkey] Edge油猴插件安装教程/image-20210808174913530.png)</p><p>我们点击插件后，可以管理当前页面生效的脚本，也可以点击&quot;管理面板&quot;管理所有脚本</p><p>![](/img/[tampermonkey] Edge油猴插件安装教程/image-20210808174955539.png)</p>]]></content>
    
    
    
    <tags>
      
      <tag>实用</tag>
      
      <tag>Tampermonkey</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[nginx]Nginx ubuntu部署</title>
    <link href="/p/740/"/>
    <url>/p/740/</url>
    
    <content type="html"><![CDATA[<p>本文将演示如何在ubuntu上部署nginx，并实现对以 <a href="http://rank.allenji.cn">rank.allenji.cn</a> 为例的前后端分发和 https部署</p><span id="more"></span><h2 id="安装nginx"><a class="markdownIt-Anchor" href="#安装nginx"></a> 安装nginx</h2><p>使用命令行安装nginx</p><figure class="highlight cmake"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs cmake">sudo apt <span class="hljs-keyword">install</span> nginx<br></code></pre></td></tr></table></figure><h2 id="配置nginx"><a class="markdownIt-Anchor" href="#配置nginx"></a> 配置nginx</h2><p><strong>进入目录</strong></p><p>进入nginx默认安装目录: /etc/nginx</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd <span class="hljs-regexp">/etc/</span>nginx<br></code></pre></td></tr></table></figure><p><img src="/img/image-20210807132620388.png" alt="image-20210807132620388" /></p><p>这时打开“nginx.conf&quot;</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">sudo <span class="hljs-keyword">vim</span> nginx.<span class="hljs-keyword">conf</span><br></code></pre></td></tr></table></figure><p>文档内容如下:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">user</span> www-data;<br><span class="hljs-attribute">worker_processes</span> auto;<br><span class="hljs-attribute">pid</span> /run/nginx.pid;<br><span class="hljs-attribute">include</span> /etc/nginx/modules-enabled/<span class="hljs-regexp">*.conf</span>;<br><br><span class="hljs-section">events</span> &#123;<br>        <span class="hljs-attribute">worker_connections</span> <span class="hljs-number">768</span>;<br>        <span class="hljs-comment"># multi_accept on;</span><br>&#125;<br><br><span class="hljs-section">http</span> &#123;<br><br>        <span class="hljs-comment">##</span><br>        <span class="hljs-comment"># Basic Settings</span><br>        <span class="hljs-comment">##</span><br><br>        <span class="hljs-attribute">sendfile</span> <span class="hljs-literal">on</span>;<br>        <span class="hljs-attribute">tcp_nopush</span> <span class="hljs-literal">on</span>;<br>        <span class="hljs-attribute">tcp_nodelay</span> <span class="hljs-literal">on</span>;<br>        <span class="hljs-attribute">keepalive_timeout</span> <span class="hljs-number">65</span>;<br>        <span class="hljs-attribute">types_hash_max_size</span> <span class="hljs-number">2048</span>;<br>        <span class="hljs-comment"># server_tokens off;</span><br><br>        <span class="hljs-comment"># server_names_hash_bucket_size 64;</span><br>        <span class="hljs-attribute">include</span> /etc/nginx/mime.types;<br>        <span class="hljs-attribute">default_type</span> application/octet-stream;<br><br>        <span class="hljs-comment">##</span><br><br>        <span class="hljs-attribute">ssl_protocols</span> TLSv1 TLSv1.<span class="hljs-number">1</span> TLSv1.<span class="hljs-number">2</span> TLSv1.<span class="hljs-number">3</span>; <span class="hljs-comment"># Dropping SSLv3, ref: POODLE</span><br>        <span class="hljs-attribute">ssl_prefer_server_ciphers</span> <span class="hljs-literal">on</span>;<br><br>        <span class="hljs-comment">##</span><br>        <span class="hljs-comment"># Logging Settings</span><br>        <span class="hljs-comment">##</span><br><br>        <span class="hljs-attribute">access_log</span> /var/log/nginx/access.log;<br>        <span class="hljs-attribute">error_log</span> /var/log/nginx/<span class="hljs-literal">error</span>.log;<br><br>        <span class="hljs-comment">##</span><br>        <span class="hljs-comment"># Gzip Settings</span><br>        <span class="hljs-comment">##</span><br><br>        <span class="hljs-attribute">gzip</span> <span class="hljs-literal">on</span>;<br><br>        <span class="hljs-comment"># gzip_vary on;</span><br>        <span class="hljs-comment"># gzip_proxied any;</span><br>        <span class="hljs-comment"># gzip_comp_level 6;</span><br>        <span class="hljs-comment"># gzip_buffers 16 8k;</span><br>        <span class="hljs-comment"># gzip_http_version 1.1;</span><br><br>        <span class="hljs-comment">##</span><br>        <span class="hljs-comment"># Virtual Host Configs</span><br>        <span class="hljs-comment">##</span><br><br>        <span class="hljs-attribute">include</span> /etc/nginx/conf.d/<span class="hljs-regexp">*.conf</span>;<br>        <span class="hljs-attribute">include</span> /etc/nginx/sites-enabled/*;<br>&#125;<br><br><br><span class="hljs-comment">#mail &#123;</span><br><span class="hljs-comment">#       # See sample authentication script at:</span><br><span class="hljs-comment">#       # http://wiki.nginx.org/ImapAuthenticateWithApachePhpScript</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#       # auth_http localhost/auth.php;</span><br><span class="hljs-comment">#       # pop3_capabilities &quot;TOP&quot; &quot;USER&quot;;</span><br><span class="hljs-comment">#       # imap_capabilities &quot;IMAP4rev1&quot; &quot;UIDPLUS&quot;;</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#       server &#123;</span><br><span class="hljs-comment">#               listen     localhost:110;</span><br><span class="hljs-comment">#               protocol   pop3;</span><br><span class="hljs-comment">#               proxy      on;</span><br><span class="hljs-comment">#       &#125;</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#       server &#123;</span><br><span class="hljs-comment">#               listen     localhost:143;</span><br><span class="hljs-comment">#               protocol   imap;</span><br><span class="hljs-comment">#               proxy      on;</span><br><span class="hljs-comment">#       &#125;</span><br><span class="hljs-comment">#&#125;</span><br></code></pre></td></tr></table></figure><p>由</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">include</span> <span class="hljs-regexp">/etc/</span>nginx<span class="hljs-regexp">/conf.d/</span>*.conf;<br><span class="hljs-keyword">include</span> <span class="hljs-regexp">/etc/</span>nginx<span class="hljs-regexp">/sites-enabled/</span>*;<br></code></pre></td></tr></table></figure><p>这两行可知，配置文件定义在这两个文件夹里</p><p><strong>进入次级目录</strong></p><p>为了方便管理，我们进入&quot;site-enabled&quot;目录并分站点定义配置文件</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">cd</span> sites-enabled<br>sudo touch rank.<span class="hljs-keyword">conf</span><br>sudo <span class="hljs-keyword">vim</span> rank.<span class="hljs-keyword">conf</span><br></code></pre></td></tr></table></figure><p>我们将rank.conf写成这样</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br><span class="hljs-attribute">listen</span> <span class="hljs-number">443</span> ssl;<span class="hljs-comment">#听ssl端口</span><br><span class="hljs-attribute">server_name</span> rank.allenji.cn;<span class="hljs-comment">#站点名</span><br><span class="hljs-attribute">root</span> /home/wwwroot/rank;<span class="hljs-comment">#站点静态单页地址</span><br><span class="hljs-section">location</span> / &#123;<br><span class="hljs-attribute">index</span> index.html;<span class="hljs-comment">#站点单页的index.html</span><br>&#125;<br><span class="hljs-section">location</span> /api/ &#123;<br><span class="hljs-attribute">proxy_pass</span> https://localhost:8080; <span class="hljs-comment">#将/api的请求转发到后端接口</span><br>&#125;<br><br><br><span class="hljs-comment">#ssl配置 请参考各大服务器运营商的ssl部署教程</span><br><br><span class="hljs-attribute">ssl_certificate</span> ssl/1_rank.allenji.cn_bundle.crt;<br><span class="hljs-attribute">ssl_certificate_key</span> ssl/2_rank.allenji.cn.key;<br><span class="hljs-attribute">ssl_session_timeout</span> <span class="hljs-number">5m</span>;<br><span class="hljs-attribute">ssl_protocols</span> TLSv1 TLSv1.<span class="hljs-number">1</span> TLSv1.<span class="hljs-number">2</span>;<br><span class="hljs-attribute">ssl_ciphers</span> ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;<br><span class="hljs-attribute">ssl_prefer_server_ciphers</span> <span class="hljs-literal">on</span>;<br><br>&#125;<br><br><span class="hljs-section">server</span> &#123;<span class="hljs-comment">#强制将http访问的请求转发到https</span><br><span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;<br><span class="hljs-attribute">server_name</span> rank.allenji.cn;<br><span class="hljs-attribute">return</span> <span class="hljs-number">301</span> https://<span class="hljs-variable">$host</span><span class="hljs-variable">$request_uri</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>如上，站点的conf就配置完毕了</p><p><strong>重载配置文件</strong></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo nginx -s reload</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>ubuntu</tag>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[cpp]单调栈</title>
    <link href="/p/7ebb/"/>
    <url>/p/7ebb/</url>
    
    <content type="html"><![CDATA[<p><strong>何为单调栈？</strong><br />顾名思义，就是单调的栈，我们维护一个栈，栈中的元素保持非严格单调递增或递减。</p><span id="more"></span><p>此算法在处理一些问题时莫名其妙（雾）的有效，是一个典型的空间换时间的算法。</p><h2 id="1-最大的矩形-csp201312-3-leetcode-84"><a class="markdownIt-Anchor" href="#1-最大的矩形-csp201312-3-leetcode-84"></a> 1. 最大的矩形 [CSP]201312-3 / [LeetCode] 84.</h2><p>问题描述<br />在横轴上放了n个相邻的矩形，每个矩形的宽度是1，而第i（1 ≤ i ≤ n）个矩形的高度是hi。这n个矩形构成了一个直方图。例如，下图中六个矩形的高度就分别是3, 1, 6, 5, 2, 3。<br /><img src="https://img-blog.csdnimg.cn/2020121717482394.png" alt="" /></p><p>请找出能放在给定直方图里面积最大的矩形，它的边要与坐标轴平行。对于上面给出的例子，最大矩形如下图所示的阴影部分，面积是10。<br /><img src="https://img-blog.csdnimg.cn/20201217174844858.png" alt="" /></p><p><strong>输入格式</strong><br />第一行包含一个整数n，即矩形的数量(1 ≤ n ≤ 1000)。<br />第二行包含n 个整数h1, h2, … , hn，相邻的数之间由空格分隔。(1 ≤ hi ≤ 10000)。hi是第i个矩形的高度。<br />　　<br /><strong>输出格式</strong><br />输出一行，包含一个整数，即给定直方图内的最大矩形的面积。<br />　　<br /><strong>样例输入</strong><br />6<br />3 1 6 5 2 3</p><p><strong>样例输出</strong><br />10</p><p><strong>题解</strong><br />我们可以维持一个单调递增的栈，为了便于计算矩形宽度，我们在栈里存放单个矩形的位置。<br />我们从左到右遍历高度数组，对于每个矩形的高度p，如果p大于等于当前栈顶储存位置的高度q，我们将p的位置也压入栈中；<br />如果p小于q，我们将q弹出，纪录高度，并记录当前遍历到的矩形p与新栈顶位置之差(实际上还需要减1)，作为宽度，并更新结果。<br />为避免栈中剩余矩形，我们可以在数组尾插入一个高度为零的矩形，使栈中所有矩形弹出并更新。</p><p><strong>代码实现</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; heights)</span> </span>&#123;<br>heights.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<span class="hljs-comment">//插入空矩形，弹出栈中剩余矩形</span><br><span class="hljs-type">int</span> len = heights.<span class="hljs-built_in">size</span>(), area = <span class="hljs-number">0</span>, pre_index, height, width;<br>stack&lt;<span class="hljs-type">int</span>&gt; indices;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br><span class="hljs-keyword">while</span> (!indices.<span class="hljs-built_in">empty</span>() &amp;&amp; heights[indices.<span class="hljs-built_in">top</span>()] &gt; heights[i]) &#123;<span class="hljs-comment">//检查栈是否为空</span><br>pre_index = indices.<span class="hljs-built_in">top</span>();<span class="hljs-comment">//储存栈顶矩形的位置</span><br>indices.<span class="hljs-built_in">pop</span>();<br>height = heights[pre_index];<span class="hljs-comment">//储存高度</span><br><span class="hljs-keyword">if</span> (indices.<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-comment">//避免操作空栈</span><br>width = i;<span class="hljs-comment">//若弹出至栈为空，因栈的递增性，边界可向左延伸至0</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>width = i - indices.<span class="hljs-built_in">top</span>() - <span class="hljs-number">1</span>;<span class="hljs-comment">//储存宽度</span><br>&#125;<br>area = area &gt; (width * height) ? area : (width * height);<span class="hljs-comment">//更新结果</span><br>&#125;<br>indices.<span class="hljs-built_in">push</span>(i);<br>&#125;<br><span class="hljs-keyword">return</span> area;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2每日温度-leetcode-739"><a class="markdownIt-Anchor" href="#2每日温度-leetcode-739"></a> 2.每日温度 [LeetCode] 739.</h2><p><strong>问题描述</strong></p><p>请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。<br />例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。<br />提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。</p><p><strong>题解</strong></p><p>我们在这里维持一个单调递减的栈，为了便于计算天数差，我们在栈中储存位置(即日期)。<br />此题相较上题简单一些，故不在此赘述。<br /><strong>注意：</strong><br />此题与上题不同的是，若栈中有剩余的日期，说明此后没有更暖和的日期，故无需再弹出。</p><p><strong>代码实现</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dailyTemperatures</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; T)</span> </span>&#123;<br><span class="hljs-type">int</span> n = T.<span class="hljs-built_in">size</span>(), pre_index;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n)</span></span>;<br>stack&lt;<span class="hljs-type">int</span>&gt; indices;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br><span class="hljs-keyword">while</span> (!indices.<span class="hljs-built_in">empty</span>() &amp;&amp; T[indices.<span class="hljs-built_in">top</span>()] &lt; T[i]) &#123;<br>pre_index = indices.<span class="hljs-built_in">top</span>();<br>indices.<span class="hljs-built_in">pop</span>();<br>ans[pre_index] = i - pre_index;<span class="hljs-comment">//计算日期差</span><br>&#125;<br>indices.<span class="hljs-built_in">push</span>(i);<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[cpp]gcd&amp;lcm</title>
    <link href="/p/c73b/"/>
    <url>/p/c73b/</url>
    
    <content type="html"><![CDATA[<p>写了一万年这俩算法，还是记不住，这次强化记忆一下</p><span id="more"></span><h2 id="gcd"><a class="markdownIt-Anchor" href="#gcd"></a> GCD</h2><h3 id="基础循环"><a class="markdownIt-Anchor" href="#基础循环"></a> 基础循环</h3><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br><span class="hljs-type">int</span> r;<br>    <span class="hljs-keyword">while</span>(b&gt;<span class="hljs-number">0</span>) &#123;<br>        r=a%b;<br>        a=b;<br>        b=r;<br>    &#125;<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="位运算"><a class="markdownIt-Anchor" href="#位运算"></a> 位运算</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (b^=a^=b^=a%=b);  <span class="hljs-comment">//a%=b,swap(a,b)</span><br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="gcd库函数"><a class="markdownIt-Anchor" href="#gcd库函数"></a> gcd库函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span> </span>&#123;<br><span class="hljs-keyword">return</span> __gcd(a,b);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="lcm"><a class="markdownIt-Anchor" href="#lcm"></a> LCM</h2><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>∗</mo><mi>b</mi><mo>=</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>l</mi><mi>c</mi><mi>m</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a*b = gcd(a,b) * lcm(a,b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">c</span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lcm</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br><span class="hljs-keyword">return</span> a*b/<span class="hljs-built_in">gcd</span>(a,b);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
