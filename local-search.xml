<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>剑指Offer Day-28 搜索与回溯算法（困难）</title>
    <link href="/p/cf0/"/>
    <url>/p/cf0/</url>
    
    <content type="html"><![CDATA[<p>剑指Offer Day-28 搜索与回溯算法（困难）</p><span id="more"></span><h2 id="剑指-offer-37-序列化二叉树"><a class="markdownIt-Anchor" href="#剑指-offer-37-序列化二叉树"></a> <a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/">剑指 Offer 37. 序列化二叉树</a></h2><h3 id="描述"><a class="markdownIt-Anchor" href="#描述"></a> 描述</h3><p>请实现两个函数，分别用来序列化和反序列化二叉树。</p><p>你需要设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p><p>提示：输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p><p><strong>示例</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><p><strong>注意</strong></p><p>本题与主站 297 题相同：<a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/">https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/</a></p><h3 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h3><p>BFS层序遍历，使用 stringstream 流恢复树。</p><p>层序遍历生成序列，元素之间空格间隔。</p><p>恢复时也用层序遍历。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Codec</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-comment">// Encodes a tree to a single string.</span><br>    <span class="hljs-function">string <span class="hljs-title">serialize</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root)<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        string ans;<br>        queue&lt;TreeNode *&gt; queue;<br>        queue.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!queue.<span class="hljs-built_in">empty</span>()) &#123;<br>            TreeNode *front = queue.<span class="hljs-built_in">front</span>();<br>            <span class="hljs-comment">//空节点，序列化为 #</span><br>            <span class="hljs-keyword">if</span> (!front) &#123;<br>                ans += <span class="hljs-string">&quot;# &quot;</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                queue.<span class="hljs-built_in">push</span>(front-&gt;left);<br>                queue.<span class="hljs-built_in">push</span>(front-&gt;right);<br>                ans += <span class="hljs-built_in">to_string</span>(front-&gt;val) + <span class="hljs-string">&quot; &quot;</span>;<br>            &#125;<br>            queue.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-comment">//序列化后的树以空格为间隔，方便使用 stringstream</span><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-comment">// Decodes your encoded data to tree.</span><br>    <span class="hljs-function">TreeNode *<span class="hljs-title">deserialize</span><span class="hljs-params">(string data)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (data.<span class="hljs-built_in">length</span>() == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-comment">//stringstream 流</span><br>        stringstream stream;<br>        string str;<br>        <span class="hljs-comment">//流读入数据</span><br>        stream &lt;&lt; data;<br>        <span class="hljs-comment">//流读出数据</span><br>        stream &gt;&gt; str;<br>        <span class="hljs-comment">//stoi 将 string 转为 int</span><br>        TreeNode *root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-built_in">stoi</span>(str));<br>        queue&lt;TreeNode *&gt; queue;<br>        queue.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!queue.<span class="hljs-built_in">empty</span>()) &#123;<br>            TreeNode *front = queue.<span class="hljs-built_in">front</span>();<br>            stream &gt;&gt; str;<br>            <span class="hljs-keyword">if</span> (str != <span class="hljs-string">&quot;#&quot;</span>) &#123;<br>                front-&gt;left = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-built_in">stoi</span>(str));<br>                queue.<span class="hljs-built_in">push</span>(front-&gt;left);<br>            &#125;<br>            stream &gt;&gt; str;<br>            <span class="hljs-keyword">if</span> (str != <span class="hljs-string">&quot;#&quot;</span>) &#123;<br>                front-&gt;right = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-built_in">stoi</span>(str));<br>                queue.<span class="hljs-built_in">push</span>(front-&gt;right);<br>            &#125;<br>            queue.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// Your Codec object will be instantiated and called as such:</span><br><span class="hljs-comment">// Codec codec;</span><br><span class="hljs-comment">// codec.deserialize(codec.serialize(root));</span><br></code></pre></td></tr></table></figure><h2 id="剑指-offer-38-字符串的排列"><a class="markdownIt-Anchor" href="#剑指-offer-38-字符串的排列"></a> <a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/">剑指 Offer 38. 字符串的排列</a></h2><p><a href="https://blog.allenji.cn/p/9230/">面试算法题-02 - Allen Ji’s blog</a></p>]]></content>
    
    
    <categories>
      
      <category>剑指Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer Day-09 动态规划（中等）</title>
    <link href="/p/8fea/"/>
    <url>/p/8fea/</url>
    
    <content type="html"><![CDATA[<p>剑指Offer Day-09 动态规划（中等）</p><span id="more"></span><h2 id="剑指-offer-42-连续子数组的最大和"><a class="markdownIt-Anchor" href="#剑指-offer-42-连续子数组的最大和"></a> <a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/">剑指 Offer 42. 连续子数组的最大和</a></h2><h3 id="描述"><a class="markdownIt-Anchor" href="#描述"></a> 描述</h3><p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p><p>要求时间复杂度为O(n)。</p><p><strong>示例1</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入: nums = [<span class="hljs-string">-2</span>,1,<span class="hljs-string">-3</span>,4,<span class="hljs-string">-1</span>,2,1,<span class="hljs-string">-5</span>,4]<br>输出: 6<br>解释: 连续子数组 [4,<span class="hljs-string">-1</span>,2,1] 的和最大，为 6。<br></code></pre></td></tr></table></figure><p><strong>提示</strong></p><ul><li>1 &lt;= arr.length &lt;= 10^5</li><li>-100 &lt;= arr[i] &lt;= 100</li></ul><p><strong>注意</strong></p><p>本题与主站 53 题相同：<a href="https://leetcode-cn.com/problems/maximum-subarray/">https://leetcode-cn.com/problems/maximum-subarray/</a></p><h3 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h3><p>动态规划。</p><p>dp数组存到每个位置为止的最大子列和。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">dp[i] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>] + nums[i], nums[i]);<br></code></pre></td></tr></table></figure><p>将前一位的最大子列和与本位相加</p><ul><li>如果小于本位，则说明本位可另起最大子列。</li><li>如果大于本位，则本位储存该结果，表示到该位为止的最大子列和</li></ul><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;nums)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size())</span></span>;<br>        <span class="hljs-keyword">int</span> ans = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-comment">//边界判断</span><br>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;<br>                dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">//递推关系，比较本位和本位加上前一位的最大子列和，得出本位的最大子列和</span><br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>] + nums[i], nums[i]);<br>            <span class="hljs-comment">//储存结果</span><br>            <span class="hljs-keyword">if</span> (dp[i] &gt; ans)<br>                ans = dp[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="剑指-offer-47-礼物的最大价值"><a class="markdownIt-Anchor" href="#剑指-offer-47-礼物的最大价值"></a> <a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/">剑指 Offer 47. 礼物的最大价值</a></h2><h3 id="描述-2"><a class="markdownIt-Anchor" href="#描述-2"></a> 描述</h3><p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p><p><strong>示例 1</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: <br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,3,1]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,5,1]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[4,2,1]</span></span><br><span class="hljs-comment">]</span><br>输出: 12<br>解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物<br></code></pre></td></tr></table></figure><p><strong>提示</strong></p><ul><li>0 &lt; grid.length &lt;= 200</li><li>0 &lt; grid[0].length &lt;= 200</li></ul><h3 id="题解-2"><a class="markdownIt-Anchor" href="#题解-2"></a> 题解</h3><p>动态规划。</p><p>二维dp，dp矩阵的每个值储存到该位置为止，拿到的最大价值。</p><p>因为每个位置可从上边或者左边拿，所以比较两个位置的最大值，再加上本位的价值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]) + grid[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure><p>可以用新数组，最左列和最上列初始化为0，可省略边界判断。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxValue</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; &amp;grid)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(grid.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//初始化，避免边界判断</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; dp.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            dp[i] = vector&lt;<span class="hljs-keyword">int</span>&gt;(grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; dp.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; dp[i].<span class="hljs-built_in">size</span>(); ++j) &#123;<br>                <span class="hljs-comment">//递推关系，从左和上两个方向选出最大值，加上本位价值，得出到本位的最大价值</span><br>                dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]) + grid[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                <span class="hljs-comment">//保存结果</span><br>                ans = <span class="hljs-built_in">max</span>(dp[i][j], ans);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>剑指Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer Day-27 栈与队列（困难）</title>
    <link href="/p/a0f5/"/>
    <url>/p/a0f5/</url>
    
    <content type="html"><![CDATA[<p>剑指Offer Day-27 栈与队列（困难）</p><span id="more"></span><h2 id="剑指-offer-59-i-滑动窗口的最大值"><a class="markdownIt-Anchor" href="#剑指-offer-59-i-滑动窗口的最大值"></a> <a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/">剑指 Offer 59 - I. 滑动窗口的最大值</a></h2><h3 id="描述"><a class="markdownIt-Anchor" href="#描述"></a> 描述</h3><p>给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。</p><p><strong>示例</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入: nums = [1,3,<span class="hljs-string">-1</span>,<span class="hljs-string">-3</span>,5,3,6,7], 和 k = 3<br>输出: [3,3,5,5,6,7] <br>解释: <br><br>  滑动窗口的位置                最大值<br><br>---------------               -----<br><br>[1  3  <span class="hljs-string">-1</span>] <span class="hljs-string">-3</span>  5  3  6  7       3<br> 1 [3  <span class="hljs-string">-1</span>  <span class="hljs-string">-3</span>] 5  3  6  7       3<br> 1  3 [<span class="hljs-string">-1</span>  <span class="hljs-string">-3</span>  5] 3  6  7       5<br> 1  3  <span class="hljs-string">-1</span> [<span class="hljs-string">-3</span>  5  3] 6  7       5<br> 1  3  <span class="hljs-string">-1</span>  <span class="hljs-string">-3</span> [5  3  6] 7       6<br> 1  3  <span class="hljs-string">-1</span>  <span class="hljs-string">-3</span>  5 [3  6  7]      7<br></code></pre></td></tr></table></figure><p><strong>提示</strong></p><p>你可以假设 k 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。</p><p><strong>注意</strong></p><p>本题与主站 239 题相同：<a href="https://leetcode-cn.com/problems/sliding-window-maximum/">https://leetcode-cn.com/problems/sliding-window-maximum/</a></p><h3 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h3><p>本体使用类似单调栈的思路，维护一个单调结构。</p><p>因为我们需要所有滑动窗口里最大的值，所以维护一个单调递减的队列，这样可以让队首的元素永远是最大的。</p><p>当队首元素出滑动窗口时，注意让其出队。</p><p>本题里我们保存下标。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        deque&lt;<span class="hljs-keyword">int</span>&gt; deque;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; ans;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">empty</span>() || k == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> ans;<br>        <span class="hljs-comment">//形成初始窗口</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>            <span class="hljs-keyword">while</span> (!deque.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i] &gt; nums[deque.<span class="hljs-built_in">back</span>()]) &#123;<br>                deque.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>            deque.<span class="hljs-built_in">push_back</span>(i);<br>        &#125;<br>        ans.<span class="hljs-built_in">push_back</span>(nums[deque.<span class="hljs-built_in">front</span>()]);<br>        <span class="hljs-comment">//形成窗口后</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = k; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">if</span> (deque.<span class="hljs-built_in">front</span>() == i - k) &#123;<br>                deque.<span class="hljs-built_in">pop_front</span>();<br>            &#125;<br>            <span class="hljs-keyword">while</span> (!deque.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i] &gt; nums[deque.<span class="hljs-built_in">back</span>()]) &#123;<br>                deque.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>            deque.<span class="hljs-built_in">push_back</span>(i);<br>            ans.<span class="hljs-built_in">push_back</span>(nums[deque.<span class="hljs-built_in">front</span>()]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="剑指-offer-59-ii-队列的最大值"><a class="markdownIt-Anchor" href="#剑指-offer-59-ii-队列的最大值"></a> <a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/">剑指 Offer 59 - II. 队列的最大值</a></h2><h3 id="描述-2"><a class="markdownIt-Anchor" href="#描述-2"></a> 描述</h3><p>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。</p><p>若队列为空，pop_front 和 max_value 需要返回 -1</p><p><strong>示例 1</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入: <br>[<span class="hljs-string">&quot;MaxQueue&quot;</span>,<span class="hljs-string">&quot;push_back&quot;</span>,<span class="hljs-string">&quot;push_back&quot;</span>,<span class="hljs-string">&quot;max_value&quot;</span>,<span class="hljs-string">&quot;pop_front&quot;</span>,<span class="hljs-string">&quot;max_value&quot;</span>]<br>[[],[<span class="hljs-number">1</span>],[<span class="hljs-number">2</span>],[],[],[]]<br>输出: [null,null,null,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入: <br>[<span class="hljs-string">&quot;MaxQueue&quot;</span>,<span class="hljs-string">&quot;pop_front&quot;</span>,<span class="hljs-string">&quot;max_value&quot;</span>]<br>[[],[],[]]<br>输出: [null,<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>]<br></code></pre></td></tr></table></figure><p><strong>限制</strong></p><ul><li>1 &lt;= push_back,pop_front,max_value的总操作数 &lt;= 10000</li><li>1 &lt;= value &lt;= 10^5</li></ul><h3 id="题解-2"><a class="markdownIt-Anchor" href="#题解-2"></a> 题解</h3><p>参考上题，本题可用单调队列。</p><p>额外维护一个递减队列存最大值，当有新的值比队尾大时依次弹出队尾，被它弹出的元素永远比该新值小。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MaxQueue</span> &#123;</span><br>    deque&lt;<span class="hljs-keyword">int</span>&gt; deque;<br>    queue&lt;<span class="hljs-keyword">int</span>&gt; queue;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MaxQueue</span>() &#123;<br>        <span class="hljs-keyword">while</span> (!deque.<span class="hljs-built_in">empty</span>())<br>            deque.<span class="hljs-built_in">pop_back</span>();<br>        <span class="hljs-keyword">while</span> (!queue.<span class="hljs-built_in">empty</span>())<br>            queue.<span class="hljs-built_in">pop</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">max_value</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (queue.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> deque.<span class="hljs-built_in">front</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        queue.<span class="hljs-built_in">push</span>(value);<br>        <span class="hljs-keyword">while</span> (!deque.<span class="hljs-built_in">empty</span>() &amp;&amp; value &gt; deque.<span class="hljs-built_in">back</span>()) &#123;<br>            deque.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>        deque.<span class="hljs-built_in">push_back</span>(value);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pop_front</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (queue.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">int</span> front = queue.<span class="hljs-built_in">front</span>();<br>        <span class="hljs-keyword">if</span> (deque.<span class="hljs-built_in">front</span>() == front)<br>            deque.<span class="hljs-built_in">pop_front</span>();<br>        queue.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> front;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MaxQueue object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MaxQueue* obj = new MaxQueue();</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;max_value();</span><br><span class="hljs-comment"> * obj-&gt;push_back(value);</span><br><span class="hljs-comment"> * int param_3 = obj-&gt;pop_front();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>剑指Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer Day-08 动态规划（简单）</title>
    <link href="/p/11fd/"/>
    <url>/p/11fd/</url>
    
    <content type="html"><![CDATA[<p>剑指Offer Day-08 动态规划（简单）</p><span id="more"></span><h2 id="剑指-offer-10-i-斐波那契数列"><a class="markdownIt-Anchor" href="#剑指-offer-10-i-斐波那契数列"></a> <a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">剑指 Offer 10- I. 斐波那契数列</a></h2><h3 id="描述"><a class="markdownIt-Anchor" href="#描述"></a> 描述</h3><p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">F</span>(<span class="hljs-number">0</span>) = <span class="hljs-number">0</span>,   F(<span class="hljs-number">1</span>) = <span class="hljs-number">1</span><br><span class="hljs-attribute">F</span>(N) = F(N - <span class="hljs-number">1</span>) + F(N - <span class="hljs-number">2</span>), 其中 N &gt; <span class="hljs-number">1</span>.<br></code></pre></td></tr></table></figure><p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p><strong>示例 1</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">5</span><br>输出：<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p><strong>提示</strong></p><ul><li>0 &lt;= n &lt;= 100</li></ul><h3 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h3><p>普通的递归会超时，因为有很多的重复计算，需要优化。</p><p>在这里我们使用动态规划。</p><p>维护一个滑动窗口，根据前两个值直接计算出第三个值。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-keyword">int</span> first = <span class="hljs-number">0</span>, second = <span class="hljs-number">0</span>, third = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i) &#123;<br>            first = second;<br>            second = third;<br>            third = (first + second) % MOD;<br>        &#125;<br>        <span class="hljs-keyword">return</span> third;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="剑指-offer-10-ii-青蛙跳台阶问题"><a class="markdownIt-Anchor" href="#剑指-offer-10-ii-青蛙跳台阶问题"></a> <a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/">剑指 Offer 10- II. 青蛙跳台阶问题</a></h2><h3 id="描述-2"><a class="markdownIt-Anchor" href="#描述-2"></a> 描述</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p><strong>示例 1</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">7</span><br>输出：<span class="hljs-number">21</span><br></code></pre></td></tr></table></figure><p><strong>示例 3</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">0</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>提示</strong></p><ul><li>0 &lt;= n &lt;= 100</li></ul><p><strong>注意</strong></p><p>本题与主站 70 题相同：<a href="https://leetcode-cn.com/problems/climbing-stairs/">https://leetcode-cn.com/problems/climbing-stairs/</a></p><h3 id="题解-2"><a class="markdownIt-Anchor" href="#题解-2"></a> 题解</h3><p>我们从后往前看，当青蛙要跳上 n 阶时，要么跳一步，要么跳两步。</p><p>所以 n 阶的跳法就是 n-1 阶和 n-2阶的和。</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">f</span>(<span class="hljs-variable">n</span>)=<span class="hljs-title">f</span>(<span class="hljs-variable">n</span>-<span class="hljs-number">1</span>)+<span class="hljs-title">f</span>(<span class="hljs-variable">n</span>-<span class="hljs-number">2</span>)</span><br></code></pre></td></tr></table></figure><p>本体与斐波那契数列类似，都可以用动态规划。</p><p>注意边界条件</p><blockquote><p>f(0)=1</p><p>f(1)=1</p></blockquote><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numWays</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> first = <span class="hljs-number">0</span>, second = <span class="hljs-number">1</span>, third = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i) &#123;<br>            first = second;<br>            second = third;<br>            third = (first + second) % MOD;<br>        &#125;<br>        <span class="hljs-keyword">return</span> third;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="剑指-offer-63-股票的最大利润"><a class="markdownIt-Anchor" href="#剑指-offer-63-股票的最大利润"></a> <a href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/">剑指 Offer 63. 股票的最大利润</a></h2><h3 id="描述-3"><a class="markdownIt-Anchor" href="#描述-3"></a> 描述</h3><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p><p><strong>示例 1</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [7,1,5,3,6,4]</span><br><span class="hljs-section">输出: 5</span><br><span class="hljs-section">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。<br></code></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [7,6,4,3,1]</span><br><span class="hljs-section">输出: 0</span><br><span class="hljs-section">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></code></pre></td></tr></table></figure><p><strong>限制</strong></p><ul><li>0 &lt;= 数组长度 &lt;= 10^5</li></ul><p><strong>注意</strong></p><p>本题与主站 121 题相同：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/</a></p><h3 id="题解-3"><a class="markdownIt-Anchor" href="#题解-3"></a> 题解</h3><p>直接保存历史最低价格，与每天的价格比较，记录最大利润。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;prices)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> min = INT32_MAX, ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; prices.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">if</span> (prices[i] &lt; min)<br>                min = prices[i];<br>            <span class="hljs-keyword">if</span> (prices[i] - min &gt; ans)<br>                ans = prices[i] - min;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>剑指Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL练习题</title>
    <link href="/p/2815/"/>
    <url>/p/2815/</url>
    
    <content type="html"><![CDATA[<p>SQL练习题</p><span id="more"></span><h2 id="数据表结构"><a class="markdownIt-Anchor" href="#数据表结构"></a> 数据表结构</h2><p><strong>学生表 Student</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> Student(Sid <span class="hljs-type">varchar</span>(<span class="hljs-number">6</span>), Sname <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>), Sage datetime, Ssex <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>));<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Student <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;01&#x27;</span> , <span class="hljs-string">&#x27;赵雷&#x27;</span> , <span class="hljs-string">&#x27;1990-01-01&#x27;</span> , <span class="hljs-string">&#x27;男&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Student <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;02&#x27;</span> , <span class="hljs-string">&#x27;钱电&#x27;</span> , <span class="hljs-string">&#x27;1990-12-21&#x27;</span> , <span class="hljs-string">&#x27;男&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Student <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;03&#x27;</span> , <span class="hljs-string">&#x27;孙风&#x27;</span> , <span class="hljs-string">&#x27;1990-05-20&#x27;</span> , <span class="hljs-string">&#x27;男&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Student <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;04&#x27;</span> , <span class="hljs-string">&#x27;李云&#x27;</span> , <span class="hljs-string">&#x27;1990-08-06&#x27;</span> , <span class="hljs-string">&#x27;男&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Student <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;05&#x27;</span> , <span class="hljs-string">&#x27;周梅&#x27;</span> , <span class="hljs-string">&#x27;1991-12-01&#x27;</span> , <span class="hljs-string">&#x27;女&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Student <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;06&#x27;</span> , <span class="hljs-string">&#x27;吴兰&#x27;</span> , <span class="hljs-string">&#x27;1992-03-01&#x27;</span> , <span class="hljs-string">&#x27;女&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Student <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;07&#x27;</span> , <span class="hljs-string">&#x27;郑竹&#x27;</span> , <span class="hljs-string">&#x27;1989-07-01&#x27;</span> , <span class="hljs-string">&#x27;女&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Student <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;08&#x27;</span> , <span class="hljs-string">&#x27;王菊&#x27;</span> , <span class="hljs-string">&#x27;1990-01-20&#x27;</span> , <span class="hljs-string">&#x27;女&#x27;</span>);<br></code></pre></td></tr></table></figure><p><strong>成绩表 SC</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> SC(Sid <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>), Cid <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>), score <span class="hljs-type">decimal</span>(<span class="hljs-number">18</span>,<span class="hljs-number">1</span>));<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;01&#x27;</span> , <span class="hljs-string">&#x27;01&#x27;</span> , <span class="hljs-number">80</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;01&#x27;</span> , <span class="hljs-string">&#x27;02&#x27;</span> , <span class="hljs-number">90</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;01&#x27;</span> , <span class="hljs-string">&#x27;03&#x27;</span> , <span class="hljs-number">99</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;02&#x27;</span> , <span class="hljs-string">&#x27;01&#x27;</span> , <span class="hljs-number">70</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;02&#x27;</span> , <span class="hljs-string">&#x27;02&#x27;</span> , <span class="hljs-number">60</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;02&#x27;</span> , <span class="hljs-string">&#x27;03&#x27;</span> , <span class="hljs-number">80</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;03&#x27;</span> , <span class="hljs-string">&#x27;01&#x27;</span> , <span class="hljs-number">80</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;03&#x27;</span> , <span class="hljs-string">&#x27;02&#x27;</span> , <span class="hljs-number">80</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;03&#x27;</span> , <span class="hljs-string">&#x27;03&#x27;</span> , <span class="hljs-number">80</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;04&#x27;</span> , <span class="hljs-string">&#x27;01&#x27;</span> , <span class="hljs-number">50</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;04&#x27;</span> , <span class="hljs-string">&#x27;02&#x27;</span> , <span class="hljs-number">30</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;04&#x27;</span> , <span class="hljs-string">&#x27;03&#x27;</span> , <span class="hljs-number">20</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;05&#x27;</span> , <span class="hljs-string">&#x27;01&#x27;</span> , <span class="hljs-number">76</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;05&#x27;</span> , <span class="hljs-string">&#x27;02&#x27;</span> , <span class="hljs-number">87</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;06&#x27;</span> , <span class="hljs-string">&#x27;01&#x27;</span> , <span class="hljs-number">31</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;06&#x27;</span> , <span class="hljs-string">&#x27;03&#x27;</span> , <span class="hljs-number">34</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;07&#x27;</span> , <span class="hljs-string">&#x27;02&#x27;</span> , <span class="hljs-number">89</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;07&#x27;</span> , <span class="hljs-string">&#x27;03&#x27;</span> , <span class="hljs-number">98</span>);<br></code></pre></td></tr></table></figure><p><strong>课程表 Course</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> Course(Cid <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>),Cname <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>),Tid <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>));<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Course <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;01&#x27;</span> , <span class="hljs-string">&#x27;语文&#x27;</span> , <span class="hljs-string">&#x27;02&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Course <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;02&#x27;</span> , <span class="hljs-string">&#x27;数学&#x27;</span> , <span class="hljs-string">&#x27;01&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Course <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;03&#x27;</span> , <span class="hljs-string">&#x27;英语&#x27;</span> , <span class="hljs-string">&#x27;03&#x27;</span>);<br></code></pre></td></tr></table></figure><p><strong>教师表 Teacher</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> Teacher(Tid <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>),Tname <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>));<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Teacher <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;01&#x27;</span> , <span class="hljs-string">&#x27;张三&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Teacher <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;02&#x27;</span> , <span class="hljs-string">&#x27;李四&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Teacher <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;03&#x27;</span> , <span class="hljs-string">&#x27;王五&#x27;</span>);<br></code></pre></td></tr></table></figure><h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2><h3 id="查询-01-课程比-02-课程成绩高的学生的信息及课程分数"><a class="markdownIt-Anchor" href="#查询-01-课程比-02-课程成绩高的学生的信息及课程分数"></a> 查询 “01” 课程比 “02” 课程成绩高的学生的信息及课程分数</h3><p>首先从 student 表选择所有学生信息， sc 表分别选择两个课程的成绩。</p><p>where 语句控制 01 课程比 02 课程成绩高，同时将 select 回来的三个结果连在一起</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> s.<span class="hljs-operator">*</span>, sc_01.score <span class="hljs-keyword">as</span> score_01, sc_01.score <span class="hljs-keyword">as</span> score_02<br><span class="hljs-keyword">from</span> student s,<br>     (<span class="hljs-keyword">select</span> Sid, score <span class="hljs-keyword">from</span> sc <span class="hljs-keyword">where</span> Cid <span class="hljs-operator">=</span> <span class="hljs-number">01</span>) sc_01,<br>     (<span class="hljs-keyword">select</span> Sid, score <span class="hljs-keyword">from</span> sc <span class="hljs-keyword">where</span> Cid <span class="hljs-operator">=</span> <span class="hljs-number">02</span>) sc_02<br><span class="hljs-keyword">where</span> sc_01.Sid <span class="hljs-operator">=</span> sc_02.Sid<br>  <span class="hljs-keyword">and</span> sc_01.score <span class="hljs-operator">&gt;</span> sc_02.score<br>  <span class="hljs-keyword">and</span> s.Sid <span class="hljs-operator">=</span> sc_01.Sid;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">+</span><span class="hljs-comment">------+--------+---------------------+------+----------+----------+</span><br><span class="hljs-operator">|</span> Sid  <span class="hljs-operator">|</span> Sname  <span class="hljs-operator">|</span> Sage                <span class="hljs-operator">|</span> Ssex <span class="hljs-operator">|</span> score_01 <span class="hljs-operator">|</span> score_02 <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------+--------+---------------------+------+----------+----------+</span><br><span class="hljs-operator">|</span> <span class="hljs-number">02</span>   <span class="hljs-operator">|</span> 钱电   <span class="hljs-operator">|</span> <span class="hljs-number">1990</span><span class="hljs-number">-12</span><span class="hljs-number">-21</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-operator">|</span> 男   <span class="hljs-operator">|</span>     <span class="hljs-number">70.0</span> <span class="hljs-operator">|</span>     <span class="hljs-number">60.0</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">04</span>   <span class="hljs-operator">|</span> 李云   <span class="hljs-operator">|</span> <span class="hljs-number">1990</span><span class="hljs-number">-08</span><span class="hljs-number">-06</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-operator">|</span> 男   <span class="hljs-operator">|</span>     <span class="hljs-number">50.0</span> <span class="hljs-operator">|</span>     <span class="hljs-number">30.0</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------+--------+---------------------+------+----------+----------+</span><br><span class="hljs-number">2</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><h3 id="查询平均成绩大于等于60分的同学的学生编号和学生姓名和平均成绩"><a class="markdownIt-Anchor" href="#查询平均成绩大于等于60分的同学的学生编号和学生姓名和平均成绩"></a> 查询平均成绩大于等于60分的同学的学生编号和学生姓名和平均成绩</h3><p>从 student 表和 sc 表选择信息。</p><p>按学生编号分组后，求出 score 的平均值，并筛选。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> s.sid, sname, <span class="hljs-built_in">avg</span>(score) <span class="hljs-keyword">as</span> avg_score<br><span class="hljs-keyword">from</span> student <span class="hljs-keyword">as</span> s,<br>     sc<br><span class="hljs-keyword">where</span> s.sid <span class="hljs-operator">=</span> sc.sid<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> s.sid<br><span class="hljs-keyword">having</span> avg_score <span class="hljs-operator">&gt;</span> <span class="hljs-number">60</span>;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">+</span><span class="hljs-comment">------+--------+-----------+</span><br><span class="hljs-operator">|</span> sid  <span class="hljs-operator">|</span> sname  <span class="hljs-operator">|</span> avg_score <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------+--------+-----------+</span><br><span class="hljs-operator">|</span> <span class="hljs-number">01</span>   <span class="hljs-operator">|</span> 赵雷   <span class="hljs-operator">|</span>  <span class="hljs-number">89.66667</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">02</span>   <span class="hljs-operator">|</span> 钱电   <span class="hljs-operator">|</span>  <span class="hljs-number">70.00000</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">03</span>   <span class="hljs-operator">|</span> 孙风   <span class="hljs-operator">|</span>  <span class="hljs-number">80.00000</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">05</span>   <span class="hljs-operator">|</span> 周梅   <span class="hljs-operator">|</span>  <span class="hljs-number">81.50000</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">07</span>   <span class="hljs-operator">|</span> 郑竹   <span class="hljs-operator">|</span>  <span class="hljs-number">93.50000</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------+--------+-----------+</span><br><span class="hljs-number">5</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><h3 id="查询-sc-表存在成绩的学生信息"><a class="markdownIt-Anchor" href="#查询-sc-表存在成绩的学生信息"></a> 查询 SC 表存在成绩的学生信息</h3><p>查询 student 表。</p><p>筛选条件放在where语句里。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> student s<br><span class="hljs-keyword">where</span> Sid <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> Sid <span class="hljs-keyword">from</span> sc <span class="hljs-keyword">where</span> score <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>)<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">+</span><span class="hljs-comment">------+--------+---------------------+------+</span><br><span class="hljs-operator">|</span> Sid  <span class="hljs-operator">|</span> Sname  <span class="hljs-operator">|</span> Sage                <span class="hljs-operator">|</span> Ssex <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------+--------+---------------------+------+</span><br><span class="hljs-operator">|</span> <span class="hljs-number">01</span>   <span class="hljs-operator">|</span> 赵雷   <span class="hljs-operator">|</span> <span class="hljs-number">1990</span><span class="hljs-number">-01</span><span class="hljs-number">-01</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-operator">|</span> 男   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">02</span>   <span class="hljs-operator">|</span> 钱电   <span class="hljs-operator">|</span> <span class="hljs-number">1990</span><span class="hljs-number">-12</span><span class="hljs-number">-21</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-operator">|</span> 男   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">03</span>   <span class="hljs-operator">|</span> 孙风   <span class="hljs-operator">|</span> <span class="hljs-number">1990</span><span class="hljs-number">-05</span><span class="hljs-number">-20</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-operator">|</span> 男   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">04</span>   <span class="hljs-operator">|</span> 李云   <span class="hljs-operator">|</span> <span class="hljs-number">1990</span><span class="hljs-number">-08</span><span class="hljs-number">-06</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-operator">|</span> 男   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">05</span>   <span class="hljs-operator">|</span> 周梅   <span class="hljs-operator">|</span> <span class="hljs-number">1991</span><span class="hljs-number">-12</span><span class="hljs-number">-01</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-operator">|</span> 女   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">06</span>   <span class="hljs-operator">|</span> 吴兰   <span class="hljs-operator">|</span> <span class="hljs-number">1992</span><span class="hljs-number">-03</span><span class="hljs-number">-01</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-operator">|</span> 女   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">07</span>   <span class="hljs-operator">|</span> 郑竹   <span class="hljs-operator">|</span> <span class="hljs-number">1989</span><span class="hljs-number">-07</span><span class="hljs-number">-01</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-operator">|</span> 女   <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------+--------+---------------------+------+</span><br><span class="hljs-number">7</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><h3 id="查询所有同学的学生编号-学生姓名-选课总数-所有课程的总成绩没成绩的显示为-null"><a class="markdownIt-Anchor" href="#查询所有同学的学生编号-学生姓名-选课总数-所有课程的总成绩没成绩的显示为-null"></a> 查询所有同学的学生编号、学生姓名、选课总数、所有课程的总成绩(没成绩的显示为 null )</h3><p>因为有空值，所以用 join。且因为空值是在 sc 里，让 sc left join student 表。</p><p>同时对学生编号分组，统计每个人的选课总数和总成绩。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> s.Sid, s.Sname, <span class="hljs-built_in">count</span>(Cid) <span class="hljs-keyword">as</span> count_course, <span class="hljs-built_in">sum</span>(score) <span class="hljs-keyword">as</span> sum_score<br><span class="hljs-keyword">from</span> student s<br>         <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> sc <span class="hljs-keyword">on</span> s.Sid <span class="hljs-operator">=</span> sc.Sid<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> s.Sid<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">+</span><span class="hljs-comment">------+--------+--------------+-----------+</span><br><span class="hljs-operator">|</span> sid  <span class="hljs-operator">|</span> sname  <span class="hljs-operator">|</span> 选课总数     <span class="hljs-operator">|</span> 总成绩    <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------+--------+--------------+-----------+</span><br><span class="hljs-operator">|</span> <span class="hljs-number">01</span>   <span class="hljs-operator">|</span> 赵雷   <span class="hljs-operator">|</span>            <span class="hljs-number">3</span> <span class="hljs-operator">|</span>     <span class="hljs-number">269.0</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">02</span>   <span class="hljs-operator">|</span> 钱电   <span class="hljs-operator">|</span>            <span class="hljs-number">3</span> <span class="hljs-operator">|</span>     <span class="hljs-number">210.0</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">03</span>   <span class="hljs-operator">|</span> 孙风   <span class="hljs-operator">|</span>            <span class="hljs-number">3</span> <span class="hljs-operator">|</span>     <span class="hljs-number">240.0</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">04</span>   <span class="hljs-operator">|</span> 李云   <span class="hljs-operator">|</span>            <span class="hljs-number">3</span> <span class="hljs-operator">|</span>     <span class="hljs-number">100.0</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">05</span>   <span class="hljs-operator">|</span> 周梅   <span class="hljs-operator">|</span>            <span class="hljs-number">2</span> <span class="hljs-operator">|</span>     <span class="hljs-number">163.0</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">06</span>   <span class="hljs-operator">|</span> 吴兰   <span class="hljs-operator">|</span>            <span class="hljs-number">2</span> <span class="hljs-operator">|</span>      <span class="hljs-number">65.0</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">07</span>   <span class="hljs-operator">|</span> 郑竹   <span class="hljs-operator">|</span>            <span class="hljs-number">2</span> <span class="hljs-operator">|</span>     <span class="hljs-number">187.0</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">08</span>   <span class="hljs-operator">|</span> 王菊   <span class="hljs-operator">|</span>            <span class="hljs-number">0</span> <span class="hljs-operator">|</span>      <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------+--------+--------------+-----------+</span><br><span class="hljs-number">8</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><h3 id="查带有成绩的学生信息"><a class="markdownIt-Anchor" href="#查带有成绩的学生信息"></a> 查带有成绩的学生信息</h3><p>行转列时，使用 sum(case when … then …)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> s.Sid,<br>       s.Sname,<br>       <span class="hljs-built_in">count</span>(Cid)                                       <span class="hljs-keyword">as</span> count_course,<br>       <span class="hljs-built_in">sum</span>(score)                                       <span class="hljs-keyword">as</span> sum_score,<br>       <span class="hljs-built_in">sum</span>(<span class="hljs-keyword">case</span> <span class="hljs-keyword">when</span> Cid <span class="hljs-operator">=</span> <span class="hljs-number">01</span> <span class="hljs-keyword">then</span> score <span class="hljs-keyword">else</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">end</span>) <span class="hljs-keyword">as</span> score_01,<br>       <span class="hljs-built_in">sum</span>(<span class="hljs-keyword">case</span> <span class="hljs-keyword">when</span> Cid <span class="hljs-operator">=</span> <span class="hljs-number">02</span> <span class="hljs-keyword">then</span> score <span class="hljs-keyword">else</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">end</span>) <span class="hljs-keyword">as</span> score_02,<br>       <span class="hljs-built_in">sum</span>(<span class="hljs-keyword">case</span> <span class="hljs-keyword">when</span> Cid <span class="hljs-operator">=</span> <span class="hljs-number">03</span> <span class="hljs-keyword">then</span> score <span class="hljs-keyword">else</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">end</span>) <span class="hljs-keyword">as</span> score_03<br><span class="hljs-keyword">from</span> student s,<br>     sc<br><span class="hljs-keyword">where</span> s.Sid <span class="hljs-operator">=</span> sc.Sid<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> s.Sid<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">+</span><span class="hljs-comment">------+--------+--------------+-----------+----------+----------+----------+</span><br><span class="hljs-operator">|</span> sid  <span class="hljs-operator">|</span> sname  <span class="hljs-operator">|</span> 选课总数     <span class="hljs-operator">|</span> 总成绩    <span class="hljs-operator">|</span> score_01 <span class="hljs-operator">|</span> score_02 <span class="hljs-operator">|</span> score_03 <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------+--------+--------------+-----------+----------+----------+----------+</span><br><span class="hljs-operator">|</span> <span class="hljs-number">01</span>   <span class="hljs-operator">|</span> 赵雷   <span class="hljs-operator">|</span>            <span class="hljs-number">3</span> <span class="hljs-operator">|</span>     <span class="hljs-number">269.0</span> <span class="hljs-operator">|</span>     <span class="hljs-number">80.0</span> <span class="hljs-operator">|</span>     <span class="hljs-number">90.0</span> <span class="hljs-operator">|</span>     <span class="hljs-number">99.0</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">02</span>   <span class="hljs-operator">|</span> 钱电   <span class="hljs-operator">|</span>            <span class="hljs-number">3</span> <span class="hljs-operator">|</span>     <span class="hljs-number">210.0</span> <span class="hljs-operator">|</span>     <span class="hljs-number">70.0</span> <span class="hljs-operator">|</span>     <span class="hljs-number">60.0</span> <span class="hljs-operator">|</span>     <span class="hljs-number">80.0</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">03</span>   <span class="hljs-operator">|</span> 孙风   <span class="hljs-operator">|</span>            <span class="hljs-number">3</span> <span class="hljs-operator">|</span>     <span class="hljs-number">240.0</span> <span class="hljs-operator">|</span>     <span class="hljs-number">80.0</span> <span class="hljs-operator">|</span>     <span class="hljs-number">80.0</span> <span class="hljs-operator">|</span>     <span class="hljs-number">80.0</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">04</span>   <span class="hljs-operator">|</span> 李云   <span class="hljs-operator">|</span>            <span class="hljs-number">3</span> <span class="hljs-operator">|</span>     <span class="hljs-number">100.0</span> <span class="hljs-operator">|</span>     <span class="hljs-number">50.0</span> <span class="hljs-operator">|</span>     <span class="hljs-number">30.0</span> <span class="hljs-operator">|</span>     <span class="hljs-number">20.0</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">05</span>   <span class="hljs-operator">|</span> 周梅   <span class="hljs-operator">|</span>            <span class="hljs-number">2</span> <span class="hljs-operator">|</span>     <span class="hljs-number">163.0</span> <span class="hljs-operator">|</span>     <span class="hljs-number">76.0</span> <span class="hljs-operator">|</span>     <span class="hljs-number">87.0</span> <span class="hljs-operator">|</span>     <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">06</span>   <span class="hljs-operator">|</span> 吴兰   <span class="hljs-operator">|</span>            <span class="hljs-number">2</span> <span class="hljs-operator">|</span>      <span class="hljs-number">65.0</span> <span class="hljs-operator">|</span>     <span class="hljs-number">31.0</span> <span class="hljs-operator">|</span>     <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span>     <span class="hljs-number">34.0</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">07</span>   <span class="hljs-operator">|</span> 郑竹   <span class="hljs-operator">|</span>            <span class="hljs-number">2</span> <span class="hljs-operator">|</span>     <span class="hljs-number">187.0</span> <span class="hljs-operator">|</span>     <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span>     <span class="hljs-number">89.0</span> <span class="hljs-operator">|</span>     <span class="hljs-number">98.0</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------+--------+--------------+-----------+----------+----------+----------+</span><br><span class="hljs-number">7</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><h3 id="查询李姓老师的数量"><a class="markdownIt-Anchor" href="#查询李姓老师的数量"></a> 查询「李」姓老师的数量</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(Tid)<br><span class="hljs-keyword">from</span> teacher t<br><span class="hljs-keyword">where</span> Tname <span class="hljs-keyword">like</span> &quot;李%&quot;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">+</span><span class="hljs-comment">--------------+</span><br><span class="hljs-operator">|</span> <span class="hljs-built_in">count</span>(tname) <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------------+</span><br><span class="hljs-operator">|</span>            <span class="hljs-number">1</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------------+</span><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><h3 id="查询学过张三老师授课的同学的信息"><a class="markdownIt-Anchor" href="#查询学过张三老师授课的同学的信息"></a> 查询学过「张三」老师授课的同学的信息</h3><p>个人解法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> s.<span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> student s,<br>     teacher t,<br>     sc,<br>     course c<br><span class="hljs-keyword">where</span> sc.Sid <span class="hljs-operator">=</span> s.Sid<br>  <span class="hljs-keyword">and</span> c.Tid <span class="hljs-operator">=</span> t.Tid<br>  <span class="hljs-keyword">and</span> c.Cid <span class="hljs-operator">=</span> sc.Cid<br>  <span class="hljs-keyword">and</span> t.Tname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;张三&#x27;</span><br></code></pre></td></tr></table></figure><p>优质解法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> student<br><span class="hljs-keyword">where</span> sid <span class="hljs-keyword">in</span> (<br>    <span class="hljs-keyword">select</span> sid<br>    <span class="hljs-keyword">from</span> sc,<br>         course,<br>         teacher<br>    <span class="hljs-keyword">where</span> sc.cid <span class="hljs-operator">=</span> course.cid<br>      <span class="hljs-keyword">and</span> course.tid <span class="hljs-operator">=</span> teacher.tid<br>      <span class="hljs-keyword">and</span> tname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;张三&#x27;</span><br>)<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">+</span><span class="hljs-comment">------+--------+---------------------+------+</span><br><span class="hljs-operator">|</span> Sid  <span class="hljs-operator">|</span> Sname  <span class="hljs-operator">|</span> Sage                <span class="hljs-operator">|</span> Ssex <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------+--------+---------------------+------+</span><br><span class="hljs-operator">|</span> <span class="hljs-number">01</span>   <span class="hljs-operator">|</span> 赵雷   <span class="hljs-operator">|</span> <span class="hljs-number">1990</span><span class="hljs-number">-01</span><span class="hljs-number">-01</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-operator">|</span> 男   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">02</span>   <span class="hljs-operator">|</span> 钱电   <span class="hljs-operator">|</span> <span class="hljs-number">1990</span><span class="hljs-number">-12</span><span class="hljs-number">-21</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-operator">|</span> 男   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">03</span>   <span class="hljs-operator">|</span> 孙风   <span class="hljs-operator">|</span> <span class="hljs-number">1990</span><span class="hljs-number">-05</span><span class="hljs-number">-20</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-operator">|</span> 男   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">04</span>   <span class="hljs-operator">|</span> 李云   <span class="hljs-operator">|</span> <span class="hljs-number">1990</span><span class="hljs-number">-08</span><span class="hljs-number">-06</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-operator">|</span> 男   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">05</span>   <span class="hljs-operator">|</span> 周梅   <span class="hljs-operator">|</span> <span class="hljs-number">1991</span><span class="hljs-number">-12</span><span class="hljs-number">-01</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-operator">|</span> 女   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">07</span>   <span class="hljs-operator">|</span> 郑竹   <span class="hljs-operator">|</span> <span class="hljs-number">1989</span><span class="hljs-number">-07</span><span class="hljs-number">-01</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-operator">|</span> 女   <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------+--------+---------------------+------+</span><br><span class="hljs-number">6</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>sqss</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer Day-07</title>
    <link href="/p/9c6a/"/>
    <url>/p/9c6a/</url>
    
    <content type="html"><![CDATA[<p>剑指Offer Day-07</p><span id="more"></span><h2 id="剑指-offer-26-树的子结构"><a class="markdownIt-Anchor" href="#剑指-offer-26-树的子结构"></a> <a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/">剑指 Offer 26. 树的子结构</a></h2><h3 id="描述"><a class="markdownIt-Anchor" href="#描述"></a> 描述</h3><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p><p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p><p><strong>例如</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs livescript">给定的树 A:<br>     <span class="hljs-number">3</span><br>    / <span class="hljs-string">\</span><br>   <span class="hljs-number">4</span>   <span class="hljs-number">5</span><br>  / <span class="hljs-string">\</span><br> <span class="hljs-number">1</span>   <span class="hljs-number">2</span><br> <br>给定的树 B：<br>   <span class="hljs-number">4</span> <br>  /<br> <span class="hljs-number">1</span><br> <br>返回 <span class="hljs-literal">true</span>，因为 B 与 A 的一个子树拥有相同的结构和节点值。<br></code></pre></td></tr></table></figure><p><strong>示例 1</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">A</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], <span class="hljs-attr">B</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">A</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], <span class="hljs-attr">B</span> = [<span class="hljs-number">4</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>限制</strong></p><ul><li>0 &lt;= 节点个数 &lt;= 10000</li></ul><h3 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h3><p>我们先找到A中与B的根节点数值相同的节点。</p><p>然后再用递归比对B是否为A的子结构。</p><p><strong>策略</strong></p><ul><li>判断当前节点值是否相等，不等则返回 false，相等则递归继续判断。</li><li>如果B先递归完，说明之前的判断都没有问题，B为A的子结构，返回 true。</li><li>如果A先递归完，说明B的结构比A的长，B不为A的子结构，返回 false。</li></ul><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSubStructure</span><span class="hljs-params">(TreeNode *A, TreeNode *B)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!A || !B)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">//判断是否相等并且为子结构</span><br>        <span class="hljs-keyword">if</span> (A-&gt;val == B-&gt;val &amp;&amp; <span class="hljs-built_in">recur</span>(A, B))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//递归搜索</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isSubStructure</span>(A-&gt;left, B) || <span class="hljs-built_in">isSubStructure</span>(A-&gt;right, B);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">recur</span><span class="hljs-params">(TreeNode *A, TreeNode *B)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!B)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (!A)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (A-&gt;val == B-&gt;val) &#123;<br>            <span class="hljs-comment">//递归继续判断</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">recur</span>(A-&gt;left, B-&gt;left) &amp;&amp; <span class="hljs-built_in">recur</span>(A-&gt;right, B-&gt;right);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="剑指-offer-27-二叉树的镜像"><a class="markdownIt-Anchor" href="#剑指-offer-27-二叉树的镜像"></a> <a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/">剑指 Offer 27. 二叉树的镜像</a></h2><h3 id="描述-2"><a class="markdownIt-Anchor" href="#描述-2"></a> 描述</h3><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p><p><strong>例如</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs livescript">输入：<br>     <span class="hljs-number">4</span><br>   /   <span class="hljs-string">\</span><br>  <span class="hljs-number">2</span>     <span class="hljs-number">7</span><br> / <span class="hljs-string">\</span>   / <span class="hljs-string">\</span><br><span class="hljs-number">1</span>   <span class="hljs-number">3</span> <span class="hljs-number">6</span>   <span class="hljs-number">9</span><br><br>镜像输出：<br>     <span class="hljs-number">4</span><br>   /   <span class="hljs-string">\</span><br>  <span class="hljs-number">7</span>     <span class="hljs-number">2</span><br> / <span class="hljs-string">\</span>   / <span class="hljs-string">\</span><br><span class="hljs-number">9</span>   <span class="hljs-number">6</span> <span class="hljs-number">3</span>   <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 1</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：root = <span class="hljs-string">[4,2,7,1,3,6,9]</span><br>输出：<span class="hljs-string">[4,7,2,9,6,3,1]</span><br></code></pre></td></tr></table></figure><p><strong>限制</strong></p><ul><li>0 &lt;= 节点个数 &lt;= 1000</li></ul><p><strong>注意</strong></p><p>本题与主站 226 题相同：<a href="https://leetcode-cn.com/problems/invert-binary-tree/">https://leetcode-cn.com/problems/invert-binary-tree/</a></p><h3 id="题解-2"><a class="markdownIt-Anchor" href="#题解-2"></a> 题解</h3><p>本体应用较基础的递归思想，直接递归交换即可。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode *<span class="hljs-title">mirrorTree</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-built_in">swapNode</span>(root);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-comment">//递归交换</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swapNode</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root)<br>            <span class="hljs-keyword">return</span>;<br>        TreeNode *temp = root-&gt;left;<br>        root-&gt;left = root-&gt;right;<br>        root-&gt;right = temp;<br>        <span class="hljs-built_in">swapNode</span>(root-&gt;left);<br>        <span class="hljs-built_in">swapNode</span>(root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="剑指-offer-28-对称的二叉树"><a class="markdownIt-Anchor" href="#剑指-offer-28-对称的二叉树"></a> <a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/">剑指 Offer 28. 对称的二叉树</a></h2><h3 id="描述-3"><a class="markdownIt-Anchor" href="#描述-3"></a> 描述</h3><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p><p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">    <span class="hljs-number">1</span><br>   / <span class="hljs-string">\</span><br>  <span class="hljs-number">2</span>   <span class="hljs-number">2</span><br> / <span class="hljs-string">\</span> / <span class="hljs-string">\</span><br><span class="hljs-number">3</span>  <span class="hljs-number">4</span> <span class="hljs-number">4</span>  <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">  <span class="hljs-number">1</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">2</span>   <span class="hljs-number">2</span><br> <span class="hljs-string">\</span>   <span class="hljs-string">\</span><br> <span class="hljs-number">3</span>    <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>示例 1</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>]<br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>]<br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>限制</strong></p><ul><li>0 &lt;= 节点个数 &lt;= 1000</li></ul><p><strong>注意</strong></p><p>本题与主站 101 题相同：<a href="https://leetcode-cn.com/problems/symmetric-tree/">https://leetcode-cn.com/problems/symmetric-tree/</a></p><h3 id="题解-3"><a class="markdownIt-Anchor" href="#题解-3"></a> 题解</h3><p>当有两个对称节点，他们应满足以下条件：</p><ul><li>两个节点值相同</li><li>左节点的右子节点与右节点的左子节点相同</li><li>左节点的左子节点与右节点的右子节点相同</li></ul><p>我们可以每次递归判断第一个条件，其他的则由递归来完成。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">recue</span>(root-&gt;left, root-&gt;right);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">recue</span><span class="hljs-params">(TreeNode *left, TreeNode *right)</span> </span>&#123;<br>        <span class="hljs-comment">//两节点都为空，对称</span><br>        <span class="hljs-keyword">if</span> (!left &amp;&amp; !right)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//其中一个为空，不对称</span><br>        <span class="hljs-keyword">if</span> (left &amp;&amp; !right || !left &amp;&amp; right)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">//两节点值相等，递归判断子节点</span><br>        <span class="hljs-keyword">if</span> (left-&gt;val == right-&gt;val)<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">recue</span>(left-&gt;left, right-&gt;right) &amp;&amp; <span class="hljs-built_in">recue</span>(left-&gt;right, right-&gt;left);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>剑指Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer Day-06</title>
    <link href="/p/5cab/"/>
    <url>/p/5cab/</url>
    
    <content type="html"><![CDATA[<p>剑指Offer Day-06</p><span id="more"></span><h2 id="面试题32-i-从上到下打印二叉树"><a class="markdownIt-Anchor" href="#面试题32-i-从上到下打印二叉树"></a> <a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/">面试题32 - I. 从上到下打印二叉树</a></h2><h3 id="描述"><a class="markdownIt-Anchor" href="#描述"></a> 描述</h3><p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p><p><strong>例如</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs livescript">给定二叉树: [<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>],<br>    <span class="hljs-number">3</span><br>   / <span class="hljs-string">\</span><br>  <span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>    /  <span class="hljs-string">\</span><br>   <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br>   <br>返回：<br>[<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]<br></code></pre></td></tr></table></figure><p><strong>提示</strong></p><ul><li>节点总数 &lt;= 1000</li></ul><h3 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h3><p>最普通的层序遍历，使用队列。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    queue&lt;TreeNode *&gt; queue;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; ans;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">levelOrder</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root)<br>            <span class="hljs-keyword">return</span> ans;<br>        queue.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!queue.<span class="hljs-built_in">empty</span>()) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(queue.<span class="hljs-built_in">front</span>()-&gt;val);<br>            <span class="hljs-keyword">if</span> (queue.<span class="hljs-built_in">front</span>()-&gt;left)<br>                queue.<span class="hljs-built_in">push</span>(queue.<span class="hljs-built_in">front</span>()-&gt;left);<br>            <span class="hljs-keyword">if</span> (queue.<span class="hljs-built_in">front</span>()-&gt;right)<br>                queue.<span class="hljs-built_in">push</span>(queue.<span class="hljs-built_in">front</span>()-&gt;right);<br>            queue.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="剑指-offer-32-ii-从上到下打印二叉树-ii"><a class="markdownIt-Anchor" href="#剑指-offer-32-ii-从上到下打印二叉树-ii"></a> <a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">剑指 Offer 32 - II. 从上到下打印二叉树 II</a></h2><h3 id="描述-2"><a class="markdownIt-Anchor" href="#描述-2"></a> 描述</h3><p>此题与<a href="https://blog.allenji.cn/p/9230/">面试算法题-02 - Allen Ji’s blog</a>中<a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a>相同。</p><h3 id="题解-2"><a class="markdownIt-Anchor" href="#题解-2"></a> 题解</h3><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    queue&lt;TreeNode *&gt; queue;<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; ans;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode *root) &#123;<br>        <span class="hljs-keyword">if</span> (!root)<br>            <span class="hljs-keyword">return</span> ans;<br>        queue.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!queue.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">int</span> levelSize = queue.<span class="hljs-built_in">size</span>();<br>            ans.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;());<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; levelSize; ++i) &#123;<br>                ans.<span class="hljs-built_in">back</span>().<span class="hljs-built_in">push_back</span>(queue.<span class="hljs-built_in">front</span>()-&gt;val);<br>                <span class="hljs-keyword">if</span> (queue.<span class="hljs-built_in">front</span>()-&gt;left)<br>                    queue.<span class="hljs-built_in">push</span>(queue.<span class="hljs-built_in">front</span>()-&gt;left);<br>                <span class="hljs-keyword">if</span> (queue.<span class="hljs-built_in">front</span>()-&gt;right)<br>                    queue.<span class="hljs-built_in">push</span>(queue.<span class="hljs-built_in">front</span>()-&gt;right);<br>                queue.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="剑指-offer-32-iii-从上到下打印二叉树-iii"><a class="markdownIt-Anchor" href="#剑指-offer-32-iii-从上到下打印二叉树-iii"></a> <a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/">剑指 Offer 32 - III. 从上到下打印二叉树 III</a></h2><h3 id="题解-3"><a class="markdownIt-Anchor" href="#题解-3"></a> 题解</h3><p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p><p><strong>例如</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">给定二叉树: [<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>],<br>    <span class="hljs-number">3</span><br>   / \<br>  <span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>    /  \<br>   <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br>   <br>返回其层次遍历结果：<br><span class="hljs-string">[</span><br><span class="hljs-string">  [3]</span>,<br><span class="hljs-string">  [20,9]</span>,<br><span class="hljs-string">  [15,7]</span><br>]<br></code></pre></td></tr></table></figure><p><strong>提示</strong></p><ul><li>节点总数 &lt;= 1000</li></ul><h3 id="题解-4"><a class="markdownIt-Anchor" href="#题解-4"></a> 题解</h3><p>我们将奇数层和偶数层的操作分开。</p><p>level从0开始计数。</p><ul><li>奇数层：队首读，队尾入。</li><li>偶数层：队尾读，队首入。</li></ul><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    deque&lt;TreeNode *&gt; deque;<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; ans;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode *root) &#123;<br>        <span class="hljs-keyword">if</span> (!root)<br>            <span class="hljs-keyword">return</span> ans;<br>        deque.<span class="hljs-built_in">push_back</span>(root);<br>        <span class="hljs-keyword">int</span> level = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!deque.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">int</span> levelSize = deque.<span class="hljs-built_in">size</span>();<br>            ans.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;());<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; levelSize; ++i) &#123;<br>                <span class="hljs-keyword">if</span> (level % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">//偶数层，从队尾读，队首入</span><br>                    ans.<span class="hljs-built_in">back</span>().<span class="hljs-built_in">push_back</span>(deque.<span class="hljs-built_in">back</span>()-&gt;val);<br>                    <span class="hljs-keyword">if</span> (deque.<span class="hljs-built_in">back</span>()-&gt;left)<br>                        deque.<span class="hljs-built_in">push_front</span>(deque.<span class="hljs-built_in">back</span>()-&gt;left);<br>                    <span class="hljs-keyword">if</span> (deque.<span class="hljs-built_in">back</span>()-&gt;right)<br>                        deque.<span class="hljs-built_in">push_front</span>(deque.<span class="hljs-built_in">back</span>()-&gt;right);<br>                    deque.<span class="hljs-built_in">pop_back</span>();<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//奇数层，队首读，队尾入</span><br>                    ans.<span class="hljs-built_in">back</span>().<span class="hljs-built_in">push_back</span>(deque.<span class="hljs-built_in">front</span>()-&gt;val);<br>                    <span class="hljs-keyword">if</span> (deque.<span class="hljs-built_in">front</span>()-&gt;right)<br>                        deque.<span class="hljs-built_in">push_back</span>(deque.<span class="hljs-built_in">front</span>()-&gt;right);<br>                    <span class="hljs-keyword">if</span> (deque.<span class="hljs-built_in">front</span>()-&gt;left)<br>                        deque.<span class="hljs-built_in">push_back</span>(deque.<span class="hljs-built_in">front</span>()-&gt;left);<br>                    deque.<span class="hljs-built_in">pop_front</span>();<br>                &#125;<br>            &#125;<br>            level++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>剑指Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer Day-05</title>
    <link href="/p/5deb/"/>
    <url>/p/5deb/</url>
    
    <content type="html"><![CDATA[<p>剑指Offer Day-05</p><span id="more"></span><h2 id="剑指-offer-04-二维数组中的查找"><a class="markdownIt-Anchor" href="#剑指-offer-04-二维数组中的查找"></a> <a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">剑指 Offer 04. 二维数组中的查找</a></h2><h3 id="描述"><a class="markdownIt-Anchor" href="#描述"></a> 描述</h3><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p><strong>示例</strong></p><p>现有矩阵 matrix 如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json">[<br>  [<span class="hljs-number">1</span>,   <span class="hljs-number">4</span>,  <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">15</span>],<br>  [<span class="hljs-number">2</span>,   <span class="hljs-number">5</span>,  <span class="hljs-number">8</span>, <span class="hljs-number">12</span>, <span class="hljs-number">19</span>],<br>  [<span class="hljs-number">3</span>,   <span class="hljs-number">6</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">22</span>],<br>  [<span class="hljs-number">10</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">17</span>, <span class="hljs-number">24</span>],<br>  [<span class="hljs-number">18</span>, <span class="hljs-number">21</span>, <span class="hljs-number">23</span>, <span class="hljs-number">26</span>, <span class="hljs-number">30</span>]<br>]<br></code></pre></td></tr></table></figure><p>给定 target = 5，返回 true。</p><p>给定 target = 20，返回 false。</p><p><strong>限制</strong></p><ul><li><p>0 &lt;= n &lt;= 1000</p></li><li><p>0 &lt;= m &lt;= 1000</p></li></ul><p><strong>注意</strong></p><p>本题与主站 240 题相同：<a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/">https://leetcode-cn.com/problems/search-a-2d-matrix-ii/</a></p><h3 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h3><p>参考：<a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/solution/mian-shi-ti-04-er-wei-shu-zu-zhong-de-cha-zhao-zuo/">面试题04. 二维数组中的查找（标志数，清晰图解） - 二维数组中的查找 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p>我们发现此排序矩阵类似二叉搜索树，对于每个元素，其“左分支”元素更小，“右分支”元素更大。</p><p><img src="https://pic.leetcode-cn.com/6584ea93812d27112043d203ea90e4b0950117d45e0452d0c630fcb247fbc4af-Picture1.png" alt="Picture1.png" /></p><p>所以我们可以从左下角或右上角开始，按照类似二叉搜索树方式遍历。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">findNumberIn2DArray</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; &amp;matrix, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (matrix.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">//这里我们选的从右上角开始遍历</span><br>        <span class="hljs-keyword">int</span> col = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, row = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> curr;<br>        <span class="hljs-comment">//设置边界条件，防止越界</span><br>        <span class="hljs-keyword">while</span> (col &gt;= <span class="hljs-number">0</span> &amp;&amp; row &lt;= matrix.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) &#123;<br>            curr = matrix[row][col];<br>            <span class="hljs-keyword">if</span> (curr == target)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (target &gt; curr)<br>                row++;<br>            <span class="hljs-keyword">else</span><br>                col--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="剑指-offer-11-旋转数组的最小数字"><a class="markdownIt-Anchor" href="#剑指-offer-11-旋转数组的最小数字"></a> <a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">剑指 Offer 11. 旋转数组的最小数字</a></h2><h3 id="描述-2"><a class="markdownIt-Anchor" href="#描述-2"></a> 描述</h3><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。</p><p>给你一个可能存在 重复 元素值的数组 numbers ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一次旋转，该数组的最小值为1。</p><p><strong>示例 1</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：<span class="hljs-string">[3,4,5,1,2]</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：<span class="hljs-string">[2,2,2,0,1]</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>注意</strong></p><p>本题与主站 154 题相同：<a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/">https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/</a></p><h3 id="题解-2"><a class="markdownIt-Anchor" href="#题解-2"></a> 题解</h3><p>本题为排序数组，所以用二分解。</p><p>二分的中心思想是不断地缩小边界，我们需要考虑各个情况如何缩小边界，最后到达左侧排序序列的右边界。</p><p><strong>首先判断mid落在哪里</strong></p><p>我们默认在到达边界之前，left都应在左序列，而right在右序列</p><ul><li>如果mid落在左排序序列</li></ul><p>此时mid大于等于left，同时也大于等于right。</p><ul><li>如果mid落在右排序序列</li></ul><p>此时mid小于等于left，同时也小于等于right。</p><p>由上可知，只需要单独关注left或者right就行，并且需要区分出相等的情况。在本题解，我们关注right。</p><ul><li>当mid等于right时</li></ul><p>我们只需要让right减小，以缩小边界。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;numbers)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (numbers.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> numbers[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = numbers.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, mid;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            mid = left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (numbers[mid] &lt; numbers[right])<br>                right = mid;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (numbers[mid] &gt; numbers[right])<br>                left = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                right--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> numbers[left];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="剑指-offer-50-第一个只出现一次的字符"><a class="markdownIt-Anchor" href="#剑指-offer-50-第一个只出现一次的字符"></a> <a href="https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/">剑指 Offer 50. 第一个只出现一次的字符</a></h2><h3 id="描述-3"><a class="markdownIt-Anchor" href="#描述-3"></a> 描述</h3><p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。</p><p><strong>示例 1</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：s = <span class="hljs-string">&quot;abaccdeff&quot;</span><br>输出：&#x27;b&#x27;<br></code></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：s = <span class="hljs-string">&quot;&quot;</span> <br>输出：&#x27; &#x27;<br></code></pre></td></tr></table></figure><p><strong>限制</strong></p><ul><li>0 &lt;= s 的长度 &lt;= 50000</li></ul><h3 id="题解-3"><a class="markdownIt-Anchor" href="#题解-3"></a> 题解</h3><p>首先用map存储字符出现的频次，如果多次出现则置为-1。</p><p>其次我们需要第一个只出现一次的字符，很适合用队列（FIFO）</p><p>在每个字符第一次出现的时候，将其加入队列。</p><p>遍历完频次后，从队列头开始判断，如果value为-1说明多次出现，出队列。</p><p>第一个value为1的元素即是第一个出现一次的元素。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    map&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; map;<br>    queue&lt;<span class="hljs-keyword">char</span>&gt; queue;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">firstUniqChar</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ch:s) &#123;<br>            <span class="hljs-keyword">if</span> (map.<span class="hljs-built_in">count</span>(ch) == <span class="hljs-number">0</span>) &#123;<br>                map[ch] = <span class="hljs-number">1</span>;<br>                queue.<span class="hljs-built_in">push</span>(ch);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                map[ch] = <span class="hljs-number">-1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (!queue.<span class="hljs-built_in">empty</span>() &amp;&amp; map[queue.<span class="hljs-built_in">front</span>()] == <span class="hljs-number">-1</span>)<br>            queue.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span> (queue.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> queue.<span class="hljs-built_in">front</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>剑指Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer Day-04</title>
    <link href="/p/9d2a/"/>
    <url>/p/9d2a/</url>
    
    <content type="html"><![CDATA[<p>剑指Offer Day-04</p><span id="more"></span><h2 id="剑指-offer-03-数组中重复的数字"><a class="markdownIt-Anchor" href="#剑指-offer-03-数组中重复的数字"></a> <a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">剑指 Offer 03. 数组中重复的数字</a></h2><h3 id="描述"><a class="markdownIt-Anchor" href="#描述"></a> 描述</h3><p>找出数组中重复的数字。</p><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p><p><strong>示例 1</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：<br><span class="hljs-string">[2, 3, 1, 0, 2, 5, 3]</span><br>输出：<span class="hljs-number">2</span> 或 <span class="hljs-number">3</span> <br></code></pre></td></tr></table></figure><p><strong>限制</strong></p><p>2 &lt;= n &lt;= 100000</p><h3 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h3><p><strong>解法一</strong></p><p>遍历，保存到set里</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    set&lt;<span class="hljs-keyword">int</span>&gt; set;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findRepeatNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;nums)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> item:nums) &#123;<br>            <span class="hljs-keyword">if</span> (set.<span class="hljs-built_in">count</span>(item) &gt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> item;<br>            set.<span class="hljs-built_in">insert</span>(item);<br>        &#125;<br>        <span class="hljs-comment">//题目保证有重复，这里返回什么都可以</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>解法二</strong></p><p>原地交换。</p><p>遍历时，将元素与元素值对应的索引地址交换，形成 <code>nums[i] == nums[nums[i]]</code> 。</p><p>这样，下次遇到相同的 <code>nums[i]</code> 想交换时，会发现目标位置已经有重复值，最后返回这个重复值</p><p><strong>注意</strong></p><p>如果进行了一次交换，<code>i</code> 不要增加，因为不能保证交换过来的元素（也就是 <code>i</code> 位置当前的元素）处于正确的位置，所以我们需要再对 <code>i</code> 位置判断一次。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findRepeatNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;nums)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] != i) &#123;<br>                <span class="hljs-keyword">if</span> (nums[i] == nums[nums[i]])<br>                    <span class="hljs-keyword">return</span> nums[i];<br>                <span class="hljs-built_in">swap</span>(nums[i], nums[nums[i]]);<br>                <span class="hljs-comment">//i不增加，对当前位置再判断一次</span><br>                i--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="剑指-offer-53-i-在排序数组中查找数字-i"><a class="markdownIt-Anchor" href="#剑指-offer-53-i-在排序数组中查找数字-i"></a> <a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/">剑指 Offer 53 - I. 在排序数组中查找数字 I</a></h2><h3 id="描述-2"><a class="markdownIt-Anchor" href="#描述-2"></a> 描述</h3><p>统计一个数字在排序数组中出现的次数。</p><p><strong>示例 1</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [5,7,7,8,8,10], target = 8</span><br><span class="hljs-section">输出: 2</span><br></code></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [5,7,7,8,8,10], target = 6</span><br><span class="hljs-section">输出: 0</span><br></code></pre></td></tr></table></figure><p><strong>提示</strong></p><ul><li>0 &lt;= nums.length &lt;= 10^5</li><li>-10^9 &lt;= nums[i] &lt;= 10^9</li><li>nums 是一个非递减数组</li><li>-10^9 &lt;= target &lt;= 10^9</li></ul><p><strong>注意</strong></p><p>本题与主站 34 题相同（仅返回值不同）：<a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/</a></p><h3 id="题解-2"><a class="markdownIt-Anchor" href="#题解-2"></a> 题解</h3><p>两次二分，分别找 <code>target</code> 的上界和下界，返回差值。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, mid;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            mid = (left + right) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &lt; target)<br>                left = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> lBound = left;<br>        left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            mid = (left + right) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &lt;= target)<br>                left = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> rBound = left;<br>        <span class="hljs-keyword">return</span> rBound - lBound;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="剑指-offer-53-ii-0~n-1中缺失的数字"><a class="markdownIt-Anchor" href="#剑指-offer-53-ii-0~n-1中缺失的数字"></a> <a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/">剑指 Offer 53 - II. 0～n-1中缺失的数字</a></h2><h3 id="描述-3"><a class="markdownIt-Anchor" href="#描述-3"></a> 描述</h3><p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p><p><strong>示例 1</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [0,1,3]</span><br><span class="hljs-section">输出: 2</span><br></code></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入: [<span class="hljs-number">0,1,2,3</span>,<span class="hljs-number">4,5,6,7</span>,<span class="hljs-number">9</span>]<br>输出: <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p><strong>限制</strong></p><p>1 &lt;= 数组长度 &lt;= 10000</p><h3 id="题解-3"><a class="markdownIt-Anchor" href="#题解-3"></a> 题解</h3><p>排序数组，优先使用二分法。</p><p>思考缺失的位置有什么特殊点（可比较点）。</p><p>缺失的位置左边都应是 <code>nums[i]=i</code> ，所以我们直接寻找该序列的最右端，最右端右侧的位置就是缺失的位置。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">missingNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, mid;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            mid = (left + right) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] == mid)<br>                left = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>剑指Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试算法题-02</title>
    <link href="/p/9230/"/>
    <url>/p/9230/</url>
    
    <content type="html"><![CDATA[<p>面试算法题-02</p><span id="more"></span><h2 id="剑指-offer-52-两个链表的第一个公共节点"><a class="markdownIt-Anchor" href="#剑指-offer-52-两个链表的第一个公共节点"></a> <a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">剑指 Offer 52. 两个链表的第一个公共节点</a></h2><h3 id="描述"><a class="markdownIt-Anchor" href="#描述"></a> 描述</h3><p>输入两个链表，找出它们的第一个公共节点。</p><p>如下面的两个链表：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" alt="img" /></p><p>在节点 c1 开始相交。</p><p><strong>示例 1</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" alt="img" /></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">intersectVal</span> = <span class="hljs-number">8</span>, <span class="hljs-attr">listA</span> = [<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], <span class="hljs-attr">listB</span> = [<span class="hljs-number">5</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], <span class="hljs-attr">skipA</span> = <span class="hljs-number">2</span>, <span class="hljs-attr">skipB</span> = <span class="hljs-number">3</span><br>输出：Reference of the node <span class="hljs-keyword">with</span> <span class="hljs-attr">value</span> = <span class="hljs-number">8</span><br>输入解释：相交节点的值为 <span class="hljs-number">8</span> （注意，如果两个列表相交则不能为 <span class="hljs-number">0</span>）。从各自的表头开始算起，链表 A 为 [<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]，链表 B 为 [<span class="hljs-number">5</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]。在 A 中，相交节点前有 <span class="hljs-number">2</span> 个节点；在 B 中，相交节点前有 <span class="hljs-number">3</span> 个节点。<br></code></pre></td></tr></table></figure><p><strong>示例 2</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_2.png" alt="img" /></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">intersectVal</span> = <span class="hljs-number">2</span>, <span class="hljs-attr">listA</span> = [<span class="hljs-number">0</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>], <span class="hljs-attr">listB</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>], <span class="hljs-attr">skipA</span> = <span class="hljs-number">3</span>, <span class="hljs-attr">skipB</span> = <span class="hljs-number">1</span><br>输出：Reference of the node <span class="hljs-keyword">with</span> <span class="hljs-attr">value</span> = <span class="hljs-number">2</span><br>输入解释：相交节点的值为 <span class="hljs-number">2</span> （注意，如果两个列表相交则不能为 <span class="hljs-number">0</span>）。从各自的表头开始算起，链表 A 为 [<span class="hljs-number">0</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]，链表 B 为 [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]。在 A 中，相交节点前有 <span class="hljs-number">3</span> 个节点；在 B 中，相交节点前有 <span class="hljs-number">1</span> 个节点。<br></code></pre></td></tr></table></figure><p><strong>示例 3</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png" alt="img" /></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">intersectVal</span> = <span class="hljs-number">0</span>, <span class="hljs-attr">listA</span> = [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>], <span class="hljs-attr">listB</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>], <span class="hljs-attr">skipA</span> = <span class="hljs-number">3</span>, <span class="hljs-attr">skipB</span> = <span class="hljs-number">2</span><br>输出：<span class="hljs-literal">null</span><br>输入解释：从各自的表头开始算起，链表 A 为 [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>]，链表 B 为 [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>]。由于这两个链表不相交，所以 intersectVal 必须为 <span class="hljs-number">0</span>，而 skipA 和 skipB 可以是任意值。<br>解释：这两个链表不相交，因此返回 <span class="hljs-literal">null</span>。<br></code></pre></td></tr></table></figure><p><strong>注意</strong></p><ul><li>如果两个链表没有交点，返回 null.</li><li>在返回结果后，两个链表仍须保持原有的结构。</li><li>可假定整个链表结构中没有循环。</li><li>程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</li><li>本题与主站 160 题相同：<a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">https://leetcode-cn.com/problems/intersection-of-two-linked-lists/</a></li></ul><h3 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h3><p>本题运用双指针。</p><blockquote><p>怎么让两个速度相同，跑道不同的人相遇？</p><p>答案是交换他们的跑道</p></blockquote><p>我们让两个指针分别从两条链表的头开始向后走，当其中一个链表走到尾端（即指向为空）时，让其从另一个链表头开始再走一遍，直到俩链表相遇或是都为空。</p><p>假设A链表长为A，B链表长为B，公共区域长为C。</p><p>从A出发的指针pA走完时，长度为A+C，相对的，pB走完时长度为B+C。</p><p>这时交换他们的跑道，pA走A+C+B，pB走B+C+A，因他们速度相同，要么在交点相遇，要么都走到空节点，此时返回他们指向的节点即可。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>        ListNode *pA = headA, *pB = headB;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">//相遇或均为空时，返回结果</span><br>            <span class="hljs-keyword">if</span> (pA == <span class="hljs-literal">NULL</span> &amp;&amp; pB == <span class="hljs-literal">NULL</span> || pA == pB) &#123;<br>                <span class="hljs-keyword">return</span> pA;<br>            &#125;<br>            <span class="hljs-comment">//如果pA走到尽头，从B链表再开始</span><br>            <span class="hljs-keyword">if</span> (pA == <span class="hljs-literal">NULL</span>)<br>                pA = headB;<br>            <span class="hljs-keyword">else</span><br>                pA = pA-&gt;next;<br>            <span class="hljs-comment">//如果pB走到尽头，从A链表再开始</span><br>            <span class="hljs-keyword">if</span> (pB == <span class="hljs-literal">NULL</span>)<br>                pB = headA;<br>            <span class="hljs-keyword">else</span><br>                pB = pB-&gt;next;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="反转url"><a class="markdownIt-Anchor" href="#反转url"></a> 反转URL</h2><h3 id="描述-2"><a class="markdownIt-Anchor" href="#描述-2"></a> 描述</h3><p>将URL反转</p><p><strong>示例</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：<span class="hljs-string">&quot;www.baidu.com&quot;</span><br>输出：<span class="hljs-string">&quot;www.udiab.moc&quot;</span><br></code></pre></td></tr></table></figure><h3 id="题解-2"><a class="markdownIt-Anchor" href="#题解-2"></a> 题解</h3><p>遍历，储存遇到的上一个标识点。</p><p>将上一个标识点与当前标识点中间区域反转。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">reverseURL</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        string ans = s;<br>        <span class="hljs-keyword">int</span> pre = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ans.<span class="hljs-built_in">length</span>(); ++i) &#123;<br>            <span class="hljs-keyword">if</span> (ans[i] == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>                <span class="hljs-built_in">reverse</span>(ans.<span class="hljs-built_in">begin</span>() + pre, ans.<span class="hljs-built_in">begin</span>() + i);<br>                pre = i + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//最后将顶级域名部分反转</span><br>        <span class="hljs-built_in">reverse</span>(ans.<span class="hljs-built_in">begin</span>() + pre, ans.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="145-二叉树的后序遍历"><a class="markdownIt-Anchor" href="#145-二叉树的后序遍历"></a> <a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a></h2><h3 id="描述-3"><a class="markdownIt-Anchor" href="#描述-3"></a> 描述</h3><p>给你一棵二叉树的根节点 root ，返回其节点值的 后序遍历 。</p><p><strong>示例 1</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/08/28/pre1.jpg" alt="img" /></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[1,null,2,3]</span><br>输出：<span class="hljs-comment">[3,2,1]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[1]</span><br>输出：<span class="hljs-comment">[1]</span><br></code></pre></td></tr></table></figure><p><strong>提示</strong></p><ul><li>树中节点的数目在范围 [0, 100] 内</li><li>-100 &lt;= Node.val &lt;= 100</li></ul><p><strong>进阶</strong></p><p>递归算法很简单，你可以通过迭代算法完成吗？</p><h3 id="题解-3"><a class="markdownIt-Anchor" href="#题解-3"></a> 题解</h3><p>递归较简单，这里我们用迭代。顺带复习一下DFS。</p><p>使用栈储存节点，map或者set储存已访问的节点。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    stack&lt;TreeNode *&gt; stack;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; ans;<br>    map&lt;TreeNode *, <span class="hljs-keyword">bool</span>&gt; isVisited;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root)<br>            <span class="hljs-keyword">return</span> ans;<br>        stack.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!stack.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-comment">//标记访问到的节点</span><br>            isVisited[stack.<span class="hljs-built_in">top</span>()] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">//非空且未访问过，入栈</span><br>            <span class="hljs-keyword">if</span> (stack.<span class="hljs-built_in">top</span>()-&gt;left &amp;&amp; !isVisited.<span class="hljs-built_in">count</span>(stack.<span class="hljs-built_in">top</span>()-&gt;left)) &#123;<br>                stack.<span class="hljs-built_in">push</span>(stack.<span class="hljs-built_in">top</span>()-&gt;left);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">//同上</span><br>            <span class="hljs-keyword">if</span> (stack.<span class="hljs-built_in">top</span>()-&gt;right &amp;&amp; !isVisited.<span class="hljs-built_in">count</span>(stack.<span class="hljs-built_in">top</span>()-&gt;right)) &#123;<br>                stack.<span class="hljs-built_in">push</span>(stack.<span class="hljs-built_in">top</span>()-&gt;right);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">//因为是后序，最后输出值并出栈</span><br>            ans.<span class="hljs-built_in">push_back</span>(stack.<span class="hljs-built_in">top</span>()-&gt;val);<br>            stack.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="102-二叉树的层序遍历"><a class="markdownIt-Anchor" href="#102-二叉树的层序遍历"></a> <a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h2><h3 id="描述-4"><a class="markdownIt-Anchor" href="#描述-4"></a> 描述</h3><p>给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。</p><p><strong>示例 1</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" alt="img" /></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[3,9,20,null,null,15,7]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[3]</span>,<span class="hljs-comment">[9,20]</span>,<span class="hljs-comment">[15,7]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：root = [<span class="hljs-number">1</span>]<br>输出：<span class="hljs-string">[[1]]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>提示</strong></p><ul><li>树中节点数目在范围 [0, 2000] 内</li><li>-1000 &lt;= Node.val &lt;= 1000</li></ul><h3 id="题解-4"><a class="markdownIt-Anchor" href="#题解-4"></a> 题解</h3><p>层序遍历我们一般使用队列，从左向右遍历时，将下一层的节点加入队列。</p><p>此题需要我们进行分层，我们便在while语句中进一步用for来细化各层，将开启每一层时队列的大小当作循环条件。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    queue&lt;TreeNode *&gt; queue;<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; ans;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode *root) &#123;<br>        <span class="hljs-keyword">if</span> (!root)<br>            <span class="hljs-keyword">return</span> ans;<br>        queue.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!queue.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-comment">//保存该层的大小</span><br>            <span class="hljs-keyword">int</span> levelSize = queue.<span class="hljs-built_in">size</span>();<br>            ans.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;());<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; levelSize; ++i) &#123;<br>                TreeNode *node = queue.<span class="hljs-built_in">front</span>();<br>                ans.<span class="hljs-built_in">back</span>().<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>                <span class="hljs-keyword">if</span> (node-&gt;left)<br>                    queue.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span> (node-&gt;right)<br>                    queue.<span class="hljs-built_in">push</span>(node-&gt;right);<br>                queue.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="找出每一个数后面第一个比它大的数"><a class="markdownIt-Anchor" href="#找出每一个数后面第一个比它大的数"></a> 找出每一个数后面第一个比它大的数</h2><h3 id="描述-5"><a class="markdownIt-Anchor" href="#描述-5"></a> 描述</h3><p>给定一个整型数组，数组元素随机无序的，要求打印出所有元素右边第一个大于该元素的值。</p><p><strong>示例 1</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：<span class="hljs-string">[1,5,3,6,4,8,9,10]</span><br>输出：<span class="hljs-string">[5, 6, 6, 8, 8, 9, 10, -1]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：[8, 2, 5, 4, 3, 9, 7, 2, 5]<br>输出：[9, 5, 9, 9, 9, <span class="hljs-string">-1</span>, <span class="hljs-string">-1</span>, 5, <span class="hljs-string">-1</span>]<br></code></pre></td></tr></table></figure><h3 id="题解-5"><a class="markdownIt-Anchor" href="#题解-5"></a> 题解</h3><p>单调栈。</p><p>单调栈的核心在于，我们想要什么时候弹出元素。</p><p>本题中，我们希望当新元素比栈顶元素大时，弹出栈顶，保存信息。所以我们采用单调减的栈。</p><p>在本题中保存索引下标。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">firstLargeNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; nums)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(nums.size())</span></span>;<br>        stack&lt;<span class="hljs-keyword">int</span>&gt; stack;<br>        stack.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; nums[stack.<span class="hljs-built_in">top</span>()]) &#123;<br>                <span class="hljs-comment">//比栈顶大时，弹出并处理元素，直到恢复单调</span><br>                <span class="hljs-keyword">while</span> (!stack.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i] &gt; nums[stack.<span class="hljs-built_in">top</span>()]) &#123;<br>                    ans[stack.<span class="hljs-built_in">top</span>()] = nums[i];<br>                    stack.<span class="hljs-built_in">pop</span>();<br>                &#125;<br>                stack.<span class="hljs-built_in">push</span>(i);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                stack.<span class="hljs-built_in">push</span>(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//栈中还有剩余元素，说明这些元素右边没有比它大的元素，按顺序弹出处理就好</span><br>        <span class="hljs-keyword">while</span> (!stack.<span class="hljs-built_in">empty</span>()) &#123;<br>            ans[stack.<span class="hljs-built_in">top</span>()] = <span class="hljs-number">-1</span>;<br>            stack.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>面试算法题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer Day-03</title>
    <link href="/p/5f6b/"/>
    <url>/p/5f6b/</url>
    
    <content type="html"><![CDATA[<p>剑指Offer Day-03</p><span id="more"></span><h2 id="剑指-offer-05-替换空格"><a class="markdownIt-Anchor" href="#剑指-offer-05-替换空格"></a> <a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">剑指 Offer 05. 替换空格</a></h2><h3 id="描述"><a class="markdownIt-Anchor" href="#描述"></a> 描述</h3><p>请实现一个函数，把字符串 s 中的每个空格替换成&quot;%20&quot;。</p><p><strong>示例 1</strong></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl">输入：s = <span class="hljs-string">&quot;We are happy.&quot;</span><br>输出：<span class="hljs-string">&quot;We%20are%20happy.&quot;</span><br></code></pre></td></tr></table></figure><p><strong>限制</strong></p><p>0 &lt;= s 的长度 &lt;= 10000</p><h3 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h3><p>没啥好说的，直接遍历</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">replaceSpace</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        string ans;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ch:s) &#123;<br>            <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;%&#x27;</span>);<br>                ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;2&#x27;</span>);<br>                ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;0&#x27;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(ch);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="剑指-offer-58-ii-左旋转字符串"><a class="markdownIt-Anchor" href="#剑指-offer-58-ii-左旋转字符串"></a> <a href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">剑指 Offer 58 - II. 左旋转字符串</a></h2><h3 id="描述-2"><a class="markdownIt-Anchor" href="#描述-2"></a> 描述</h3><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串&quot;abcdefg&quot;和数字2，该函数将返回左旋转两位得到的结果&quot;cdefgab&quot;。</p><p><strong>示例 1</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">s</span> = <span class="hljs-string">&quot;abcdefg&quot;</span>, <span class="hljs-attr">k</span> = <span class="hljs-number">2</span><br>输出: <span class="hljs-string">&quot;cdefgab&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">s</span> = <span class="hljs-string">&quot;lrloseumgh&quot;</span>, <span class="hljs-attr">k</span> = <span class="hljs-number">6</span><br>输出: <span class="hljs-string">&quot;umghlrlose&quot;</span><br></code></pre></td></tr></table></figure><p><strong>限制</strong></p><p>1 &lt;= k &lt; s.length &lt;= 10000</p><h3 id="题解-2"><a class="markdownIt-Anchor" href="#题解-2"></a> 题解</h3><p>使用string类的substr()方法，直接拼接字符串。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">reverseLeftWords</span><span class="hljs-params">(string s, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        string ans;<br>        ans = s.<span class="hljs-built_in">substr</span>(n);<br>        ans += s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, n);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>剑指Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer Day-02 链表（简单）</title>
    <link href="/p/9faa/"/>
    <url>/p/9faa/</url>
    
    <content type="html"><![CDATA[<p>剑指Offer Day-02 链表（简单）</p><span id="more"></span><h2 id="剑指-offer-06-从尾到头打印链表"><a class="markdownIt-Anchor" href="#剑指-offer-06-从尾到头打印链表"></a> <a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">剑指 Offer 06. 从尾到头打印链表</a></h2><h3 id="描述"><a class="markdownIt-Anchor" href="#描述"></a> 描述</h3><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><p><strong>示例 1</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1,3,2]</span><br>输出：<span class="hljs-comment">[2,3,1]</span><br></code></pre></td></tr></table></figure><p><strong>限制</strong></p><p>0 &lt;= 链表长度 &lt;= 10000</p><h3 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h3><p>用栈倒一下顺序</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    stack&lt;<span class="hljs-keyword">int</span>&gt; stack;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">reversePrint</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; ans;<br>        ListNode *p = head;<br>        <span class="hljs-keyword">if</span> (!p) &#123;<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (p) &#123;<br>            stack.<span class="hljs-built_in">push</span>(p-&gt;val);<br>            p = p-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (!stack.<span class="hljs-built_in">empty</span>()) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(stack.<span class="hljs-built_in">top</span>());<br>            stack.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="剑指-offer-24-反转链表"><a class="markdownIt-Anchor" href="#剑指-offer-24-反转链表"></a> <a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/">剑指 Offer 24. 反转链表</a></h2><h3 id="描述-2"><a class="markdownIt-Anchor" href="#描述-2"></a> 描述</h3><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p><p><strong>示例</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;NULL<br>输出: <span class="hljs-number">5</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">1</span>-&gt;NULL<br></code></pre></td></tr></table></figure><p><strong>限制</strong></p><p>0 &lt;= 节点个数 &lt;= 5000</p><h3 id="题解-2"><a class="markdownIt-Anchor" href="#题解-2"></a> 题解</h3><p>运用迭代，储存当前节点的next和prev。</p><p>prev用于反转链表，next用于将当前指针向下迭代。</p><p>每一次迭代，反转p和prev之间的指针。</p><p>由于头指针需要指向NULL，所以我们一开始将prev设为NULL，将p指向头指针。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        ListNode *p = head, *prev = <span class="hljs-literal">NULL</span>, *next;<br>        <span class="hljs-keyword">while</span> (p) &#123;<br>            next = p-&gt;next;<br>            p-&gt;next = prev;<br>            prev = p;<br>            p = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> prev;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="剑指-offer-35-复杂链表的复制"><a class="markdownIt-Anchor" href="#剑指-offer-35-复杂链表的复制"></a> <a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/">剑指 Offer 35. 复杂链表的复制</a></h2><h3 id="描述-3"><a class="markdownIt-Anchor" href="#描述-3"></a> 描述</h3><p>请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。</p><p><strong>示例 1</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e1.png" alt="img" /></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[<span class="hljs-comment">[7,null]</span>,<span class="hljs-comment">[13,0]</span>,<span class="hljs-comment">[11,4]</span>,<span class="hljs-comment">[10,2]</span>,<span class="hljs-comment">[1,0]</span>]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[7,null]</span>,<span class="hljs-comment">[13,0]</span>,<span class="hljs-comment">[11,4]</span>,<span class="hljs-comment">[10,2]</span>,<span class="hljs-comment">[1,0]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e2.png" alt="img" /></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：head = <span class="hljs-string">[[1,1],[2,1]]</span><br>输出：<span class="hljs-string">[[1,1],[2,1]]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e3.png" alt="img" /></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：head = <span class="hljs-string">[[3,null],[3,0],[3,null]]</span><br>输出：<span class="hljs-string">[[3,null],[3,0],[3,null]]</span><br></code></pre></td></tr></table></figure><p><strong>示例 4</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br>解释：给定的链表为空（空指针），因此返回 null。<br></code></pre></td></tr></table></figure><p><strong>提示</strong></p><ul><li><p>-10000 &lt;= Node.val &lt;= 10000</p></li><li><p>Node.random 为空（null）或指向链表中的节点。</p></li><li><p>节点数目不超过 1000 。</p></li></ul><h3 id="题解-3"><a class="markdownIt-Anchor" href="#题解-3"></a> 题解</h3><p>我们使用递归求解此题，每当创建一个节点时，递归创建该节点的next和random节点。</p><p>我们用哈希表记录每一个节点对应新节点的创建情况。</p><p>我们需要首先检查当前节点是否被拷贝过，如果已经拷贝过，我们可以直接从哈希表中取出拷贝后的节点的指针并返回。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">// Definition for a Node.</span><br><span class="hljs-comment">class Node &#123;</span><br><span class="hljs-comment">public:  </span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    Node* next;</span><br><span class="hljs-comment">    Node* random;</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    Node(int _val) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">        next = NULL;</span><br><span class="hljs-comment">        random = NULL;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    map&lt;Node *, Node *&gt; map;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Node *<span class="hljs-title">copyRandomList</span><span class="hljs-params">(Node *head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!head) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!map.<span class="hljs-built_in">count</span>(head)) &#123;<br>            <span class="hljs-comment">//如果节点不存在，创建节点并加到map中</span><br>            Node *node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(head-&gt;val);<br>            map[head] = node;<br>            <span class="hljs-comment">//递归创建next</span><br>            node-&gt;next = <span class="hljs-built_in">copyRandomList</span>(head-&gt;next);<br>            <span class="hljs-comment">//递归创建random</span><br>            node-&gt;random = <span class="hljs-built_in">copyRandomList</span>(head-&gt;random);<br>        &#125;<br>        <span class="hljs-keyword">return</span> map[head];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>剑指Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试算法题-01</title>
    <link href="/p/9370/"/>
    <url>/p/9370/</url>
    
    <content type="html"><![CDATA[<p>面试算法题-01</p><span id="more"></span><h2 id="数组中最后负数与最前正数"><a class="markdownIt-Anchor" href="#数组中最后负数与最前正数"></a> 数组中最后负数与最前正数</h2><h3 id="描述"><a class="markdownIt-Anchor" href="#描述"></a> 描述</h3><p>一个数组中间部分都是0，前半部分全是负数，后半部分都是正数，要求时间复杂度尽量低的情况下，查找最后一个负数和第一个正数。</p><h3 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h3><p>题目中描述的数组，求解结果是与0比较的，可以看做是有序的，分别二分查找，时间复杂度可以达到log(n)</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">BinSearch</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;nums)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">empty</span>() || nums[<span class="hljs-number">0</span>] &gt;= <span class="hljs-number">0</span> || nums[nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>] &lt;= <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;;<br>    <span class="hljs-keyword">int</span> positive = <span class="hljs-number">0</span>, negative = <span class="hljs-number">0</span>, mid, left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        mid = (left + right) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &gt;= <span class="hljs-number">0</span>)<br>            right = mid - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span><br>            left = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; ans;<br>    ans.<span class="hljs-built_in">push_back</span>(nums[right]);<br>    right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        mid = (left + right) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt;= <span class="hljs-number">0</span>)<br>            left = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span><br>            right = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>    ans.<span class="hljs-built_in">push_back</span>(nums[left]);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-offer-ii-046-二叉树的右侧视图"><a class="markdownIt-Anchor" href="#剑指-offer-ii-046-二叉树的右侧视图"></a> <a href="https://leetcode-cn.com/problems/WNC0Lk/">剑指 Offer II 046. 二叉树的右侧视图</a></h2><h3 id="描述-2"><a class="markdownIt-Anchor" href="#描述-2"></a> 描述</h3><p>给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><p><strong>示例 1</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/14/tree.jpg" alt="img" /></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">5</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">4</span>]<br>输出: [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: <span class="hljs-comment">[1,null,3]</span><br>输出: <span class="hljs-comment">[1,3]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: <span class="hljs-comment">[]</span><br>输出: <span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>提示</strong></p><ul><li><p>二叉树的节点个数的范围是 [0,100]</p></li><li><p>-100 &lt;= Node.val &lt;= 100</p></li></ul><h3 id="题解-2"><a class="markdownIt-Anchor" href="#题解-2"></a> 题解</h3><p>右视图需要的是每一行最右侧的元素，而如果用DFS来遍历，并且后访问右节点，永远是该行最右侧的节点最后被访问。</p><p>所以我们可以直接用数组保存每行最后访问到的节点</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">rightSideView</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; ans;<br>        <span class="hljs-built_in">preOrder</span>(root, <span class="hljs-number">0</span>, ans);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(TreeNode *root, <span class="hljs-keyword">int</span> depth, vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;ans)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (depth == ans.<span class="hljs-built_in">size</span>())<br>            ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>        ans[depth] = root-&gt;val;<br>        depth++;<br>        <span class="hljs-built_in">preOrder</span>(root-&gt;left, depth, ans);<br>        <span class="hljs-built_in">preOrder</span>(root-&gt;right, depth, ans);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="146-lru-缓存"><a class="markdownIt-Anchor" href="#146-lru-缓存"></a> <a href="https://leetcode-cn.com/problems/lru-cache/">146. LRU 缓存</a></h2><h3 id="描述-3"><a class="markdownIt-Anchor" href="#描述-3"></a> 描述</h3><p>请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。</p><p>实现 LRUCache 类：</p><ul><li>LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存</li><li>int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。</li><li>void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。</li></ul><p>函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。</p><p><strong>示例</strong></p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs haxe">输入<br>[<span class="hljs-string">&quot;LRUCache&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>]<br>[[<span class="hljs-number">2</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">1</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">2</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">1</span>], [<span class="hljs-number">3</span>], [<span class="hljs-number">4</span>]]<br>输出<br>[<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">-1</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br><br>解释<br>LRUCache lRUCache = <span class="hljs-keyword">new</span> <span class="hljs-type">LRUCache</span>(<span class="hljs-number">2</span>);<br>lRUCache.put(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// 缓存是 &#123;1=1&#125;</span><br>lRUCache.put(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// 缓存是 &#123;1=1, 2=2&#125;</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">1</span>);    <span class="hljs-comment">// 返回 1</span><br>lRUCache.put(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// 该操作会使得关键字 2 作废，缓存是 &#123;1=1, 3=3&#125;</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">2</span>);    <span class="hljs-comment">// 返回 -1 (未找到)</span><br>lRUCache.put(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// 该操作会使得关键字 1 作废，缓存是 &#123;4=4, 3=3&#125;</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">1</span>);    <span class="hljs-comment">// 返回 -1 (未找到)</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">3</span>);    <span class="hljs-comment">// 返回 3</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">4</span>);    <span class="hljs-comment">// 返回 4</span><br></code></pre></td></tr></table></figure><p><strong>提示</strong></p><p>1 &lt;= capacity &lt;= 3000<br />0 &lt;= key &lt;= 10000<br />0 &lt;= value &lt;= 105<br />最多调用 2 * 105 次 get 和 put</p><h3 id="题解-3"><a class="markdownIt-Anchor" href="#题解-3"></a> 题解</h3><p>LRU是最近最少使用算法，即扔掉最长时间未被使用的元素。我们不仅需要使用map存储键值对，还需要维护一个可更新使用频次的数据结构。</p><p>在这里我们使用双向链表，在每次更新某元素频次时，将其移动到链表头位置，所以链表的尾端就是最长时间未被使用的元素。</p><p>moveToHead直接实现较为复杂，所以我们可以将它拆分成removeNode和addToHead两部分，且两部分都可复用。</p><p>因为我们同时维护两个数据结构，所以不在removeTail中直接释放掉元素，需要拿到它的返回值以同步更新map。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>        <span class="hljs-keyword">int</span> key, value;<br>        Node *prev;<br>        Node *next;<br><br>        <span class="hljs-built_in">Node</span>() : <span class="hljs-built_in">key</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">value</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">prev</span>(<span class="hljs-literal">NULL</span>), <span class="hljs-built_in">next</span>(<span class="hljs-literal">NULL</span>) &#123;&#125;<br><br>        <span class="hljs-built_in">Node</span>(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value) : <span class="hljs-built_in">key</span>(key), <span class="hljs-built_in">value</span>(value), <span class="hljs-built_in">prev</span>(<span class="hljs-literal">NULL</span>), <span class="hljs-built_in">next</span>(<span class="hljs-literal">NULL</span>) &#123;&#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">typedef</span> Node *PtrToNode;<br>    map&lt;<span class="hljs-keyword">int</span>, PtrToNode&gt; map;<br>    PtrToNode head, tail;<br>    <span class="hljs-keyword">int</span> size, cap;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LRUCache</span>(<span class="hljs-keyword">int</span> capacity) &#123;<br>        head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br>        tail = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br>        head-&gt;next = tail;<br>        tail-&gt;prev = head;<br>        size = <span class="hljs-number">0</span>;<br>        cap = capacity;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!map.<span class="hljs-built_in">count</span>(key)) &#123;<br>            <span class="hljs-comment">//key不存在</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-comment">//如果key存在</span><br>        PtrToNode p = map[key];<br>        <span class="hljs-built_in">moveToHead</span>(p);<br>        <span class="hljs-keyword">return</span> p-&gt;value;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!map.<span class="hljs-built_in">count</span>(key)) &#123;<br>            <span class="hljs-comment">//key不存在，向map和链表中添加元素</span><br>            PtrToNode node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(key, value);<br>            map[key] = node;<br>            <span class="hljs-built_in">addToHead</span>(node);<br>            size++;<br>            <span class="hljs-keyword">if</span> (size &gt; cap) &#123;<br>                <span class="hljs-comment">//超过容量删除缓存</span><br>                PtrToNode removed = <span class="hljs-built_in">removeTail</span>();<br>                map.<span class="hljs-built_in">erase</span>(removed-&gt;key);<br>                <span class="hljs-keyword">delete</span> removed;<br>                size--;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//key存在,覆盖value</span><br>            PtrToNode node = map[key];<br>            node-&gt;value = value;<br>            <span class="hljs-built_in">moveToHead</span>(node);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">removeNode</span><span class="hljs-params">(PtrToNode node)</span> </span>&#123;<br>        node-&gt;prev-&gt;next = node-&gt;next;<br>        node-&gt;next-&gt;prev = node-&gt;prev;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addToHead</span><span class="hljs-params">(PtrToNode node)</span> </span>&#123;<br>        head-&gt;next-&gt;prev = node;<br>        node-&gt;next = head-&gt;next;<br>        head-&gt;next = node;<br>        node-&gt;prev = head;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">moveToHead</span><span class="hljs-params">(PtrToNode node)</span> </span>&#123;<br>        <span class="hljs-built_in">removeNode</span>(node);<br>        <span class="hljs-built_in">addToHead</span>(node);<br>    &#125;<br><br>    <span class="hljs-function">PtrToNode <span class="hljs-title">removeTail</span><span class="hljs-params">()</span> </span>&#123;<br>        PtrToNode removed = tail-&gt;prev;<br>        <span class="hljs-built_in">removeNode</span>(tail-&gt;prev);<br>        <span class="hljs-keyword">return</span> removed;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your LRUCache object will be instantiated and called as such:</span><br><span class="hljs-comment"> * LRUCache* obj = new LRUCache(capacity);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;get(key);</span><br><span class="hljs-comment"> * obj-&gt;put(key,value);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="98-验证二叉搜索树"><a class="markdownIt-Anchor" href="#98-验证二叉搜索树"></a> <a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h2><h3 id="描述-4"><a class="markdownIt-Anchor" href="#描述-4"></a> 描述</h3><p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</p><p>有效 二叉搜索树定义如下：</p><ul><li>节点的左子树只包含 小于 当前节点的数。</li><li>节点的右子树只包含 大于 当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p><strong>示例 1</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>]<br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>]<br>输出：<span class="hljs-literal">false</span><br>解释：根节点的值是 <span class="hljs-number">5</span> ，但是右子节点的值是 <span class="hljs-number">4</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示</strong></p><ul><li>树中节点数目范围在[1, 104] 内</li><li>-2^31 &lt;= Node.val &lt;= 2^23 - 1</li></ul><h3 id="题解-4"><a class="markdownIt-Anchor" href="#题解-4"></a> 题解</h3><p>根据二叉搜索树性质，我们知道中序遍历二叉搜索树时，一定会得到升序序列。</p><p>这里我们维护一个pre变量，来将遍历到的元素与上一个元素比较，判断是否为升序</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> pre = LONG_LONG_MIN;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">inOrder</span>(root);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">bool</span> left = <span class="hljs-built_in">inOrder</span>(root-&gt;left);<br>        <span class="hljs-keyword">if</span> (root-&gt;val &lt;= pre)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        pre = root-&gt;val;<br>        <span class="hljs-keyword">bool</span> right = <span class="hljs-built_in">inOrder</span>(root-&gt;right);<br>        <span class="hljs-keyword">return</span> left &amp;&amp; right;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="剑指-offer-38-字符串的排列"><a class="markdownIt-Anchor" href="#剑指-offer-38-字符串的排列"></a> <a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/">剑指 Offer 38. 字符串的排列</a></h2><h3 id="描述-5"><a class="markdownIt-Anchor" href="#描述-5"></a> 描述</h3><p>输入一个字符串，打印出该字符串中字符的所有排列。</p><p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p><p><strong>示例</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;abc&quot;</span><br>输出：[<span class="hljs-string">&quot;abc&quot;</span>,<span class="hljs-string">&quot;acb&quot;</span>,<span class="hljs-string">&quot;bac&quot;</span>,<span class="hljs-string">&quot;bca&quot;</span>,<span class="hljs-string">&quot;cab&quot;</span>,<span class="hljs-string">&quot;cba&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>限制</strong></p><p>1 &lt;= s 的长度 &lt;= 8</p><h3 id="题解-5"><a class="markdownIt-Anchor" href="#题解-5"></a> 题解</h3><p>这道题我们采用回溯，也叫深度优先搜索。</p><p>从第一位开始，首先与包括自己的后面所有字符交换，确定了第一位。</p><p>确定第一位之后，向更深一层搜索，即向第二位搜索。将其与包括自己的后面所有字符交换，确定第二位。</p><p>以此递归，直到所有位被确定。</p><p><strong>注意</strong></p><ul><li>交换时，可用 set 来保存每一层待交换的字符，遇到重复时可剪枝。跳过这个字符继续交换下一个字符。</li><li>在交换完毕并完成下一层的搜索后，需要恢复交换。以免影响相邻层或是下一次交换。</li></ul><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    vector&lt;string&gt; ans;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">permutation</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(s, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(string s, <span class="hljs-keyword">int</span> depth)</span> </span>&#123;<br>        <span class="hljs-comment">//到达最后一层，直接返回</span><br>        <span class="hljs-keyword">if</span> (depth == s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(s);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//使用set去重</span><br>        set&lt;<span class="hljs-keyword">char</span>&gt; set;<br>        <span class="hljs-comment">//从x位开始，分别与后面交换</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = depth; i &lt; s.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-comment">//如果待交换的字符重复，剪枝</span><br>            <span class="hljs-keyword">if</span> (set.<span class="hljs-built_in">count</span>(s[i]) &gt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            set.<span class="hljs-built_in">insert</span>(s[i]);<br>            <span class="hljs-comment">//交换</span><br>            <span class="hljs-built_in">swap</span>(s[i], s[depth]);<br>            <span class="hljs-comment">//搜索下一层</span><br>            <span class="hljs-built_in">dfs</span>(s, depth + <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//恢复交换，避免对s的修改影响相邻层或是下一次交换</span><br>            <span class="hljs-built_in">swap</span>(s[i], s[depth]);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>面试算法题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer Day-01 栈与队列（简单）</title>
    <link href="/p/9eea/"/>
    <url>/p/9eea/</url>
    
    <content type="html"><![CDATA[<p>剑指Offer Day-01 栈与队列（简单）</p><span id="more"></span><h2 id="剑指-offer-09-用两个栈实现队列"><a class="markdownIt-Anchor" href="#剑指-offer-09-用两个栈实现队列"></a> <a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">剑指 Offer 09. 用两个栈实现队列</a></h2><h3 id="描述"><a class="markdownIt-Anchor" href="#描述"></a> 描述</h3><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p><p><strong>示例 1</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：<br>[<span class="hljs-string">&quot;CQueue&quot;</span>,<span class="hljs-string">&quot;appendTail&quot;</span>,<span class="hljs-string">&quot;deleteHead&quot;</span>,<span class="hljs-string">&quot;deleteHead&quot;</span>]<br>[[],[<span class="hljs-number">3</span>],[],[]]<br>输出：[null,null,<span class="hljs-number">3</span>,<span class="hljs-number">-1</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：<br>[<span class="hljs-string">&quot;CQueue&quot;</span>,<span class="hljs-string">&quot;deleteHead&quot;</span>,<span class="hljs-string">&quot;appendTail&quot;</span>,<span class="hljs-string">&quot;appendTail&quot;</span>,<span class="hljs-string">&quot;deleteHead&quot;</span>,<span class="hljs-string">&quot;deleteHead&quot;</span>]<br>[[],[],[<span class="hljs-number">5</span>],[<span class="hljs-number">2</span>],[],[]]<br>输出：[null,<span class="hljs-number">-1</span>,null,null,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><p><strong>提示</strong></p><p>1 &lt;= values &lt;= 10000<br />最多会对 appendTail、deleteHead 进行 10000 次调用</p><h3 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h3><p>维护两个栈，一个栈stack_in只负责输出，另一个栈stack_out只负责输入。</p><p>当stack_out为空时，将stack_in倒入stack_out中。</p><p>因为栈的先入后出特性，此过程完成了一次反转，变成了先入先出，符合队列的特性</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CQueue</span> &#123;</span><br>    stack&lt;<span class="hljs-keyword">int</span>&gt; stack_in, stack_out;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">CQueue</span>() &#123;<br>        <span class="hljs-keyword">while</span> (!stack_in.<span class="hljs-built_in">empty</span>()) &#123;<br>            stack_in.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">while</span> (!stack_out.<span class="hljs-built_in">empty</span>()) &#123;<br>            stack_out.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">appendTail</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        stack_in.<span class="hljs-built_in">push</span>(value);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteHead</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//输出栈为空，将输入栈倒入输出栈中</span><br>        <span class="hljs-keyword">if</span> (stack_out.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">while</span> (!stack_in.<span class="hljs-built_in">empty</span>()) &#123;<br>                stack_out.<span class="hljs-built_in">push</span>(stack_in.<span class="hljs-built_in">top</span>());<br>                stack_in.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//如果倾倒完，输出栈还为空，说明队列为空</span><br>        <span class="hljs-keyword">if</span> (stack_out.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">int</span> ret = stack_out.<span class="hljs-built_in">top</span>();<br>            stack_out.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">return</span> ret;<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your CQueue object will be instantiated and called as such:</span><br><span class="hljs-comment"> * CQueue* obj = new CQueue();</span><br><span class="hljs-comment"> * obj-&gt;appendTail(value);</span><br><span class="hljs-comment"> * int param_2 = obj-&gt;deleteHead();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><hr /><h2 id="剑指-offer-30-包含min函数的栈"><a class="markdownIt-Anchor" href="#剑指-offer-30-包含min函数的栈"></a> <a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/">剑指 Offer 30. 包含min函数的栈</a></h2><h3 id="描述-2"><a class="markdownIt-Anchor" href="#描述-2"></a> 描述</h3><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p><p><strong>示例</strong></p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pf">M<span class="hljs-keyword">in</span>Stack <span class="hljs-keyword">min</span>Stack = new M<span class="hljs-keyword">in</span>Stack();<br><span class="hljs-keyword">min</span>Stack.push(-<span class="hljs-number">2</span>);<br><span class="hljs-keyword">min</span>Stack.push(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">min</span>Stack.push(-<span class="hljs-number">3</span>);<br><span class="hljs-keyword">min</span>Stack.<span class="hljs-keyword">min</span>();   --&gt; 返回 -<span class="hljs-number">3</span>.<br><span class="hljs-keyword">min</span>Stack.pop();<br><span class="hljs-keyword">min</span>Stack.top();      --&gt; 返回 <span class="hljs-number">0</span>.<br><span class="hljs-keyword">min</span>Stack.<span class="hljs-keyword">min</span>();   --&gt; 返回 -<span class="hljs-number">2</span>.<br></code></pre></td></tr></table></figure><p><strong>提示</strong></p><p>各函数的调用总次数不超过 20000 次</p><h3 id="题解-2"><a class="markdownIt-Anchor" href="#题解-2"></a> 题解</h3><p><strong>解法一 保存最小元素信息</strong></p><p>由于栈的特性，每个元素退出、插入后、访问时，该栈的结构不会发生变化，所以我们可以在插入元素时存：<strong>到该元素为止最小的元素</strong>。</p><p>这样，每次访问一个元素时，当前栈中最小的元素值一定是该位置保存的最小元素值。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinStack</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MinNode</span> &#123;</span><br>        <span class="hljs-keyword">int</span> min;<br>        <span class="hljs-keyword">int</span> value;<br><br>        <span class="hljs-built_in">MinNode</span>(<span class="hljs-keyword">int</span> min, <span class="hljs-keyword">int</span> value) : <span class="hljs-built_in">min</span>(min), <span class="hljs-built_in">value</span>(value) &#123;&#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">typedef</span> MinNode *PtrToNode;<br>    stack&lt;PtrToNode&gt; stack;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/** initialize your data structure here. */</span><br>    <span class="hljs-built_in">MinStack</span>() &#123;<br>        <span class="hljs-keyword">while</span> (!stack.<span class="hljs-built_in">empty</span>()) &#123;<br>            stack.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (stack.<span class="hljs-built_in">empty</span>()) &#123;<br>            stack.<span class="hljs-built_in">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">MinNode</span>(x, x));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (x &lt; stack.<span class="hljs-built_in">top</span>()-&gt;min) &#123;<br>                stack.<span class="hljs-built_in">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">MinNode</span>(x, x));<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                stack.<span class="hljs-built_in">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">MinNode</span>(stack.<span class="hljs-built_in">top</span>()-&gt;min, x));<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        stack.<span class="hljs-built_in">pop</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stack.<span class="hljs-built_in">top</span>()-&gt;value;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">min</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stack.<span class="hljs-built_in">top</span>()-&gt;min;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MinStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MinStack* obj = new MinStack();</span><br><span class="hljs-comment"> * obj-&gt;push(x);</span><br><span class="hljs-comment"> * obj-&gt;pop();</span><br><span class="hljs-comment"> * int param_3 = obj-&gt;top();</span><br><span class="hljs-comment"> * int param_4 = obj-&gt;min();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p><strong>解法二 单调栈</strong></p><p>使用单调栈，我们维护栈中元素递减。</p><p>为了不丢失信息，我们在新元素不符合递减时不弹出栈中元素，而是在符合递减时才加入新元素。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinStack</span> &#123;</span><br>    <span class="hljs-comment">//递减栈</span><br>    stack&lt;<span class="hljs-keyword">int</span>&gt; minStack;<br>    stack&lt;<span class="hljs-keyword">int</span>&gt; stack;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/** initialize your data structure here. */</span><br>    <span class="hljs-built_in">MinStack</span>() &#123;<br>        <span class="hljs-keyword">while</span> (!stack.<span class="hljs-built_in">empty</span>())<br>            stack.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">while</span> (!minStack.<span class="hljs-built_in">empty</span>()) &#123;<br>            minStack.<span class="hljs-built_in">empty</span>();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        stack.<span class="hljs-built_in">push</span>(x);<br>        <span class="hljs-keyword">if</span> (minStack.<span class="hljs-built_in">empty</span>() || x &lt;= minStack.<span class="hljs-built_in">top</span>())<br>            minStack.<span class="hljs-built_in">push</span>(x);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (stack.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (stack.<span class="hljs-built_in">top</span>() == minStack.<span class="hljs-built_in">top</span>())<br>            minStack.<span class="hljs-built_in">pop</span>();<br>        stack.<span class="hljs-built_in">pop</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (stack.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> stack.<span class="hljs-built_in">top</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">min</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (stack.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> minStack.<span class="hljs-built_in">top</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MinStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MinStack* obj = new MinStack();</span><br><span class="hljs-comment"> * obj-&gt;push(x);</span><br><span class="hljs-comment"> * obj-&gt;pop();</span><br><span class="hljs-comment"> * int param_3 = obj-&gt;top();</span><br><span class="hljs-comment"> * int param_4 = obj-&gt;min();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>剑指Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[课题设计]校园导航</title>
    <link href="/p/eb1f/"/>
    <url>/p/eb1f/</url>
    
    <content type="html"><![CDATA[<p>本实验目的为构建大学地标导航，采用前后端分离的实现形式。前端使用React框架，后端使用SpringBoot，通过api接口来通信。本文主要介绍后端部分。</p><span id="more"></span><h2 id="概览"><a class="markdownIt-Anchor" href="#概览"></a> 概览</h2><p>网页展示：<a href="http://hbu-navigation.allenji.cn">http://hbu-navigation.allenji.cn</a></p><p>前端代码仓库：<a href="https://github.com/TBDGF/hbu-navigation-frontend">TBDGF/hbu-navigation-frontend (github.com)</a></p><p>后端代码仓库：<a href="https://github.com/TBDGF/hbu-navigation">TBDGF/hbu-navigation (github.com)</a></p><p><img src="https://s2.loli.net/2021/12/10/Q8MuC5oIREadO7T.png" alt="全貌" /></p><p><img src="https://s2.loli.net/2021/12/10/mMNHZkhLp9r2WYT.png" alt="寻路预览" /></p><p><img src="https://s2.loli.net/2021/12/10/g7yYAlMfTBzNUhP.png" alt="带有中间点的寻路" /></p><h2 id="项目结构"><a class="markdownIt-Anchor" href="#项目结构"></a> 项目结构</h2><pre><code class=" mermaid">graph LRsubgraph 前端showGraph(展示图)showPath(展示路径)endsubgraph 后端graphStore(图存储)endgraphStore----&gt;showGraphgraphStore--算法处理--&gt;showPath</code></pre><h2 id="储存结构"><a class="markdownIt-Anchor" href="#储存结构"></a> 储存结构</h2><h3 id="图"><a class="markdownIt-Anchor" href="#图"></a> 图</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Graph</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;Vertex&gt; vertices = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;(); <span class="hljs-comment">//邻接表，储存顶点List</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Vertex <span class="hljs-title">getVertex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> Index)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> vertices.get(Index);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Vertex <span class="hljs-title">getVertex</span><span class="hljs-params">(String label)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (Vertex vertex : vertices) &#123;<br>            <span class="hljs-keyword">if</span> (vertex.getLabel().equals(label))<br>                <span class="hljs-keyword">return</span> vertex;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Vertex&gt; <span class="hljs-title">getVertices</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> vertices;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addVertex</span><span class="hljs-params">(String label, String information, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (Vertex vertex : vertices) &#123;<br>            <span class="hljs-keyword">if</span> (vertex.getLabel().equals(label)) &#123;<br>                System.out.println(<span class="hljs-string">&quot;repeated vertex label&quot;</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>        vertices.add(<span class="hljs-keyword">new</span> Vertex(label, information, x, y));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(Vertex source, Vertex target, <span class="hljs-keyword">int</span> weight)</span> </span>&#123;<br>        source.addEdge(target, weight);<br>        target.addEdge(source, weight);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getVertexIndex</span><span class="hljs-params">(String label)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; vertices.size(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (vertices.get(i).getLabel().equals(label))<br>                <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getVertexIndex</span><span class="hljs-params">(Vertex vertex)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; vertices.size(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (vertices.get(i).equals(vertex))<br>                <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="点"><a class="markdownIt-Anchor" href="#点"></a> 点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Vertex</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Vertex</span>&gt; </span>&#123;  <span class="hljs-comment">//实现Comparable接口，用于优先队列</span><br>    <br>    <span class="hljs-keyword">private</span> String label;       <span class="hljs-comment">//储存节点的名称</span><br>    <span class="hljs-keyword">private</span> String information; <span class="hljs-comment">//储存节点详细信息</span><br>    <span class="hljs-keyword">private</span> List&lt;Edge&gt; edges;   <span class="hljs-comment">//储存边List</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> distance;       <span class="hljs-comment">//遍历时距起点距离，用于dijkstra算法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> x, y;<span class="hljs-comment">//在图上点的绝对位置，用于可视化</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Vertex</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.label = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">this</span>.information = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">this</span>.edges = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Vertex</span><span class="hljs-params">(String label, String information, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.label = label;<br>        <span class="hljs-keyword">this</span>.information = information;<br>        <span class="hljs-keyword">this</span>.edges = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">this</span>.x = x;<br>        <span class="hljs-keyword">this</span>.y = y;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(Vertex target, <span class="hljs-keyword">int</span> weight)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (Edge edge : edges) &#123;<br>            <span class="hljs-keyword">if</span> (edge.getTarget().equals(target)) &#123;<br>                System.out.println(<span class="hljs-string">&quot;repeated edge&quot;</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">this</span>.edges.add(<span class="hljs-keyword">new</span> Edge(<span class="hljs-keyword">this</span>, target, weight));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Edge <span class="hljs-title">getEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.edges.get(index);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Vertex vertex)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.distance == vertex.distance) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.distance &lt; vertex.distance) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="边"><a class="markdownIt-Anchor" href="#边"></a> 边</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Edge</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> String id;      <span class="hljs-comment">//边的id，由起点和终点自动生成</span><br>    <span class="hljs-keyword">private</span> Vertex target;  <span class="hljs-comment">//目标节点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> weight;     <span class="hljs-comment">//权值</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Edge</span><span class="hljs-params">(Vertex target, <span class="hljs-keyword">int</span> weight)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.target = target;<br>        <span class="hljs-keyword">this</span>.weight = weight;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Edge</span><span class="hljs-params">(Vertex source, Vertex target, <span class="hljs-keyword">int</span> weight)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.target = target;<br>        <span class="hljs-keyword">this</span>.weight = weight;<br>        <span class="hljs-keyword">this</span>.id = source.getLabel() + <span class="hljs-string">&quot;-to-&quot;</span> + target.getLabel();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="核心算法"><a class="markdownIt-Anchor" href="#核心算法"></a> 核心算法</h2><h3 id="多源最短路径的寻找"><a class="markdownIt-Anchor" href="#多源最短路径的寻找"></a> 多源最短路径的寻找</h3><p>当然采用的是大名鼎鼎的floyd算法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> INF = (<span class="hljs-keyword">int</span>) <span class="hljs-number">1e6</span>;<span class="hljs-comment">//设置足够大的常数，表示距离为无穷，即不可到达</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] adjMatrix;  <span class="hljs-comment">//用于floyd的邻接矩阵</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> graphSize = Graph.getVertices().size();<br>    <span class="hljs-keyword">this</span>.adjMatrix = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[graphSize][graphSize]; <span class="hljs-comment">//初始化邻接矩阵</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; graphSize; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; graphSize; j++) &#123;<br>            <span class="hljs-keyword">this</span>.adjMatrix[i][j] = INF;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; graphSize; i++) &#123;   <span class="hljs-comment">//将以邻接表储存的图储存成临界矩阵的格式</span><br>        <span class="hljs-keyword">if</span> (!Graph.getVertex(i).getEdges().isEmpty()) &#123;<br>            <span class="hljs-keyword">for</span> (Edge edge : Graph.getVertex(i).getEdges()) &#123;<br>                adjMatrix[i][Graph.getVertexIndex(edge.getTarget())] = edge.getWeight();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; graphSize; k++) &#123;   <span class="hljs-comment">//执行floyd算法</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; graphSize; i++) &#123;<br>            <span class="hljs-keyword">if</span> (adjMatrix[i][k] != INF) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; graphSize; j++) &#123;<br>                    <span class="hljs-keyword">if</span> (adjMatrix[i][j] &gt; adjMatrix[i][k] + adjMatrix[k][j])<br>                        adjMatrix[i][j] = adjMatrix[i][k] + adjMatrix[k][j];<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="单源最短路径的寻找"><a class="markdownIt-Anchor" href="#单源最短路径的寻找"></a> 单源最短路径的寻找</h3><p>自然是同样大名鼎鼎的dijkstra算法，并使用优先队列优化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] pre;          <span class="hljs-comment">//记录前驱节点，pre[x]=y，在最短路径上，x的前一个节点是y</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] distance;     <span class="hljs-comment">//记录到起点的距离</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start)</span> </span>&#123;<br>    pre = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[Graph.getVertices().size()];<br>    distance = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[Graph.getVertices().size()];<br>    <span class="hljs-keyword">boolean</span>[] hasFound = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[Graph.getVertices().size()];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; Graph.getVertices().size(); i++) &#123;<br>        distance[i] = INF;<br>        hasFound[i] = <span class="hljs-keyword">false</span>;<br>    &#125;<br>    distance[start] = <span class="hljs-number">0</span>;<br>    PriorityQueue&lt;Vertex&gt; queue = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;();<br>    Graph.getVertex(start).setDistance(distance[start]);<br>    queue.add(Graph.getVertex(start));<br>    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>        Vertex top = queue.peek();<br>        queue.poll();<br>        <span class="hljs-keyword">if</span> (hasFound[Graph.getVertexIndex(top)]) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        hasFound[Graph.getVertexIndex(top)] = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; top.getEdges().size(); i++) &#123;<br>            Edge edge = top.getEdge(i);<br>            <span class="hljs-keyword">int</span> targetIndex=Graph.getVertexIndex(edge.getTarget());<br>            <span class="hljs-keyword">if</span> (hasFound[targetIndex])<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (distance[targetIndex] &gt; edge.getWeight() + top.getDistance()) &#123;<br>                distance[targetIndex] = edge.getWeight() + top.getDistance();<br>                edge.getTarget().setDistance(distance[targetIndex]);<br>                queue.add(edge.getTarget());<br>                pre[targetIndex] = Graph.getVertexIndex(top);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="含有必经点的路径查找"><a class="markdownIt-Anchor" href="#含有必经点的路径查找"></a> 含有必经点的路径查找</h3><ol><li>将始末点和必经点分开</li><li>将必经点全排列，作为中间路径</li><li>通过floyd便捷求得每一个中间路径的总路程，再将始末点与中间路径的距离求出后，得到最短路程</li><li>由于路径可能经过无关点（即非始末点和必经点），需要用dijkstra求出并保存每个节点之间的路径</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> WebPath <span class="hljs-title">getWebPath</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> destination)</span> </span>&#123; <span class="hljs-comment">//调用dijkstra，并保存路径</span><br>    <span class="hljs-keyword">this</span>.dijkstra(start);<br>    webPath = <span class="hljs-keyword">new</span> WebPath();<br>    traverseWebPath(start, destination);<br>    System.out.println(<span class="hljs-keyword">this</span>.distance[destination]);<br>    <span class="hljs-keyword">return</span> webPath;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;WebPath&gt; <span class="hljs-title">getPaths</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> destination, List&lt;Integer&gt; pass)</span> </span>&#123;<br>    List&lt;WebPath&gt; paths = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    <span class="hljs-keyword">this</span>.floyd();<br>    <span class="hljs-keyword">int</span> minDistance = INF;<br>    List&lt;Integer&gt; minList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    List&lt;List&lt;Integer&gt;&gt; passMatrix = Perm.permList(pass);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; passMatrix.size(); i++) &#123;<br>        List&lt;Integer&gt; passList = passMatrix.get(i);<br>        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; passList.size() - <span class="hljs-number">1</span>; j++) &#123;<br>            <span class="hljs-keyword">if</span> (adjMatrix[passList.get(j)][passList.get(j + <span class="hljs-number">1</span>)] != INF) &#123;<br>                cnt += adjMatrix[passList.get(j)][passList.get(j + <span class="hljs-number">1</span>)];<br>            &#125;<br>        &#125;<br>        cnt += adjMatrix[start][passList.get(<span class="hljs-number">0</span>)];<br>        cnt += adjMatrix[passList.get(passList.size() - <span class="hljs-number">1</span>)][destination];<br>        <span class="hljs-keyword">if</span> (minDistance &gt; cnt) &#123;<br>            minDistance = cnt;<br>            minList = passList;<br>        &#125;<br>    &#125;<br>    paths.add(getWebPath(start, minList.get(<span class="hljs-number">0</span>)));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; minList.size() - <span class="hljs-number">1</span>; i++)<br>        paths.add(getWebPath(minList.get(i), minList.get(i + <span class="hljs-number">1</span>)));<br>    paths.add(getWebPath(minList.get(minList.size() - <span class="hljs-number">1</span>), destination));<br>    System.out.println(paths);<br>    <span class="hljs-keyword">return</span> paths;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[mysql]MySQL ubuntu部署</title>
    <link href="/p/6601/"/>
    <url>/p/6601/</url>
    
    <content type="html"><![CDATA[<p>本文将演示如何在ubuntu上部署mysql，创建角色和赋予权限</p><span id="more"></span><h2 id="安装mysql"><a class="markdownIt-Anchor" href="#安装mysql"></a> 安装mysql</h2><p>使用命令行安装mysql</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">sudo apt-<span class="hljs-keyword">get</span> install mysql-<span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><h2 id="配置mysql"><a class="markdownIt-Anchor" href="#配置mysql"></a> 配置mysql</h2><h3 id="1初始化"><a class="markdownIt-Anchor" href="#1初始化"></a> 1.初始化</h3><p>命令行</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo mysql_secure_installation</span><br></code></pre></td></tr></table></figure><p>配置项如下:</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">VALIDATE PASSWORD COMPONENT can be used <span class="hljs-built_in">to</span> test passwords<br><span class="hljs-keyword">and</span> improve security. It checks <span class="hljs-keyword">the</span> strength <span class="hljs-keyword">of</span> password<br><span class="hljs-keyword">and</span> allows <span class="hljs-keyword">the</span> users <span class="hljs-built_in">to</span> <span class="hljs-built_in">set</span> only those passwords which are<br>secure enough. Would you like <span class="hljs-built_in">to</span> setup VALIDATE PASSWORD component?<br><br>Press y|Y <span class="hljs-keyword">for</span> Yes, <span class="hljs-keyword">any</span> other key <span class="hljs-keyword">for</span> No: y<span class="hljs-comment">//是否开启强密码，避免出现过弱密码，这里选择Y</span><br><br>There are <span class="hljs-literal">three</span> levels <span class="hljs-keyword">of</span> password validation policy:<br><br>LOW    Length &gt;= <span class="hljs-number">8</span><br>MEDIUM Length &gt;= <span class="hljs-number">8</span>, <span class="hljs-keyword">numeric</span>, mixed <span class="hljs-keyword">case</span>, <span class="hljs-keyword">and</span> special <span class="hljs-keyword">characters</span><br>STRONG Length &gt;= <span class="hljs-number">8</span>, <span class="hljs-keyword">numeric</span>, mixed <span class="hljs-keyword">case</span>, special <span class="hljs-keyword">characters</span> <span class="hljs-keyword">and</span> dictionary                  <span class="hljs-built_in">file</span><br><br>Please enter <span class="hljs-number">0</span> = LOW, <span class="hljs-number">1</span> = MEDIUM <span class="hljs-keyword">and</span> <span class="hljs-number">2</span> = STRONG: <span class="hljs-number">1</span><span class="hljs-comment">//选择密码强度，这里选择1</span><br>Please <span class="hljs-built_in">set</span> <span class="hljs-keyword">the</span> password <span class="hljs-keyword">for</span> root here.<br><br>New password: <span class="hljs-comment">//输入密码</span><br><br>Re-enter <span class="hljs-built_in">new</span> password: <span class="hljs-comment">//再次输入密码</span><br><br>Estimated strength <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> password: <span class="hljs-number">100</span> <br>Do you wish <span class="hljs-built_in">to</span> continue <span class="hljs-keyword">with</span> <span class="hljs-keyword">the</span> password provided?(Press y|Y <span class="hljs-keyword">for</span> Yes, <span class="hljs-keyword">any</span> other key <span class="hljs-keyword">for</span> No) : y<span class="hljs-comment">//确认或再次输入其他密码</span><br><br>By default, <span class="hljs-keyword">a</span> MySQL installation has <span class="hljs-keyword">an</span> anonymous user,<br>allowing anyone <span class="hljs-built_in">to</span> <span class="hljs-built_in">log</span> <span class="hljs-keyword">into</span> MySQL <span class="hljs-keyword">without</span> having <span class="hljs-built_in">to</span> have<br><span class="hljs-keyword">a</span> user account created <span class="hljs-keyword">for</span> them. This is intended only <span class="hljs-keyword">for</span><br>testing, <span class="hljs-keyword">and</span> <span class="hljs-built_in">to</span> make <span class="hljs-keyword">the</span> installation go <span class="hljs-keyword">a</span> bit smoother.<br>You should remove them <span class="hljs-keyword">before</span> moving <span class="hljs-keyword">into</span> <span class="hljs-keyword">a</span> production<br>environment.<br><br>Remove anonymous users? (Press y|Y <span class="hljs-keyword">for</span> Yes, <span class="hljs-keyword">any</span> other key <span class="hljs-keyword">for</span> No) : y<span class="hljs-comment">//是否移除匿名用户</span><br>Success.<br><br><br>Normally, root should only be allowed <span class="hljs-built_in">to</span> connect <span class="hljs-built_in">from</span><br><span class="hljs-string">&#x27;localhost&#x27;</span>. This ensures that someone cannot guess <span class="hljs-keyword">at</span><br><span class="hljs-keyword">the</span> root password <span class="hljs-built_in">from</span> <span class="hljs-keyword">the</span> network.<br><br>Disallow root login remotely? (Press y|Y <span class="hljs-keyword">for</span> Yes, <span class="hljs-keyword">any</span> other key <span class="hljs-keyword">for</span> No) : n<span class="hljs-comment">//是否要禁止远程登陆，选择否</span><br><br> ... skipping.<br>By default, MySQL comes <span class="hljs-keyword">with</span> <span class="hljs-keyword">a</span> database named <span class="hljs-string">&#x27;test&#x27;</span> that<br>anyone can access. This is also intended only <span class="hljs-keyword">for</span> testing,<br><span class="hljs-keyword">and</span> should be removed <span class="hljs-keyword">before</span> moving <span class="hljs-keyword">into</span> <span class="hljs-keyword">a</span> production<br>environment.<br><br><br>Remove test database <span class="hljs-keyword">and</span> access <span class="hljs-built_in">to</span> <span class="hljs-keyword">it</span>? (Press y|Y <span class="hljs-keyword">for</span> Yes, <span class="hljs-keyword">any</span> other key <span class="hljs-keyword">for</span> No) : y<span class="hljs-comment">//是否移除初始数据库</span><br> - Dropping test database...<br>Success.<br><br> - Removing privileges <span class="hljs-keyword">on</span> <span class="hljs-title">test</span> <span class="hljs-title">database</span>...<br>Success.<br><br>Reloading <span class="hljs-keyword">the</span> privilege tables will ensure that all changes<br>made so far will take effect immediately.<br><br>Reload privilege tables now? (Press y|Y <span class="hljs-keyword">for</span> Yes, <span class="hljs-keyword">any</span> other key <span class="hljs-keyword">for</span> No) : y<span class="hljs-comment">//是否重载权限</span><br>Success.<br><br>All done! <br></code></pre></td></tr></table></figure><h3 id="2配置用户"><a class="markdownIt-Anchor" href="#2配置用户"></a> 2.配置用户</h3><p>用root进入mysql</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">sudo mysql -uroot -<span class="hljs-selector-tag">p</span><br></code></pre></td></tr></table></figure><p><strong>创建用户</strong></p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">user</span> MyUser@<span class="hljs-string">&#x27;localhost&#x27;</span> identified <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;MyPassword&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>授权（授予所有数据库的所有权限）</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">grant</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">privileges</span> <span class="hljs-keyword">on</span> *.* <span class="hljs-keyword">to</span> MyUser@<span class="hljs-string">&#x27;localhost&#x27;</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>mysql</tag>
      
      <tag>ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[python]爬虫实战-爬取豆瓣小组信息&amp;自动化处理验证码</title>
    <link href="/p/7f16/"/>
    <url>/p/7f16/</url>
    
    <content type="html"><![CDATA[<p>本文会介绍如何编写豆瓣爬虫，及相对应的验证码处理</p><p>本博客不会介绍一些比较基础的信息，需要读者自己学习，比如python的异步库asyncio</p><span id="more"></span><p>写代码好累</p><p>不要靠近编程，会让人不幸</p><p><img src="/img/%5Bpython%5D%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98-%E7%88%AC%E5%8F%96%E8%B1%86%E7%93%A3%E5%B0%8F%E7%BB%84%E4%BF%A1%E6%81%AF&amp;%E8%87%AA%E5%8A%A8%E5%8C%96%E5%A4%84%E7%90%86%E9%AA%8C%E8%AF%81%E7%A0%81/meme-tired.jpg" alt="" /></p><h1 id="第三方库选型"><a class="markdownIt-Anchor" href="#第三方库选型"></a> 第三方库选型</h1><h2 id="web库选型-aiohttp"><a class="markdownIt-Anchor" href="#web库选型-aiohttp"></a> web库选型 - aiohttp</h2><p>aiohttp可以看作requests的异步版本，同时支持客户端和服务端，继承requests简洁、明了的优点同时，又不易阻塞（虽然有时候该阻还是会阻会儿）</p><p><a href="https://docs.aiohttp.org/en/stable/">aiohttp官网</a></p><p>简单实现:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> aiohttp<br><span class="hljs-keyword">import</span> asyncio<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiohttp.ClientSession() <span class="hljs-keyword">as</span> session:<br>        <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">&#x27;http://python.org&#x27;</span>) <span class="hljs-keyword">as</span> response:<br><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Status:&quot;</span>, response.status)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Content-type:&quot;</span>, response.headers[<span class="hljs-string">&#x27;content-type&#x27;</span>])<br><br>            html = <span class="hljs-keyword">await</span> response.text()<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Body:&quot;</span>, html[:<span class="hljs-number">15</span>], <span class="hljs-string">&quot;...&quot;</span>)<br><br>loop = asyncio.get_event_loop()<br>loop.run_until_complete(main())<br></code></pre></td></tr></table></figure><p>同时，我们也不会放弃使用requests，可以用它来处理一些简单的中间请求</p><h2 id="html库-beautiful-soup"><a class="markdownIt-Anchor" href="#html库-beautiful-soup"></a> HTML库 - Beautiful Soup</h2><p>Beautiful Soup 是一个可以从HTML或XML文件中提取数据的Python库.它能够通过你喜欢的转换器实现惯用的文档导航,查找,修改文档的方式.Beautiful Soup会帮你节省数小时甚至数天的工作时间.</p><p><a href="https://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/">Beautiful Soup 中文文档 </a></p><p>简单实现:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br><br>soup = BeautifulSoup(html_text, <span class="hljs-string">&#x27;lxml&#x27;</span>)<span class="hljs-comment">#html_text为html字符串</span><br>link_elements = soup.find_all(<span class="hljs-string">&quot;a&quot;</span>)<br><br></code></pre></td></tr></table></figure><h2 id="ocr库-pytesseract"><a class="markdownIt-Anchor" href="#ocr库-pytesseract"></a> OCR库 - pytesseract</h2><p>Tesseract 是一个开源的ocr引擎，可以开箱即用，项目最初由惠普实验室支持，1996年被移植到Windows上，1998年进行了C++化。在2005年Tesseract 由惠普公司宣布开源。2006年到现在，都由Google公司开发。</p><p><a href="https://github.com/tesseract-ocr/tesseract/">仓库地址</a></p><p>pytesseract 则是Tesseract 的python接口库，pytesseract只是接口，我们需在本地单独安装Tesseract</p><p>我们使用pytesseract 库需要借助PIL(Python Image Library)库，该库提供了基本的图像处理功能</p><p>简单实现:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span>  PIL <span class="hljs-keyword">import</span>  Image<br><span class="hljs-keyword">import</span> pytesseract<br><br>img = Image.<span class="hljs-built_in">open</span>(img_path)<br>text = pytesseract.image_to_string(img,lang=<span class="hljs-string">&#x27;eng&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="mysql库-pymysql"><a class="markdownIt-Anchor" href="#mysql库-pymysql"></a> MySQL库 - pymysql</h2><p>PyMySQL 是在 Python3.x 版本中用于连接 MySQL 服务器的一个库，Python2中则使用mysqldb。</p><p><a href="https://www.runoob.com/python3/python3-mysql.html">pymysql-菜鸟教程</a></p><p>简单实现:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br> <br><span class="hljs-keyword">import</span> pymysql<br> <br><span class="hljs-comment"># 打开数据库连接</span><br>db = pymysql.connect(<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-string">&quot;testuser&quot;</span>,<span class="hljs-string">&quot;test123&quot;</span>,<span class="hljs-string">&quot;TESTDB&quot;</span> )<br> <br><span class="hljs-comment"># 使用 cursor() 方法创建一个游标对象 cursor</span><br>cursor = db.cursor()<br> <br><span class="hljs-comment"># 使用 execute()  方法执行 SQL 查询 </span><br>cursor.execute(<span class="hljs-string">&quot;SELECT VERSION()&quot;</span>)<br> <br><span class="hljs-comment"># 使用 fetchone() 方法获取单条数据.</span><br>data = cursor.fetchone()<br> <br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;Database version : %s &quot;</span> % data)<br> <br><span class="hljs-comment"># 关闭数据库连接</span><br>db.close()<br></code></pre></td></tr></table></figure><h2 id="工具库"><a class="markdownIt-Anchor" href="#工具库"></a> 工具库</h2><h3 id="dateutil"><a class="markdownIt-Anchor" href="#dateutil"></a> dateutil</h3><p>一个方便，开箱即用的时间转换库，帮助我们处理时间</p><p><a href="https://pypi.org/project/python-dateutil/">pypi地址</a></p><p>简单实现:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> dateutil.parser <span class="hljs-keyword">import</span> parse<br> <br><span class="hljs-meta">&gt;&gt;&gt; </span>parse(<span class="hljs-string">&quot;2018-10-21&quot;</span>)<br>datetime.datetime(<span class="hljs-number">2018</span>, <span class="hljs-number">10</span>, <span class="hljs-number">21</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br> <br><span class="hljs-meta">&gt;&gt;&gt; </span>parse(<span class="hljs-string">&quot;20181021&quot;</span>)<br>datetime.datetime(<span class="hljs-number">2018</span>, <span class="hljs-number">10</span>, <span class="hljs-number">21</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br> <br><span class="hljs-meta">&gt;&gt;&gt; </span>parse(<span class="hljs-string">&quot;2018/10/21&quot;</span>)<br>datetime.datetime(<span class="hljs-number">2018</span>, <span class="hljs-number">10</span>, <span class="hljs-number">21</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br> <br><span class="hljs-meta">&gt;&gt;&gt; </span>parse(<span class="hljs-string">&quot;10-21&quot;</span>)<br>datetime.datetime(<span class="hljs-number">2018</span>, <span class="hljs-number">10</span>, <span class="hljs-number">21</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br> <br><span class="hljs-meta">&gt;&gt;&gt; </span>parse(<span class="hljs-string">&quot;10/21&quot;</span>)<br>datetime.datetime(<span class="hljs-number">2018</span>, <span class="hljs-number">10</span>, <span class="hljs-number">21</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><h1 id="设计思路"><a class="markdownIt-Anchor" href="#设计思路"></a> 设计思路</h1><h2 id="总流程"><a class="markdownIt-Anchor" href="#总流程"></a> 总流程</h2><pre><code class=" mermaid">graph TB小组的原始积累--&gt;小组列表待添加小组列表--&gt;小组列表小组列表--处理验证码--&gt;遍历小组</code></pre><h2 id="获取信息"><a class="markdownIt-Anchor" href="#获取信息"></a> 获取信息</h2><pre><code class=" mermaid">graph LR获取信息--&gt;获取成功获取信息--&gt;获取失败获取失败--&gt;验证码处理--&gt;流程结束获取成功--&gt;流程结束--循环结构--&gt;获取信息</code></pre><h2 id="验证码处理"><a class="markdownIt-Anchor" href="#验证码处理"></a> 验证码处理</h2><p>由于豆瓣验证码并非可以直接OCR的图片，所以我们需要进行一些处理</p><p>Before:</p><p><img src="/img/%5Bpython%5D%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98-%E7%88%AC%E5%8F%96%E8%B1%86%E7%93%A3%E5%B0%8F%E7%BB%84%E4%BF%A1%E6%81%AF&amp;%E8%87%AA%E5%8A%A8%E5%8C%96%E5%A4%84%E7%90%86%E9%AA%8C%E8%AF%81%E7%A0%81/captcha-before.jpg" alt="captha-before" /></p><p>After:</p><p><img src="/img/%5Bpython%5D%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98-%E7%88%AC%E5%8F%96%E8%B1%86%E7%93%A3%E5%B0%8F%E7%BB%84%E4%BF%A1%E6%81%AF&amp;%E8%87%AA%E5%8A%A8%E5%8C%96%E5%A4%84%E7%90%86%E9%AA%8C%E8%AF%81%E7%A0%81/captcha-after.jpg" alt="captha-after" /></p><pre><code class=" mermaid">graph LR获取验证码图片--&gt;二值化去除背景--&gt;去除噪点--&gt;执行OCR--&gt;模拟提交表单</code></pre><h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1><h2 id="预定义常量"><a class="markdownIt-Anchor" href="#预定义常量"></a> 预定义常量</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 请求头</span><br>headers = &#123;<br>    <span class="hljs-string">&quot;User-Agent&quot;</span>: Secret.USER_AGENT,<br>    <span class="hljs-string">&quot;Cookie&quot;</span>: Secret.COOKIE<br>&#125;<br><br><span class="hljs-comment"># 数据库连接</span><br>conn = pymysql.connect(host=<span class="hljs-string">&quot;localhost&quot;</span>, user=Secret.DB_USER, password=Secret.DB_PASSWORD, database=<span class="hljs-string">&quot;doubantest&quot;</span>, port=<span class="hljs-number">3306</span>,<br>                       charset=<span class="hljs-string">&quot;utf8mb4&quot;</span>)<br>cursor = conn.cursor()<br><br><span class="hljs-comment"># 表单Body</span><br>form = &#123;<br>    <span class="hljs-string">&quot;ck&quot;</span>: <span class="hljs-string">&quot;Un0d&quot;</span>,<br>    <span class="hljs-string">&quot;captcha-solution&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>    <span class="hljs-string">&quot;captcha-id&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>    <span class="hljs-string">&quot;original-url&quot;</span>: <span class="hljs-string">&quot;https://www.douban.com/group/&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="主函数"><a class="markdownIt-Anchor" href="#主函数"></a> 主函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> traceback<br><span class="hljs-keyword">from</span> asyncio <span class="hljs-keyword">import</span> sleep<br><span class="hljs-keyword">import</span> pymysql<br><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br><span class="hljs-keyword">import</span> aiohttp<br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">from</span> dateutil.parser <span class="hljs-keyword">import</span> parse<br><span class="hljs-keyword">from</span> dateutil.relativedelta <span class="hljs-keyword">import</span> relativedelta<br><span class="hljs-keyword">import</span> datetime<br><span class="hljs-keyword">import</span> PostSolution<br><span class="hljs-keyword">import</span> Secret<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiohttp.ClientSession() <span class="hljs-keyword">as</span> session:<br>        group_list = <span class="hljs-keyword">await</span> get_group_id_list()  <span class="hljs-comment"># 从数据库读取小组列表</span><br>        <span class="hljs-comment"># await PostSolution.main()</span><br>        <span class="hljs-keyword">for</span> index, group_id <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(group_list):<br>            <span class="hljs-comment"># if index&lt;=786:</span><br>            <span class="hljs-comment">#     continue</span><br>            member = <span class="hljs-keyword">await</span> get_group_member(session, group_id)  <span class="hljs-comment"># 获取小组人数</span><br>            <span class="hljs-built_in">print</span>(group_id, member)<br>            <span class="hljs-built_in">sum</span> = <span class="hljs-keyword">await</span> get_group_comment(session, group_id)    <span class="hljs-comment"># 获取该小组讨论数</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-built_in">sum</span>)<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">sum</span> &lt;= <span class="hljs-number">100</span>:<br>                <span class="hljs-keyword">await</span> delete_group_list_by_group_id(group_id)   <span class="hljs-comment"># 如果讨论数小于100，则从数据库中删除</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">await</span> insert_group_info(group_id, member, <span class="hljs-built_in">sum</span>)  <span class="hljs-comment"># 将信息插入数据库</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;fetch over&quot;</span>)<br>        <span class="hljs-keyword">await</span> clean_group_info()    <span class="hljs-comment"># 清理无效小组信息</span><br>        <span class="hljs-keyword">await</span> replace_group_ranked()    <span class="hljs-comment"># 对小组排名并存进数据库，减少服务器压力</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    loop = asyncio.get_event_loop()<br>    loop.run_until_complete(main())<br></code></pre></td></tr></table></figure><h3 id="获取小组人数"><a class="markdownIt-Anchor" href="#获取小组人数"></a> 获取小组人数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_group_member</span>(<span class="hljs-params">session, group_id</span>):</span><br>    url = <span class="hljs-string">&quot;https://www.douban.com/group/&#123;0&#125;/&quot;</span>.<span class="hljs-built_in">format</span>(group_id)<br>    success = <span class="hljs-literal">None</span><br>    is_denied = <span class="hljs-literal">None</span><br>    cnt = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> success <span class="hljs-keyword">or</span> is_denied:  <span class="hljs-comment"># 循环结构</span><br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(url, headers=headers) <span class="hljs-keyword">as</span> response:  <span class="hljs-comment"># 获取网页HTML</span><br>                is_denied = response.url.__str__()[:<span class="hljs-number">33</span>] == <span class="hljs-string">&quot;https://www.douban.com/misc/sorry&quot;</span>  <span class="hljs-comment"># 判断是否被拒绝</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> is_denied:  <span class="hljs-comment"># 如果没有被拒绝，则获取网页元素</span><br>                    text = <span class="hljs-keyword">await</span> response.text()<br>                    soup = BeautifulSoup(text, <span class="hljs-string">&quot;lxml&quot;</span>)<br>                    member_element = soup.select(<br>                        <span class="hljs-string">&quot;#content &gt; div.grid-16-8.clearfix &gt; div.aside &gt; div.mod.side-nav &gt; p:nth-child(1) &gt; a&quot;</span>)<br>                    is_denied = <span class="hljs-built_in">len</span>(member_element) &lt;= <span class="hljs-number">0</span><br>                <span class="hljs-keyword">if</span> is_denied:  <span class="hljs-comment"># 如果被拒绝，则提交验证码，再次循环</span><br>                    <span class="hljs-keyword">await</span> PostSolution.main()<br>                    <span class="hljs-keyword">continue</span><br><br>                text = <span class="hljs-keyword">await</span> response.text()<br>                soup = BeautifulSoup(text, <span class="hljs-string">&quot;lxml&quot;</span>)<br>                member_element = soup.select(  <span class="hljs-comment"># 获取小组人数</span><br>                    <span class="hljs-string">&quot;#content &gt; div.grid-16-8.clearfix &gt; div.aside &gt; div.mod.side-nav &gt; p:nth-child(1) &gt; a&quot;</span>)<br><br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(member_element) &lt;= <span class="hljs-number">0</span>:  <span class="hljs-comment"># 如果没获取到人数，计数重复3次，如果失败则返回-1</span><br>                    cnt += <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">if</span> cnt &lt;= <span class="hljs-number">3</span>:<br>                        <span class="hljs-keyword">await</span> sleep(<span class="hljs-number">0.5</span>)<br>                    <span class="hljs-keyword">else</span>:<br>                        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    member_text = member_element[<span class="hljs-number">0</span>].get_text()<br>                    <span class="hljs-keyword">return</span> <span class="hljs-built_in">eval</span>(member_text[member_text.index(<span class="hljs-string">&quot;(&quot;</span>) + <span class="hljs-number">1</span>:-<span class="hljs-number">1</span>]) <span class="hljs-comment"># 返回小组人数</span><br>        <span class="hljs-keyword">except</span>:<br>            success = <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><h3 id="获取小组讨论"><a class="markdownIt-Anchor" href="#获取小组讨论"></a> 获取小组讨论</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_group_comment</span>(<span class="hljs-params">session, group_id</span>):</span><br>    success = <span class="hljs-literal">None</span><br>    is_denied = <span class="hljs-literal">None</span><br>    next_start = <span class="hljs-number">0</span><br>    comment_sum = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> success <span class="hljs-keyword">or</span> is_denied: <span class="hljs-comment"># 循环结构</span><br>        url = <span class="hljs-string">&quot;https://www.douban.com/group/&#123;0&#125;/discussion?start=&#123;1&#125;&quot;</span>.<span class="hljs-built_in">format</span>(group_id, next_start)<br>        <span class="hljs-keyword">await</span> sleep(<span class="hljs-number">0.5</span>)<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(url, headers=headers) <span class="hljs-keyword">as</span> response: <span class="hljs-comment"># 获取网页HTML</span><br>                is_denied = response.url.__str__()[:<span class="hljs-number">33</span>] == <span class="hljs-string">&quot;https://www.douban.com/misc/sorry&quot;</span>  <span class="hljs-comment"># 判断是否被拒绝</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> is_denied:   <span class="hljs-comment"># 如果没有被拒绝，则获取网页元素</span><br>                    text = <span class="hljs-keyword">await</span> response.text()<br>                    soup = BeautifulSoup(text, <span class="hljs-string">&quot;lxml&quot;</span>)<br>                    comment_elements = soup.find_all(<span class="hljs-string">&quot;td&quot;</span>, attrs=&#123;<span class="hljs-string">&quot;class&quot;</span>: <span class="hljs-string">&quot;r-count&quot;</span>&#125;)[<span class="hljs-number">1</span>:]<br>                    time_elements = soup.find_all(<span class="hljs-string">&quot;td&quot;</span>, attrs=&#123;<span class="hljs-string">&quot;class&quot;</span>: <span class="hljs-string">&quot;time&quot;</span>&#125;)<br>                    is_denied = <span class="hljs-built_in">len</span>(comment_elements) &lt;= <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">len</span>(time_elements) &lt;= <span class="hljs-number">0</span><br>                <span class="hljs-keyword">if</span> is_denied:   <span class="hljs-comment"># 如果被拒绝，则提交验证码，再次循环</span><br>                    <span class="hljs-keyword">await</span> PostSolution.main()<br>                    <span class="hljs-keyword">continue</span><br><br>                over_time = <span class="hljs-literal">False</span><br>                <span class="hljs-keyword">for</span> index, comment <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(comment_elements):  <span class="hljs-comment"># 判断评论是否过期并计数</span><br>                    time = parse(time_elements[index].get_text())<br>                    NOW = datetime.datetime.now()<br>                    text = comment.get_text()<br>                    <span class="hljs-keyword">if</span> time &gt; NOW + relativedelta(weeks=-<span class="hljs-number">1</span>):<br>                        <span class="hljs-keyword">if</span> text.isdigit():<br>                            num = <span class="hljs-built_in">eval</span>(text <span class="hljs-keyword">if</span> text != <span class="hljs-string">&quot;&quot;</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;1&quot;</span>)<br>                            comment_sum += num <span class="hljs-keyword">if</span> num &lt;= <span class="hljs-number">1000</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br>                    <span class="hljs-keyword">else</span>:<br>                        over_time = <span class="hljs-literal">True</span><br>                <span class="hljs-built_in">print</span>(next_start)<br><br>                <span class="hljs-comment"># 获取下一页地址</span><br>                next_start_element = soup.select(<span class="hljs-string">&quot;#content &gt; div &gt; div.article &gt; div.paginator &gt; span.next &gt; a&quot;</span>)<br>                is_end = <span class="hljs-built_in">len</span>(next_start_element) &lt;= <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> over_time<br><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> is_end:  <span class="hljs-comment"># 判断是否还有下一页，如果没有，结束循环</span><br>                next_start = next_start_element[<span class="hljs-number">0</span>].get(<span class="hljs-string">&#x27;href&#x27;</span>)<br>                next_start = next_start[next_start.index(<span class="hljs-string">&quot;=&quot;</span>) + <span class="hljs-number">1</span>:]<br>            <span class="hljs-keyword">else</span>:<br>                success = <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">except</span>:<br>            success = <span class="hljs-literal">None</span><br><br>    <span class="hljs-keyword">return</span> comment_sum<br></code></pre></td></tr></table></figure><h2 id="发送验证码"><a class="markdownIt-Anchor" href="#发送验证码"></a> 发送验证码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br><span class="hljs-keyword">import</span> aiohttp<br><span class="hljs-keyword">import</span> asyncio<br><br><span class="hljs-keyword">import</span> ImageOCR<br><span class="hljs-keyword">import</span> Secret<br><br>headers = &#123;<br>    <span class="hljs-string">&quot;User-Agent&quot;</span>: Secret.USER_AGENT,<br>    <span class="hljs-string">&quot;Cookie&quot;</span>: Secret.COOKIE,<br>    <span class="hljs-string">&quot;Host&quot;</span>: <span class="hljs-string">&quot;www.douban.com&quot;</span>,<br>    <span class="hljs-string">&quot;Origin&quot;</span>: <span class="hljs-string">&quot;https://www.douban.com&quot;</span>,<br>    <span class="hljs-string">&quot;Referer&quot;</span>: <span class="hljs-string">&quot;https://www.douban.com/misc/sorry?original-url=https://www.douban.com/group/&quot;</span>,<br>    <span class="hljs-string">&quot;Content-Type&quot;</span>: <span class="hljs-string">&quot;application/x-www-form-urlencoded&quot;</span><br>&#125;<br><br>form = &#123;<br>    <span class="hljs-string">&quot;ck&quot;</span>: <span class="hljs-string">&quot;Un0d&quot;</span>,<br>    <span class="hljs-string">&quot;captcha-solution&quot;</span>: <span class="hljs-string">&quot;money&quot;</span>,<br>    <span class="hljs-string">&quot;captcha-id&quot;</span>: <span class="hljs-string">&quot;iLO5m9Y0xdMKXkSzW8ML5Tqr:en&quot;</span>,<br>    <span class="hljs-string">&quot;original-url&quot;</span>: <span class="hljs-string">&quot;https://www.douban.com/group/&quot;</span><br>&#125;<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fetch</span>(<span class="hljs-params">session</span>):</span><br>    url = <span class="hljs-string">&quot;https://www.douban.com/misc/sorry&quot;</span><br>    is_access = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> is_access: <span class="hljs-comment"># 循环，上一次的结果在下一次循环时提交</span><br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.post(url, headers=headers, data=form) <span class="hljs-keyword">as</span> response:<br><br>                <span class="hljs-keyword">if</span> response.url.__str__()[:<span class="hljs-number">33</span>] != <span class="hljs-string">&quot;https://www.douban.com/misc/sorry&quot;</span>:<br>                    is_access = <span class="hljs-literal">True</span><br><br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> is_access:<br>                    text = <span class="hljs-keyword">await</span> response.text()<br>                    soup = BeautifulSoup(text, <span class="hljs-string">&quot;lxml&quot;</span>)<br>                    img_elements = soup.find_all(<span class="hljs-string">&quot;img&quot;</span>)<br>                    img_src = img_elements[<span class="hljs-number">0</span>].get(<span class="hljs-string">&#x27;src&#x27;</span>) <span class="hljs-comment"># 获取图片地址</span><br>                    img_id = img_src[<span class="hljs-number">39</span>:]   <span class="hljs-comment"># 获取图片id</span><br><br>                    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;list/captcha.jfif&quot;</span>, <span class="hljs-string">&#x27;wb+&#x27;</span>) <span class="hljs-keyword">as</span> f: <span class="hljs-comment"># 保存图片到本地</span><br>                        res = requests.get(img_src, headers=headers)<br>                        f.write(res.content)<br>                        f.close()<br>                    img = ImageOCR.Img()    <span class="hljs-comment"># 执行OCR</span><br>                    solution = img.deocr()<br><br>                form[<span class="hljs-string">&#x27;captcha-solution&#x27;</span>] = solution<br>                form[<span class="hljs-string">&#x27;captcha-id&#x27;</span>] = img_id<br>                <span class="hljs-built_in">print</span>(form)<br>        <span class="hljs-keyword">except</span>:<br>            is_access = <span class="hljs-literal">None</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;access&quot;</span>)<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiohttp.ClientSession() <span class="hljs-keyword">as</span> session:<br>        <span class="hljs-keyword">await</span> fetch(session)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    loop = asyncio.get_event_loop()<br>    loop.run_until_complete(main())<br><br></code></pre></td></tr></table></figure><h2 id="ocr"><a class="markdownIt-Anchor" href="#ocr"></a> OCR</h2><p>懒得写了现在，有时间再补吧</p>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>爬虫</tag>
      
      <tag>OCR</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[tampermonkey]Edge油猴插件安装教程</title>
    <link href="/p/51a9/"/>
    <url>/p/51a9/</url>
    
    <content type="html"><![CDATA[<p>本文旨在帮助读者进行油猴插件的安装，由于Edge平台没有需要翻墙的阻碍，所以我们选择他进行介绍</p><span id="more"></span><h2 id="从应用商店安装油猴"><a class="markdownIt-Anchor" href="#从应用商店安装油猴"></a> 从应用商店安装油猴</h2><p>使用最新版的Edge浏览器</p><p>打开<a href="https://microsoftedge.microsoft.com/addons/detail/tampermonkey/iikmkjmpaadaobahmlepeloendndfphd?source=sfw">Tampermonkey - Microsoft Edge Addons</a>，并进行安装</p><p>![](/img/[tampermonkey] Edge油猴插件安装教程/image-20210808173309417.png)</p><p>安装成功后，应该可以从右上角看到插件的图标</p><p>![](/img/[tampermonkey] Edge油猴插件安装教程/image-20210808173555488.png)</p><h2 id="从脚本网站加载脚本"><a class="markdownIt-Anchor" href="#从脚本网站加载脚本"></a> 从脚本网站加载脚本</h2><h3 id="greasyfork"><a class="markdownIt-Anchor" href="#greasyfork"></a> GreasyFork</h3><p><strong>通过链接打开</strong></p><p><a href="https://greasyfork.org/zh-CN">Greasy Fork - 安全、实用的用户脚本大全</a></p><p><strong>通过油猴插件打开</strong></p><p>点击插件，选择&quot;获取新脚本&quot;</p><p>![](/img/[tampermonkey] Edge油猴插件安装教程/image-20210808174148253.png)</p><p>然后在下面找到并点选GreasyFork链接</p><p>![](/img/[tampermonkey] Edge油猴插件安装教程/image-20210808174315114.png)</p><p>搜索自己需要的插件即可</p><h3 id="找脚本"><a class="markdownIt-Anchor" href="#找脚本"></a> 找脚本</h3><p><strong>通过链接打开</strong></p><p><a href="https://www.zhaojiaoben.cn/">找脚本——找任何你需要的脚本 (zhaojiaoben.cn)</a></p><p>搜索自己需要的插件即可</p><h2 id="安装脚本"><a class="markdownIt-Anchor" href="#安装脚本"></a> 安装脚本</h2><p>上面两个脚本网站安装脚本时都会弹出新界面，点击安装即可</p><p><strong>我们以刷课脚本为例</strong></p><p>打开<a href="https://www.zhaojiaoben.cn/">找脚本——找任何你需要的脚本 (zhaojiaoben.cn)</a></p><p>首页就有该脚本，点击直接安装</p><p>![](/img/[tampermonkey] Edge油猴插件安装教程/image-20210808175933672.png)</p><p>然后在弹出的界面选择安装即可</p><h2 id="管理脚本"><a class="markdownIt-Anchor" href="#管理脚本"></a> 管理脚本</h2><p>当脚本安装后，到可用网页会自动生效，油猴插件图标会自动亮起</p><p>![](/img/[tampermonkey] Edge油猴插件安装教程/image-20210808174913530.png)</p><p>我们点击插件后，可以管理当前页面生效的脚本，也可以点击&quot;管理面板&quot;管理所有脚本</p><p>![](/img/[tampermonkey] Edge油猴插件安装教程/image-20210808174955539.png)</p>]]></content>
    
    
    
    <tags>
      
      <tag>实用</tag>
      
      <tag>Tampermonkey</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[nginx]Nginx ubuntu部署</title>
    <link href="/p/740/"/>
    <url>/p/740/</url>
    
    <content type="html"><![CDATA[<p>本文将演示如何在ubuntu上部署nginx，并实现对以 <a href="http://rank.allenji.cn">rank.allenji.cn</a> 为例的前后端分发和 https部署</p><span id="more"></span><h2 id="安装nginx"><a class="markdownIt-Anchor" href="#安装nginx"></a> 安装nginx</h2><p>使用命令行安装nginx</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo apt <span class="hljs-keyword">install</span> nginx<br></code></pre></td></tr></table></figure><h2 id="配置nginx"><a class="markdownIt-Anchor" href="#配置nginx"></a> 配置nginx</h2><p><strong>进入目录</strong></p><p>进入nginx默认安装目录: /etc/nginx</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd <span class="hljs-regexp">/etc/</span>nginx<br></code></pre></td></tr></table></figure><p><img src="/img/image-20210807132620388.png" alt="image-20210807132620388" /></p><p>这时打开“nginx.conf&quot;</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">sudo <span class="hljs-keyword">vim</span> nginx.<span class="hljs-keyword">conf</span><br></code></pre></td></tr></table></figure><p>文档内容如下:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">user</span> www-data;<br><span class="hljs-attribute">worker_processes</span> auto;<br><span class="hljs-attribute">pid</span> /run/nginx.pid;<br><span class="hljs-attribute">include</span> /etc/nginx/modules-enabled/<span class="hljs-regexp">*.conf</span>;<br><br><span class="hljs-section">events</span> &#123;<br>        <span class="hljs-attribute">worker_connections</span> <span class="hljs-number">768</span>;<br>        <span class="hljs-comment"># multi_accept on;</span><br>&#125;<br><br><span class="hljs-section">http</span> &#123;<br><br>        <span class="hljs-comment">##</span><br>        <span class="hljs-comment"># Basic Settings</span><br>        <span class="hljs-comment">##</span><br><br>        <span class="hljs-attribute">sendfile</span> <span class="hljs-literal">on</span>;<br>        <span class="hljs-attribute">tcp_nopush</span> <span class="hljs-literal">on</span>;<br>        <span class="hljs-attribute">tcp_nodelay</span> <span class="hljs-literal">on</span>;<br>        <span class="hljs-attribute">keepalive_timeout</span> <span class="hljs-number">65</span>;<br>        <span class="hljs-attribute">types_hash_max_size</span> <span class="hljs-number">2048</span>;<br>        <span class="hljs-comment"># server_tokens off;</span><br><br>        <span class="hljs-comment"># server_names_hash_bucket_size 64;</span><br>        <span class="hljs-attribute">include</span> /etc/nginx/mime.types;<br>        <span class="hljs-attribute">default_type</span> application/octet-stream;<br><br>        <span class="hljs-comment">##</span><br><br>        <span class="hljs-attribute">ssl_protocols</span> TLSv1 TLSv1.<span class="hljs-number">1</span> TLSv1.<span class="hljs-number">2</span> TLSv1.<span class="hljs-number">3</span>; <span class="hljs-comment"># Dropping SSLv3, ref: POODLE</span><br>        <span class="hljs-attribute">ssl_prefer_server_ciphers</span> <span class="hljs-literal">on</span>;<br><br>        <span class="hljs-comment">##</span><br>        <span class="hljs-comment"># Logging Settings</span><br>        <span class="hljs-comment">##</span><br><br>        <span class="hljs-attribute">access_log</span> /var/log/nginx/access.log;<br>        <span class="hljs-attribute">error_log</span> /var/log/nginx/error.log;<br><br>        <span class="hljs-comment">##</span><br>        <span class="hljs-comment"># Gzip Settings</span><br>        <span class="hljs-comment">##</span><br><br>        <span class="hljs-attribute">gzip</span> <span class="hljs-literal">on</span>;<br><br>        <span class="hljs-comment"># gzip_vary on;</span><br>        <span class="hljs-comment"># gzip_proxied any;</span><br>        <span class="hljs-comment"># gzip_comp_level 6;</span><br>        <span class="hljs-comment"># gzip_buffers 16 8k;</span><br>        <span class="hljs-comment"># gzip_http_version 1.1;</span><br><br>        <span class="hljs-comment">##</span><br>        <span class="hljs-comment"># Virtual Host Configs</span><br>        <span class="hljs-comment">##</span><br><br>        <span class="hljs-attribute">include</span> /etc/nginx/conf.d/<span class="hljs-regexp">*.conf</span>;<br>        <span class="hljs-attribute">include</span> /etc/nginx/sites-enabled/*;<br>&#125;<br><br><br><span class="hljs-comment">#mail &#123;</span><br><span class="hljs-comment">#       # See sample authentication script at:</span><br><span class="hljs-comment">#       # http://wiki.nginx.org/ImapAuthenticateWithApachePhpScript</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#       # auth_http localhost/auth.php;</span><br><span class="hljs-comment">#       # pop3_capabilities &quot;TOP&quot; &quot;USER&quot;;</span><br><span class="hljs-comment">#       # imap_capabilities &quot;IMAP4rev1&quot; &quot;UIDPLUS&quot;;</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#       server &#123;</span><br><span class="hljs-comment">#               listen     localhost:110;</span><br><span class="hljs-comment">#               protocol   pop3;</span><br><span class="hljs-comment">#               proxy      on;</span><br><span class="hljs-comment">#       &#125;</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#       server &#123;</span><br><span class="hljs-comment">#               listen     localhost:143;</span><br><span class="hljs-comment">#               protocol   imap;</span><br><span class="hljs-comment">#               proxy      on;</span><br><span class="hljs-comment">#       &#125;</span><br><span class="hljs-comment">#&#125;</span><br></code></pre></td></tr></table></figure><p>由</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">include</span> <span class="hljs-regexp">/etc/</span>nginx<span class="hljs-regexp">/conf.d/</span>*.conf;<br><span class="hljs-keyword">include</span> <span class="hljs-regexp">/etc/</span>nginx<span class="hljs-regexp">/sites-enabled/</span>*;<br></code></pre></td></tr></table></figure><p>这两行可知，配置文件定义在这两个文件夹里</p><p><strong>进入次级目录</strong></p><p>为了方便管理，我们进入&quot;site-enabled&quot;目录并分站点定义配置文件</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">cd</span> sites-enabled<br>sudo touch rank.<span class="hljs-keyword">conf</span><br>sudo <span class="hljs-keyword">vim</span> rank.<span class="hljs-keyword">conf</span><br></code></pre></td></tr></table></figure><p>我们将rank.conf写成这样</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br><span class="hljs-attribute">listen</span> <span class="hljs-number">443</span> ssl;<span class="hljs-comment">#听ssl端口</span><br><span class="hljs-attribute">server_name</span> rank.allenji.cn;<span class="hljs-comment">#站点名</span><br><span class="hljs-attribute">root</span> /home/wwwroot/rank;<span class="hljs-comment">#站点静态单页地址</span><br><span class="hljs-attribute">location</span> / &#123;<br><span class="hljs-attribute">index</span> index.html;<span class="hljs-comment">#站点单页的index.html</span><br>&#125;<br><span class="hljs-attribute">location</span> /api/ &#123;<br><span class="hljs-attribute">proxy_pass</span> https://localhost:8080; <span class="hljs-comment">#将/api的请求转发到后端接口</span><br>&#125;<br><br><br><span class="hljs-comment">#ssl配置 请参考各大服务器运营商的ssl部署教程</span><br><br><span class="hljs-attribute">ssl_certificate</span> ssl/1_rank.allenji.cn_bundle.crt;<br><span class="hljs-attribute">ssl_certificate_key</span> ssl/2_rank.allenji.cn.key;<br><span class="hljs-attribute">ssl_session_timeout</span> <span class="hljs-number">5m</span>;<br><span class="hljs-attribute">ssl_protocols</span> TLSv1 TLSv1.<span class="hljs-number">1</span> TLSv1.<span class="hljs-number">2</span>;<br><span class="hljs-attribute">ssl_ciphers</span> ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;<br><span class="hljs-attribute">ssl_prefer_server_ciphers</span> <span class="hljs-literal">on</span>;<br><br>&#125;<br><br><span class="hljs-section">server</span> &#123;<span class="hljs-comment">#强制将http访问的请求转发到https</span><br><span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;<br><span class="hljs-attribute">server_name</span> rank.allenji.cn;<br><span class="hljs-attribute">return</span> <span class="hljs-number">301</span> https://$host$request_uri;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>如上，站点的conf就配置完毕了</p><p><strong>重载配置文件</strong></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo nginx -s reload</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>ubuntu</tag>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[cpp]单调栈</title>
    <link href="/p/7ebb/"/>
    <url>/p/7ebb/</url>
    
    <content type="html"><![CDATA[<p><strong>何为单调栈？</strong><br />顾名思义，就是单调的栈，我们维护一个栈，栈中的元素保持非严格单调递增或递减。</p><span id="more"></span><p>此算法在处理一些问题时莫名其妙（雾）的有效，是一个典型的空间换时间的算法。</p><h2 id="1-最大的矩形-csp201312-3-leetcode-84"><a class="markdownIt-Anchor" href="#1-最大的矩形-csp201312-3-leetcode-84"></a> 1. 最大的矩形 [CSP]201312-3 / [LeetCode] 84.</h2><p>问题描述<br />在横轴上放了n个相邻的矩形，每个矩形的宽度是1，而第i（1 ≤ i ≤ n）个矩形的高度是hi。这n个矩形构成了一个直方图。例如，下图中六个矩形的高度就分别是3, 1, 6, 5, 2, 3。<br /><img src="https://img-blog.csdnimg.cn/2020121717482394.png" alt="" /></p><p>请找出能放在给定直方图里面积最大的矩形，它的边要与坐标轴平行。对于上面给出的例子，最大矩形如下图所示的阴影部分，面积是10。<br /><img src="https://img-blog.csdnimg.cn/20201217174844858.png" alt="" /></p><p><strong>输入格式</strong><br />第一行包含一个整数n，即矩形的数量(1 ≤ n ≤ 1000)。<br />第二行包含n 个整数h1, h2, … , hn，相邻的数之间由空格分隔。(1 ≤ hi ≤ 10000)。hi是第i个矩形的高度。<br />　　<br /><strong>输出格式</strong><br />输出一行，包含一个整数，即给定直方图内的最大矩形的面积。<br />　　<br /><strong>样例输入</strong><br />6<br />3 1 6 5 2 3</p><p><strong>样例输出</strong><br />10</p><p><strong>题解</strong><br />我们可以维持一个单调递增的栈，为了便于计算矩形宽度，我们在栈里存放单个矩形的位置。<br />我们从左到右遍历高度数组，对于每个矩形的高度p，如果p大于等于当前栈顶储存位置的高度q，我们将p的位置也压入栈中；<br />如果p小于q，我们将q弹出，纪录高度，并记录当前遍历到的矩形p与新栈顶位置之差(实际上还需要减1)，作为宽度，并更新结果。<br />为避免栈中剩余矩形，我们可以在数组尾插入一个高度为零的矩形，使栈中所有矩形弹出并更新。</p><p><strong>代码实现</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; heights)</span> </span>&#123;<br>heights.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<span class="hljs-comment">//插入空矩形，弹出栈中剩余矩形</span><br><span class="hljs-keyword">int</span> len = heights.<span class="hljs-built_in">size</span>(), area = <span class="hljs-number">0</span>, pre_index, height, width;<br>stack&lt;<span class="hljs-keyword">int</span>&gt; indices;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br><span class="hljs-keyword">while</span> (!indices.<span class="hljs-built_in">empty</span>() &amp;&amp; heights[indices.<span class="hljs-built_in">top</span>()] &gt; heights[i]) &#123;<span class="hljs-comment">//检查栈是否为空</span><br>pre_index = indices.<span class="hljs-built_in">top</span>();<span class="hljs-comment">//储存栈顶矩形的位置</span><br>indices.<span class="hljs-built_in">pop</span>();<br>height = heights[pre_index];<span class="hljs-comment">//储存高度</span><br><span class="hljs-keyword">if</span> (indices.<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-comment">//避免操作空栈</span><br>width = i;<span class="hljs-comment">//若弹出至栈为空，因栈的递增性，边界可向左延伸至0</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>width = i - indices.<span class="hljs-built_in">top</span>() - <span class="hljs-number">1</span>;<span class="hljs-comment">//储存宽度</span><br>&#125;<br>area = area &gt; (width * height) ? area : (width * height);<span class="hljs-comment">//更新结果</span><br>&#125;<br>indices.<span class="hljs-built_in">push</span>(i);<br>&#125;<br><span class="hljs-keyword">return</span> area;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2每日温度-leetcode-739"><a class="markdownIt-Anchor" href="#2每日温度-leetcode-739"></a> 2.每日温度 [LeetCode] 739.</h2><p><strong>问题描述</strong></p><p>请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。<br />例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。<br />提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。</p><p><strong>题解</strong></p><p>我们在这里维持一个单调递减的栈，为了便于计算天数差，我们在栈中储存位置(即日期)。<br />此题相较上题简单一些，故不在此赘述。<br /><strong>注意：</strong><br />此题与上题不同的是，若栈中有剩余的日期，说明此后没有更暖和的日期，故无需再弹出。</p><p><strong>代码实现</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dailyTemperatures</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; T)</span> </span>&#123;<br><span class="hljs-keyword">int</span> n = T.<span class="hljs-built_in">size</span>(), pre_index;<br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n)</span></span>;<br>stack&lt;<span class="hljs-keyword">int</span>&gt; indices;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br><span class="hljs-keyword">while</span> (!indices.<span class="hljs-built_in">empty</span>() &amp;&amp; T[indices.<span class="hljs-built_in">top</span>()] &lt; T[i]) &#123;<br>pre_index = indices.<span class="hljs-built_in">top</span>();<br>indices.<span class="hljs-built_in">pop</span>();<br>ans[pre_index] = i - pre_index;<span class="hljs-comment">//计算日期差</span><br>&#125;<br>indices.<span class="hljs-built_in">push</span>(i);<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[cpp]gcd&amp;lcm</title>
    <link href="/p/c73b/"/>
    <url>/p/c73b/</url>
    
    <content type="html"><![CDATA[<p>写了一万年这俩算法，还是记不住，这次强化记忆一下</p><span id="more"></span><h2 id="gcd"><a class="markdownIt-Anchor" href="#gcd"></a> GCD</h2><h3 id="基础循环"><a class="markdownIt-Anchor" href="#基础循环"></a> 基础循环</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123;<br><span class="hljs-keyword">int</span> r;<br>    <span class="hljs-keyword">while</span>(b&gt;<span class="hljs-number">0</span>) &#123;<br>        r=a%b;<br>        a=b;<br>        b=r;<br>    &#125;<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="位运算"><a class="markdownIt-Anchor" href="#位运算"></a> 位运算</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (b^=a^=b^=a%=b);  <span class="hljs-comment">//a%=b,swap(a,b)</span><br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="gcd库函数"><a class="markdownIt-Anchor" href="#gcd库函数"></a> gcd库函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span> </span>&#123;<br><span class="hljs-keyword">return</span> __gcd(a,b);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="lcm"><a class="markdownIt-Anchor" href="#lcm"></a> LCM</h2><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>∗</mo><mi>b</mi><mo>=</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>l</mi><mi>c</mi><mi>m</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a*b = gcd(a,b) * lcm(a,b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">c</span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lcm</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123;<br><span class="hljs-keyword">return</span> a*b/<span class="hljs-built_in">gcd</span>(a,b);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
