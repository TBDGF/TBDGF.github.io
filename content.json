{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/07/11/hello-world/"},{"title":"","text":"单调栈何为单调栈？顾名思义，就是单调的栈，我们维护一个栈，栈中的元素保持非严格单调递增或递减。此算法在处理一些问题时莫名其妙（雾）的有效，是一个典型的空间换时间的算法。 1. 最大的矩形 [CSP]201312-3 / [LeetCode] 84.问题描述在横轴上放了n个相邻的矩形，每个矩形的宽度是1，而第i（1 ≤ i ≤ n）个矩形的高度是hi。这n个矩形构成了一个直方图。例如，下图中六个矩形的高度就分别是3, 1, 6, 5, 2, 3。 请找出能放在给定直方图里面积最大的矩形，它的边要与坐标轴平行。对于上面给出的例子，最大矩形如下图所示的阴影部分，面积是10。 输入格式第一行包含一个整数n，即矩形的数量(1 ≤ n ≤ 1000)。第二行包含n 个整数h1, h2, … , hn，相邻的数之间由空格分隔。(1 ≤ hi ≤ 10000)。hi是第i个矩形的高度。 输出格式输出一行，包含一个整数，即给定直方图内的最大矩形的面积。 样例输入63 1 6 5 2 3 样例输出10 题解我们可以维持一个单调递增的栈，为了便于计算矩形宽度，我们在栈里存放单个矩形的位置。我们从左到右遍历高度数组，对于每个矩形的高度p，如果p大于等于当前栈顶储存位置的高度q，我们将p的位置也压入栈中；如果p小于q，我们将q弹出，纪录高度，并记录当前遍历到的矩形p与新栈顶位置之差(实际上还需要减1)，作为宽度，并更新结果。为避免栈中剩余矩形，我们可以在数组尾插入一个高度为零的矩形，使栈中所有矩形弹出并更新。 代码实现 1234567891011121314151617181920int largestRectangleArea(vector&lt;int&gt;&amp; heights) { heights.push_back(0); //插入空矩形，弹出栈中剩余矩形 int len = heights.size(), area = 0, pre_index, height, width; stack&lt;int&gt; indices; for (int i = 0; i &lt; len; i++) { while (!indices.empty() &amp;&amp; heights[indices.top()] &gt; heights[i]) { //检查栈是否为空 pre_index = indices.top(); //储存栈顶矩形的位置 indices.pop(); height = heights[pre_index]; //储存高度 if (indices.empty()) { //避免操作空栈 width = i; //若弹出至栈为空，因栈的递增性，边界可向左延伸至0 } else { width = i - indices.top() - 1; //储存宽度 } area = area &gt; (width * height) ? area : (width * height); //更新结果 } indices.push(i); } return area;} 2.每日温度 [LeetCode] 739.问题描述 请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。 题解 我们在这里维持一个单调递减的栈，为了便于计算天数差，我们在栈中储存位置(即日期)。此题相较上题简单一些，故不在此赘述。注意：此题与上题不同的是，若栈中有剩余的日期，说明此后没有更暖和的日期，故无需再弹出。 代码实现 1234567891011121314vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; T) { int n = T.size(), pre_index; vector&lt;int&gt; ans(n); stack&lt;int&gt; indices; for (int i = 0; i &lt; n; i++) { while (!indices.empty() &amp;&amp; T[indices.top()] &lt; T[i]) { pre_index = indices.top(); indices.pop(); ans[pre_index] = i - pre_index; //计算日期差 } indices.push(i); } return ans;}","link":"/2021/07/11/%E5%8D%95%E8%B0%83%E6%A0%88/"}],"tags":[],"categories":[]}